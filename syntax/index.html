<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta content="width=device-width,initial-scale=1" name="viewport" />
    <title>Model for Tabular Data and Metadata on the Web</title>
    <script class="remove" src="http://www.w3.org/Tools/respec/respec-w3c-common">
		</script>
    <script class="remove">
var respecConfig = {
    localBiblio: {
       "tabular-metadata": {
            "authors": [
              "Rufus Pollock",
              "Jeni Tennison"
            ],
            "title": "Metadata Vocabulary for Tabular Data",
            "href" : "http://www.w3.org/TR/2014/WD-tabular-metadata-20140710/",
            "rawDate": "2014-07-10",
            "status" : "WD",
            "publisher": "W3C"
        },
        "EBNF-NOTATION" : {
          "authors" : [
            "Tim Bray",
            "Jean Paoli",
            "C. Michael Sperberg-McQueen",
            "Eve Maler",
            "François Yergau"
          ],
          "title" : "EBNF Notation",
          "rawDate" : "2008-11-26",
          "status" : "REC",
          "publisher" : "W3C",
          "href" : "http://www.w3.org/TR/REC-xml/#sec-notation"
        },
        "RFC7111" : {
          "authors" : [
            "Michael Hausenblas",
            "Erik Wilde",
            "Jenni Tennison"
          ],
          "title" : "URI Fragment Identifiers for the text/csv Media Type",
          "rawDate" : "2014-01",
          "status": "Internet RFC",
          "publisher" : "IETF",
          "href" : "http://www.ietf.org/rfc/rfc7111.txt"
        }
    },
    specStatus: "ED",
    shortName: "tabular-data-model",
    //publishDate:  "2014-03-27",
    previousPublishDate: "2014-03-27",
    previousMaturity: "FPWD",
    previousURI: "http://www.w3.org/TR/2014/WD-tabular-data-model-20140327/",
    edDraftURI: "http://w3c.github.io/csvw/syntax/",
    // lcEnd: "3000-01-01",
    // crEnd: "3000-01-01",
    editors: [{
      name: "Jeni Tennison",
      company: "Open Data Institute",
      companyURL: "http://theodi.org/"
    }, { 
      name: "Gregg Kellogg", 
      url: "http://greggkellogg.net/",
      company: "Kellogg Associates", 
      companyURL: "http://kellogg-assoc.com/" 
    }],
    wg: "CSV on the Web Working Group",
    wgURI: "http://www.w3.org/2013/csvw/",
    wgPublicList: "public-csv-wg",
    wgPatentURI: "http://www.w3.org/2004/01/pp-impl/68238/status",
    otherLinks: [{
      key: "Repository",
      data: [{
          value: "We are on Github",
          href: "https://github.com/w3c/csvw"
      }, {
          value: "File a bug",
          href: "https://github.com/w3c/csvw"
      }]
      }, {
      key: "Changes",
        data: [{
          value: "Diff to previous version",
          href: "diff-20140327.html"
        }, {
          value: "Commit history",
          href: "https://github.com/w3c/csvw/commits/gh-pages"
      }]
    }],
    inlineCSS: true,
    issueBase: "https://github.com/w3c/csvw/issues/",
    noIDLIn: true,
    noLegacyStyle: false
    };
    </script>
    <style type="text/css">
      .grammar td { font-family: monospace; vertical-align: top; }
      .grammar-literal { color: gray;}
    </style>
  </head>
  <body>
    <section id="abstract">
      <p>
        Tabular data is routinely transferred on the web as "CSV", but the definition of "CSV" in practice is very loose. This document outlines a basic data model or infoset for tabular data and metadata about that tabular data. It also contains some non-normative information about a best practice syntax for tabular data, for mapping into that data model, to contribute to the standardisation of CSV syntax by IETF. Various methods of locating metadata are also provided.
      </p>
    </section>
    <section id="sotd">
      <p>
        The CSV on the Web Working Group was chartered to produce a Recommendation "Access methods for CSV Metadata" as well as Recommendations for "Metadata vocabulary for CSV data" and "Mapping mechanism to transforming CSV into various Formats (e.g., RDF, JSON, or XML)". This document aims to primarily satisfy the first of those Recommendations (see <a href="#locating-metadata" class="sectionRef"></a>), though it also specifies an underlying model and therefore starting point for the other chartered Recommendations.
      </p>
      <p>
        This document is based on IETF's [[!RFC4180]] which is an Informational RFC. The working group's expectation is that future suggestions to refine RFC 4180 will be relayed to the IETF (e.g. around I18N and multi-part packaging) and contribute to its discussions about moving CSV to the Standards track.
      </p>
      <p>
        Many "CSV" files embed metadata, for example in lines before the header row of the CSV document. This specification does not define any formats for embedding metadata within CSV files, aside from the names of columns in the header row.
      </p>
    </section>
    <section id="intro">
      <h2>Introduction</h2>
      <p>
        <dfn title="tabular data">Tabular data</dfn> is data that is structured into rows, each of which contains information about some thing. Each row contains the same number of cells (although some of these cells may be empty), which provide values of properties of the thing described by the row. In tabular data, cells within the same column provide values for the same property of the thing described by the particular row. This is what differentiates tabular data from other line-oriented formats. 
      </p>
    	<p>
        Tabular data is routinely transferred on the web in a textual format called "CSV", but the definition of "CSV" in practice is very loose. Some people use the term to mean any delimited text file. Others stick more closely to the most standard definition of CSV that there is, [[!RFC4180]]. <a href="#standards" class="sectionRef">Appendix A</a> describes the various ways in which CSV is defined.
      </p>
    </section>
    <section id="model">
      <h2>Tabular Data Models</h2>
      <p>
        There are different levels of data models for tabular data:
      </p>
      <ul>
        <li>The <dfn>core tabular data model</dfn> described in <a href="#core-tabular-data-model" class="sectionRef"></a> defines the core model for a single table of basic data.</li>
        <li>The <dfn>annotated tabular data model</dfn> described in <a href="#annotated-tabular-data-model" class="sectionRef"></a> defines a model for tables that are annotated with metadata.</li>
        <li>The <dfn>grouped tabular data model</dfn> described in <a href="#grouped-tabular-data-model" class="sectionRef"></a> defines a model for tables that are related to each other in some way.</li>
      </ul>
      <section>
        <h3>Core Tabular Data Model</h3>
        <p>
          The core tabular data model can be used to describe a table that lacks any annotations, whether those annotations are embedded within a CSV file or arise from a separate metadata document.
        </p>
        <p>
          Data is held in a <dfn>table</dfn>. The properties of a table are:
        </p>
        <ul>
          <li><dfn title="table columns">columns</dfn> &mdash; the list of <a title="column">columns</a> in the table. A table MUST have one or more columns and the order of the columns within the list is significant and MUST be preserved by applications</li>
          <li><dfn title="table rows">rows</dfn> &mdash; the list of rows in the table</li>
        </ul>
        <p>
          A <dfn>column</dfn> represents a vertical arrangement of <a title="cell">cells</a> within a <a>table</a>. The properties of a column are:
        </p>
        <ul>
          <li><dfn title="column table">table</dfn> &mdash; the <a>table</a> that the column appears in</li>
          <li><dfn title="column number">number</dfn> &mdash; the position of the column amongst the <a title="table columns">columns</a> for the associated <a title="column table">table</a>, starting from 1</li>
          <li><dfn title="column cells">cells</dfn> &mdash; the list of <a title="cell">cells</a> in the column. A column MUST contain one cell from each <a>row</a> in the table. The order of the cells in the list MUST match the order of the rows in which they appear within the <a title="table rows">rows</a> for the associated <a title="column table">table</a>.</li>
        </ul>
        <p>
          A <dfn>row</dfn> represents a horizontal arrangement of <a title="cell">cells</a> within a <a>table</a>. The properties of a row are:
        </p>
        <ul>
          <li><dfn title="row table">table</dfn> &mdash; the <a>table</a> that the row appears in</li>
          <li><dfn title="row number">number</dfn> &mdash; the position of the row amongst the <a title="table rows">rows</a> for the <a title="row table">table</a>, starting from 1</li>
          <li><dfn title="row cells">cells</dfn> &mdash; the list of <a title="cell">cells</a> in the row. A row MUST contain one cell from each <a>column</a> in the table. The order of the cells in the list MUST match the order of the columns in which they appear within the <a>table columns</a> for the row's table.</li>
        </ul>
        <p>
          A <dfn>cell</dfn> represents a cell at the intersection of a <a>row</a> and a <a>column</a> within a <a>table</a>. The properties of a cell are:
        </p>
        <ul>
          <li><dfn title="cell table">table</dfn> &mdash; the <a>table</a> that the cell appears in</li>
          <li><dfn title="cell column">column</dfn> &mdash; the <a>column</a> that the cell appears in; the cell MUST be in the <a title="column cells">cells</a> for that column</li>
          <li><dfn title="cell row">row</dfn> &mdash; the <a>row</a> that the cell appears in; the cell MUST be in the <a title="row cells">cells</a> for that row</li>
          <li><dfn>string value</dfn> &mdash; a string that is the original syntactic representation of the value of the cell, ie how the cell appears within a CSV file; this may be an empty string</li>
          <li><dfn title="cell value">value</dfn> &mdash; the semantic value of the cell; within the core tabular data model (with no other metadata available) this is either a string which is the same as the <a>string value</a> of the cell, or <code>null</code>, if the <a>string value</a> is an empty string</li>
        </ul>
        <p class="issue" data-number="40">
          Should an empty string value always count as a <code>null</code> semantic value within the core data model (ie when there is no other metadata telling the processor how to interpret that value), or should the semantic value be an empty string?
        </p>
        <p class="note">
          There presence or absence of quotes around a value within a CSV file is a syntactic detail that is not reflected in the tabular data model. In other words, there is no distinction in the model between the second value in <code>a,,z</code> and the second value in <code>a,"",z</code>.
        </p>
      </section>
      <section>
        <h3>Annotated Tabular Data Model</h3>
        <p>
          An <dfn>annotated table</dfn> is a <a>table</a> that is annotated with additional metadata. The table MAY have any number of <dfn title="property">properties</dfn> in addition to those provided in the core tabular data model described in <a href="#core-tabular-data-model" class="sectionRef"></a> which provide information about the table as a whole. The <dfn title="value">values</dfn> of these properties may be lists, structured objects, or atomic values. Annotations on a table may include:
        </p>
        <ul>
          <li>titles or descriptions of the table</li>
          <li>information about the source or provenance of the data in the table</li>
          <li>links to other tables (eg to indicate tables that include related information)</li>
        </ul>
        <p>
          The <a title="column">columns</a> within an <a>annotated table</a> are all <dfn title="annotated column">annotated columns</dfn>: columns which MAY have any number of <a title="property">properties</a> in addition to those provided in the core tabular data model described in <a href="#core-tabular-data-model" class="sectionRef"></a>. The annotations on a column might provide information about how to interpret the <a title="cell">cells</a> in the column or information about the column as a whole. Examples of annotations might be:
        </p>
        <ul>
          <li>a name or label for the column</li>
          <li>the expected type of values in that column</li>
          <li>an indication of whether the column contains unique values</li>
        </ul>
        <p>
          The <a title="row">rows</a> within an <a>annotated table</a> are all <dfn title="annotated row">annotated rows</dfn>: rows which MAY have any number of <a title="property">properties</a> in addition to those provided in the core tabular data model described in <a href="#core-tabular-data-model" class="sectionRef"></a>. The annotations on a row provide additional metadata about the information held in the row, such as:
        </p>
        <ul>
          <li>the certainty of the information in that row</li>
          <li>information about the source or provenance of the data in that row</li>
        </ul>
        <p>
          The <a title="cell">cells</a> within an <a>annotated row</a> are all <dfn title="annotated cell">annotated cells</dfn>: cells which MAY have any number of <a title="property">properties</a> in addition to those provided in the core tabular data model described in <a href="#core-tabular-data-model" class="sectionRef"></a>. The annotations on a cell provide metadata about the value held in the cell, particularly when this overrides the information provided for the <a>annotated column</a> and <a>annotated row</a> that the cell falls within. Annotations on a cell might be:
        </p>
        <ul>
          <li>notes to aid the interpretation of the value</li>
          <li>type annotations for the value</li>
          <li>a flag that indicates the value is a null value</li>
        </ul>
        <p>
          The <a title="cell value">value</a> of an <a>annotated cell</a> MAY be of a datatype other than a string. For example, annotations might enable a processor to understand the <a>string value</a> of the cell as representing a number or a date.
        </p>
        <p class="issue" data-number="41">
          The permitted types of names and values of annotations need to be spelled out here.
        </p>
      </section>
      <section>
        <h3>Grouped Tabular Data Model</h3>
        <p>
          A <dfn>group of tables</dfn> comprises a set of <a title="table">tables</a> (which may be <a title="annotated table">annotated tables</a>) and a set of annotations (<a title="property">properties</a> and <a title="value">values</a>) that relate to the set.
        </p>
        <p class="note">
          Tables can be loosely related to each other simply through annotations; not all tables that are related to each other need to grouped together. Groups of tables are useful because they can be annotated with metadata that applies to all the tables in the group.
        </p>
      </section>
    </section>
    <section>
      <h2>Locating Metadata</h2>
      <p>
        As described in <a href="#annotated-tabular-data-model" class="sectionRef"></a>, tabular data may have a number of annotations associated with it. Here we describe the different methods that can be used to locate those annotations given a link to a CSV file.
      </p>
      <p>
        In most methods of locating metadata described here, metadata is provided within a separate document. The syntax of this document is defined in the <a href="http://w3c.github.io/csvw/metadata/">Metadata Vocabulary for Tabular Data</a> specification. These documents can include things like:
      </p>
      <ul>
        <li>metadata about the table, such as titles, descriptions, provenance, and links to other tables</li>
        <li>metadata about columns in the table, such as labels, data types and other constraints, or flags to indicate values in the column are unique</li>
        <li>metadata about rows in the table, such as certainty or provenance</li>
        <li>metadata about values in the table, such as notes or type annotations</li>
      </ul>
      <p>
        When creating a set of annotations from metadata, if the same property is specified in two locations then information "closer" to the end user or interpreter of the document should override other information, and information "closer" to the document itself should override information "further" from the document. Explicitly, the order of preference is:
      </p>
      <ol>
        <li>metadata supplied by the user of the implementation that is processing the tabular data, see <a href="#overriding-metadata" class="sectionRef"></a></li>
        <li>metadata embedded within the tabular data file itself, see <a href="#embedded-metadata" class="sectionRef"></a></li>
        <li>metadata in a document linked to using a <code>Link</code> header associated with the tabular data file, see <a href="#link-header" class="sectionRef"></a></li>
        <li>file-specific metadata in a document located based on the location of the tabular data file, see <a href="#standard-file-metadata" class="sectionRef"></a></li>
        <li>directory-specific metadata in a document located based on the location of the tabular data file, see <a href="#standard-directory-metadata" class="sectionRef"></a></li>
      </ol>
      <p>
        Processors MUST attempt to locate a metadata document based on each of these locations in order, and use first metadata document that is successfully located in this way.
      </p>
      <p class="issue" data-number="42">
        What should processors do if they have been passed a metadata file and located a CSV file from that metadata file. Should they still check for metadata files related specifically to the CSV file itself? For example, say that an application has been pointed at a metadata file at <code>http://example.org/metadata.json</code> which references <code>http://example.org/toilets.csv</code> but there is also a metadata file at <code>http://example.org/toilets.csv-metadata.json</code>. If the processor had been originally pointed to <code>http://example.org/toilets.csv</code> then it would have located the file-specific metadata at <code>http://example.org/toilets.csv-metadata.json</code>, but coming via <code>http://example.org/metadata.json</code> means that file-specific metadata is skipped.
      </p>
      <section>
        <h3>Overriding Metadata</h3>
        <p>
          Processors SHOULD provide users with the facility to provide their own metadata for tabular data files that they process.
        </p>
      </section>
      <section>
        <h3>Embedded Metadata</h3>
        <p>
          Most syntaxes for tabular data provide a facility for embedding some metadata within the tabular data file itself. The definition of a syntax for tabular data SHOULD include a description of how the syntax maps to an annotated data model. See <a href="#parsing-tabular-data" class="sectionRef"></a> for a description of this for CSV files.
        </p>
      </section>
      <section>
        <h3>Link Header</h3>
        <p>
          When retrieving a tabular data file via HTTP, the response MAY include a <code>Link</code> header with <code>rel=describedby</code> and <code>type=application/csv-metadata+json</code> that points to a metadata file that describes the tabular data file. If, by inspection, the referenced file is not a valid metadata file then it MUST be ignored. If there is more than one valid metadata file linked to through multiple <code>Link</code> headers, then the metadata referenced by <code>Link</code> headers that appear later in the response are used in preference to those referenced by earlier <code>Link</code> headers.
        </p>
        <p class="issue" data-number="43">
          Suggest that we drop the requirement to ignore invalid metadata files, given that the correct metadata file should be identified through the type of the link.
        </p>
      </section>
      <section>
        <h3>Standard File Metadata</h3>
        <p>
          If no metadata document has been located through higher-priority mechanisms, processors MUST attempt to locate a file-specific metadata document. This method is only used if the URL of the tabular data file does not contain a query component.
        </p>
        <p>
          In this case, the file-specific metadata document should be located at <code><var>location</var>-metadata.json</code>, where <var>location</var> is the base URL of the tabular data file with the fragment component of the URL removed, if applicable. For example, if the tabular data file is at <code>http://example.org/south-west/devon.csv</code> then processors should attempt to locate a metadata document at <code>http://example.org/south-west/devon.csv-metadata.json</code>. If the metadata file found at this location does not explicitly point to the relevant tabular data file then it MUST be ignored.
        </p>
      </section>
      <section>
        <h3>Standard Directory Metadata</h3>
        <p>
          If no metadata document has been located through higher-priority mechanisms, processors MUST attempt to locate a directory-level metadata document. This method is only used if the URL of the tabular data file does not contain a query component.
        </p>
        <p>
          The common metadata document for a directory can be located by resolving the relative URL <code>metadata.json</code> against the base URL of the tabular data file. For example, if the tabular data file is at <code>http://example.org/south-west/devon.csv</code> then processors should attempt to locate a metadata file at <code>http://example.org/south-west/metadata.json</code>. If the metadata file found at this location does not explicitly point to the relevant tabular data file then it MUST be ignored.
        </p>
      </section>
    </section>
    <section id="syntax" class="informative">
      <h2>CSV+ Syntax</h2>
      <p>
        There is no standard for CSV, and there are many variants of CSV used on the web today. This section defines a method for outputting tabular data adhering to the <a>core tabular data model</a> described in <a href="#core-tabular-data-model" class="sectionRef"></a> into a standard, CSV-based, syntax. Compliant applications that output this format must meet each of the constraints.
      </p>
      <p class="note">
        We are actively working with the IETF to develop a standard for CSV, which is outside the scope of the Working Group. The details here aim to help shape that standard based on our requirements.
      </p>
      <p>
        This section does not seek to describe how applications that <em>input</em> textual tabular data should interpret it, except that any data that is in the format defined here should be understood as defined here.
      </p>
      <div class="note">
        <p>
          This syntax is not compliant with <code>text/csv</code> as defined in [[!RFC4180]] in that it permits line endings other than <code>CRLF</code>. Supporting <code>LF</code> line endings are important characteristics for data formats that are used on non-Windows platforms. However, all files that adhere to [[!RFC4180]]'s definition of CSV are compliant CSV+ files.
        </p>
      </div>
      <section id="content-type">
        <h3>Content Type</h3>
        <p>
          The appropriate content type for a CSV+ file is <code>text/csv</code>. For example, when a CSV+ file is transmitted via HTTP, the HTTP response MUST include a <code>Content-Type</code> header with the value <code>text/csv</code>:
        </p>
        <pre>
Content-Type: text/csv
        </pre>
        <p class="issue">
          See below for issues relating to whether we should instead define a different content type.
        </p>
      </section>
      <section id="encoding">
        <h3>Encoding</h3>
        <p>
          CSV+ files SHOULD be encoded using UTF-8. If a CSV+ file is not encoded using UTF-8, the encoding MUST be specified through the <code>charset</code> parameter in the <code>Content-Type</code> header:
        </p>
        <pre>
Content-Type: text/csv;charset=ISO-8859-1
        </pre>
      </section>
      <section id="line-endings">
        <h3>Line Endings</h3>
        <p>
          The ends of rows in a CSV+ file MUST be either <code>CRLF</code> (<code>U+000D U+000A</code>) or <code>LF</code> (<code>U+000A</code>). Line endings within escaped <a title="cell">cells</a> are not normalised.
        </p>
        <div class="issue" data-number="45">
          <p>
            <a href="http://tools.ietf.org/html/rfc2046#section-4.1.1">Section 4.1.1 of RFC2046</a> specifies that "The canonical form of any MIME "text" subtype MUST always represent a line break as a CRLF sequence.  Similarly, any occurrence of CRLF in MIME "text" MUST represent a line break.  Use of CR and LF outside of line break sequences is also forbidden."
          </p>
          <p>
            Should we be defining <code>application/csv</code> instead, to prevent having to adhere to this rule, or should we stick to the <code>CRLF</code> rule?
          </p>
        </div>
      </section>
      <section id="lines">
        <h3>Lines</h3>
        <p>
          Each line of a CSV+ file MUST contain the same number of comma-separated values.
        </p>
        <p>
          Values that contain commas, line endings or double quotes MUST be escaped by having the entire value wrapped in double quotes. There MUST NOT be whitespace before or after the double quotes. Within these escaped cells, any double quotes MUST be escaped with two double quotes (<code>""</code>).
        </p>
        <section id="headers">
          <h4>Headers</h4>
          <p>
            The first line of a CSV+ file SHOULD contain a comma-separated list of names of <a title="column">columns</a>. This is known as the <dfn>header line</dfn> and provides names for the columns. There are no constraints on these names.
          </p>
          <p>
            If a CSV+ file does not include a header line, this MUST be specified using the <code>header</code> parameter of the media type:
          </p>
          <pre>
Content-Type: text/csv;header=absent
          </pre>
        </section>
        <section>
          <h4>Bidirectionality in CSV+ Files</h4>
          <p>
            Bidirectional content does not alter the definition of rows or the assignment of cells to columns. Whether or not a CSV+ file contains right-to-left characters, the first column's content is the first cell of each row, which is the text prior to the first occurrence of a comma within that row.
          </p>
          <div class="example">
            <p>
              For example, <a href="http://referendum2012.elections.eg/results/referendum-results">Egyptian Referendum results</a> are available as a CSV file at <a href="https://egelections-2011.appspot.com/Referendum2012/results/csv/EG.csv">https://egelections-2011.appspot.com/Referendum2012/results/csv/EG.csv</a>. Over the wire and in non-Unicode-aware text editors, the CSV looks like:
            </p>
            <pre>
              <bdo dir="ltr">
&#8204;ا&#8204;ل&#8204;م&#8204;ح&#8204;ا&#8204;ف&#8204;ظ&#8204;ة&#8204;,&#8204;ن&#8204;س&#8204;ب&#8204;ة&#8204; &#8204;م&#8204;و&#8204;ا&#8204;ف&#8204;ق&#8204;,&#8204;ن&#8204;س&#8204;ب&#8204;ة&#8204; &#8204;غ&#8204;ي&#8204;ر&#8204; &#8204;م&#8204;و&#8204;ا&#8204;ف&#8204;ق&#8204;,&#8204;ع&#8204;د&#8204;د&#8204; &#8204;ا&#8204;ل&#8204;ن&#8204;ا&#8204;خ&#8204;ب&#8204;ي&#8204;ن&#8204;,&#8204;ا&#8204;ل&#8204;أ&#8204;ص&#8204;و&#8204;ا&#8204;ت&#8204; &#8204;ا&#8204;ل&#8204;ص&#8204;ح&#8204;ي&#8204;ح&#8204;ة&#8204;,&#8204;ا&#8204;ل&#8204;أ&#8204;ص&#8204;و&#8204;ا&#8204;ت&#8204; &#8204;ا&#8204;ل&#8204;ب&#8204;ا&#8204;ط&#8204;ل&#8204;ة&#8204;,&#8204;ن&#8204;س&#8204;ب&#8204;ة&#8204; &#8204;ا&#8204;ل&#8204;م&#8204;ش&#8204;ا&#8204;ر&#8204;ك&#8204;ة&#8204;,&#8204;م&#8204;و&#8204;ا&#8204;ف&#8204;ق&#8204;,&#8204;غ&#8204;ي&#8204;ر&#8204; &#8204;م&#8204;و&#8204;ا&#8204;ف&#8204;ق&#8204;
&#8204;ا&#8204;ل&#8204;ق&#8204;ل&#8204;ي&#8204;و&#8204;ب&#8204;ي&#8204;ة&#8204;,60.0,40.0,"2,639,808","853,125","15,224",32.9,"512,055","341,070"
&#8204;ا&#8204;ل&#8204;ج&#8204;ي&#8204;ز&#8204;ة&#8204;,66.7,33.3,"4,383,701","1,493,092","24,105",34.6,"995,417","497,675"
&#8204;ا&#8204;ل&#8204;ق&#8204;ا&#8204;ه&#8204;ر&#8204;ة&#8204;,43.2,56.8,"6,580,478","2,254,698","36,342",34.8,"974,371","1,280,327"
&#8204;ق&#8204;ن&#8204;ا&#8204;,84.5,15.5,"1,629,713","364,509","6,743",22.8,"307,839","56,670"
...
              </bdo>
            </pre>
            <p>
              Within this CSV file, the first column appears as the content of each line before the first comma and is named <code>المحافظة</code> (appearing at the start of each row as <code><bdo dir="ltr">&#8204;ا&#8204;ل&#8204;م&#8204;ح&#8204;ا&#8204;ف&#8204;ظ&#8204;ة&#8204;</bdo></code> in the example, which is displaying the relevant characters from left to right in the order they appear "on the wire").
            </p>
            <p>
              The CSV translates to a table model that looks like:
            </p>
            <table style="width: 100%; text-align: right">
              <col style="width: 10%"></col>
              <col style="width: 10%"></col>
              <col style="width: 10%"></col>
              <col style="width: 10%"></col>
              <col style="width: 10%"></col>
              <col style="width: 10%"></col>
              <col style="width: 10%"></col>
              <col style="width: 10%"></col>
              <col style="width: 10%"></col>
              <col style="width: 10%"></col>
              <thead>
                <tr style="text-align: center">
                  <th>Column / Row</th>
                  <th>column 1</th>
                  <th>column 2</th>
                  <th>column 3</th>
                  <th>column 4</th>
                  <th>column 5</th>
                  <th>column 6</th>
                  <th>column 7</th>
                  <th>column 8</th>
                  <th>column 9</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <th>row 1 (header)</th><th>المحافظة</th><th>نسبة موافق</th><th>نسبة غير موافق</th><th>عدد الناخبين</th><th>الأصوات الصحيحة</th><th>الأصوات الباطلة</th><th>نسبة المشاركة</th><th>موافق</th><th>غير موافق</th>
                </tr>
                <tr>
                  <th>row 2</th><td>القليوبية</td><td>60.0</td><td>40.0</td><td>2,639,808</td><td>853,125</td><td>15,224</td><td>32.9</td><td>512,055</td><td>341,070</td>
                </tr>
                <tr>
                  <th>row 3</th><td>الجيزة</td><td>66.7</td><td>33.3</td><td>4,383,701</td><td>1,493,092</td><td>24,105</td><td>34.6</td><td>995,417</td><td>497,675</td>
                </tr>
                <tr>
                  <th>row 4</th><td>القاهرة</td><td>43.2</td><td>56.8</td><td>6,580,478</td><td>2,254,698</td><td>36,342</td><td>34.8</td><td>974,371</td><td>1,280,327</td>
                </tr>
                <tr>
                  <th>row 5</th><td>قنا</td><td>84.5</td><td>15.5</td><td>1,629,713</td><td>364,509</td><td>6,743</td><td>22.8</td><td>307,839</td><td>56,670</td>
                </tr>
              </tbody>
            </table>
            <p>
              The fragment identifier <code>#col=3</code> identifies the third of the columns, named <code>نسبة غير موافق</code> (appearing as <code><bdo dir="ltr">&#8204;ن&#8204;س&#8204;ب&#8204;ة&#8204; &#8204;غ&#8204;ي&#8204;ر&#8204; &#8204;م&#8204;و&#8204;ا&#8204;ف&#8204;ق&#8204;</bdo></code> in the example).
            </p>
            <p>
              [[!tabular-metadata]] defines how this table model should be displayed by compliant applications, and how metadata can affect the display. The default is for the display to be determined by the content of the table. For example, if this CSV were turned into an HTML table for display into a web page, it should be displayed with the first column on the right and the last on the left, as follows:
            </p>
            <table style="width: 100%; text-align: right">
              <thead>
                <tr>
                  <th>غير موافق</th>
                  <th>موافق</th>
                  <th>نسبة المشاركة</th>
                  <th>الأصوات الباطلة</th>
                  <th>الأصوات الصحيحة</th>
                  <th>عدد الناخبين</th>
                  <th>نسبة غير موافق</th>
                  <th>نسبة موافق</th>
                  <th>المحافظة</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>341,070</td>
                  <td>512,055</td>
                  <td>32.9</td>
                  <td>15,224</td>
                  <td>853,125</td>
                  <td>2,639,808</td>
                  <td>40.0</td>
                  <td>60.0</td>
                  <td>القليوبية</td>
                </tr>
                <tr>
                  <td>497,675</td>
                  <td>995,417</td>
                  <td>34.6</td>
                  <td>24,105</td>
                  <td>1,493,092</td>
                  <td>4,383,701</td>
                  <td>33.3</td>
                  <td>66.7</td>
                  <td>الجيزة</td>
                </tr>
                <tr>
                  <td>1,280,327</td>
                  <td>974,371</td>
                  <td>34.8</td>
                  <td>36,342</td>
                  <td>2,254,698</td>
                  <td>6,580,478</td>
                  <td>56.8</td>
                  <td>43.2</td>
                  <td>القاهرة</td>
                </tr>
                <tr>
                  <td>56,670</td>
                  <td>307,839</td>
                  <td>22.8</td>
                  <td>6,743</td>
                  <td>364,509</td>
                  <td>1,629,713</td>
                  <td>15.5</td>
                  <td>84.5</td>
                  <td>قنا</td>
                </tr>
              </tbody>
            </table>
            <p>
              The fragment identifier <code>#col=3</code> still identifies the third of the columns, named <code>نسبة غير موافق</code>, which appears in the HTML display as the third column from the right and is what those who read right-to-left would think of as the third column.
            </p>
            <p>
              Note that this display matches that shown <a href="http://referendum2012.elections.eg/results/referendum-results">on the original website</a>.
            </p>
          </div>
          <div class="issue" data-number="46">
            <p>
              An alternative approach is for the CSV to be parsed into a table model in which the columns are numbered in the reverse, for tables which are either marked as or detected to be right-to-left tables. For example, we could introduce a <code>bidi=rtl</code> or similar media type parameter, and use this to determine whether the first column in table generated from the CSV is the text before the first comma in each line or the text after the last comma in the line.
            </p>
            <p>
             In the example above, if the CSV were served with <code>bidi=rtl</code>, or the table was detected as being a right-to-left table, then the column numbering in the model would be reversed:
            </p>
            <table style="width: 100%; text-align: right">
              <col style="width: 10%"></col>
              <col style="width: 10%"></col>
              <col style="width: 10%"></col>
              <col style="width: 10%"></col>
              <col style="width: 10%"></col>
              <col style="width: 10%"></col>
              <col style="width: 10%"></col>
              <col style="width: 10%"></col>
              <col style="width: 10%"></col>
              <col style="width: 10%"></col>
              <thead>
                <tr style="text-align: center">
                  <th>Column / Row</th>
                  <th>column 9</th>
                  <th>column 8</th>
                  <th>column 7</th>
                  <th>column 6</th>
                  <th>column 5</th>
                  <th>column 4</th>
                  <th>column 3</th>
                  <th>column 2</th>
                  <th>column 1</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <th>row 1 (header)</th><th>المحافظة</th><th>نسبة موافق</th><th>نسبة غير موافق</th><th>عدد الناخبين</th><th>الأصوات الصحيحة</th><th>الأصوات الباطلة</th><th>نسبة المشاركة</th><th>موافق</th><th>غير موافق</th>
                </tr>
                <tr>
                  <th>row 2</th><td>القليوبية</td><td>60.0</td><td>40.0</td><td>2,639,808</td><td>853,125</td><td>15,224</td><td>32.9</td><td>512,055</td><td>341,070</td>
                </tr>
                <tr>
                  <th>row 3</th><td>الجيزة</td><td>66.7</td><td>33.3</td><td>4,383,701</td><td>1,493,092</td><td>24,105</td><td>34.6</td><td>995,417</td><td>497,675</td>
                </tr>
                <tr>
                  <th>row 4</th><td>القاهرة</td><td>43.2</td><td>56.8</td><td>6,580,478</td><td>2,254,698</td><td>36,342</td><td>34.8</td><td>974,371</td><td>1,280,327</td>
                </tr>
                <tr>
                  <th>row 5</th><td>قنا</td><td>84.5</td><td>15.5</td><td>1,629,713</td><td>364,509</td><td>6,743</td><td>22.8</td><td>307,839</td><td>56,670</td>
                </tr>
              </tbody>
            </table>
            <p>
              This would require a change to [[RFC7111]] but that might be required by updates to the definition of <code>text/csv</code> in any case. With the change, the fragment identifier <code>#col=3</code> would then refer to the third column from the right, named <code>نسبة المشاركة</code>.
            </p>
            <p>
              If the model were defined in this way, there would be no need to determine the order of the columns when displayed using a metadata property. Columns would always be displayed with the first column (numbered 1 in the model) on the left. The final display in HTML, for example, would be exactly as above. The only difference would be that <code>#col=3</code> would refer to the third column from the left.
            </p>
            <p>
              We note that using media type parameters is problematic because publishers might not have the ability to set them on their servers, and because they can easily get lost as a file is republished or emailed between people.
            </p>
            <p>
              We invite comment on the best way to approach bidirectionality in CSV files.
            </p>
          </div>
        </section>
      </section>

      <section id="ebnf">
        <h3>Grammar</h3>
        <p>This grammar is a generalization of that defined in [[!RFC4180]] and is included for reference only.</p>
        <p>The <abbr title="Extended Backus–Naur Form">EBNF</abbr> used here is defined in XML 1.0 [[EBNF-NOTATION]].</p>
        <div data-include="csv-plus.html"></div>
        <p class="note">
          We should probably place further restrictions on QCHAR and SCHAR to avoid control characters. If header weren’t optional, it would be better defined as in RFC4180, but if the syntax allows it to be optional, this would make it not an LL(1) grammar, which isn’t too much of an issue.
        </p>
      </section>
    </section>
    <section id="parsing" class="informative">
      <h2>Parsing Tabular Data</h2>
      <p>
        As described in <a href="#syntax" class="sectionRef"></a>, there may be many formats which an application might interpret into the tabular data model described in <a href="#model" class="sectionRef"></a>, including using different separators or fixed format tables, multiple tables within a single file, or ones that have metadata lines before a table header.
      </p>
      <p class="note">
        Standardising the parsing of CSV is outside the chartered scope of the Working Group. This non-normative section is intended to help the creators of parsers handle the wide variety of CSV-based formats that they may encounter due to the current lack of standardisation of the format.
      </p>
      <p>
        This section describes an algorithm for parsing formats other than the plain CSV+ format specified in <a href="#syntax" class="sectionRef"></a>. It is impossible to do this in a fully automated manner, so this algorithm depends on the following flags being set externally (eg through user input):
      </p>
      <dl>
        <dt><dfn>encoding</dfn></dt>
        <dd>The character encoding for the file, one of the encodings listed in [[!encoding]]. The default is <code>utf-8</code>.</dd>
        <dt><dfn>line terminator</dfn></dt>
        <dd>The character that is used at the end of a row. The default is <code>CRLF</code>.</dd>
        <dt><dfn>quote character</dfn></dt>
        <dd>The character that is used around escaped cells. The default is <code>"</code>.</dd>
        <dt><dfn>escape character</dfn></dt>
        <dd>The character that is used to escape the <a>quote character</a> within escaped cells. The default is <code>"</code> (such that <code>""</code> is used to escape <code>"</code> within an escaped cell).</dd>
        <dt><dfn>skip rows</dfn></dt>
        <dd>The number of rows to skip at the beginning of the file, before a header row or tabular data. The default is <code>0</code>.</dd>
        <dt><dfn>comment prefix</dfn></dt>
        <dd>A character that, when it appears at the beginning of a skipped row, indicates a comment that should be associated as a comment annotation to the table. The default is <code>#</code>.</dd>
        <dt><dfn>header row count</dfn></dt>
        <dd>The number of header rows (following the skipped rows) in the file. The default is <code>1</code>.</dd>
        <dt><dfn>delimiter</dfn></dt>
        <dd>The separator between cells. The default is <code>,</code>.</dd>
        <dt><dfn>skip columns</dfn></dt>
        <dd>The number of columns to skip at the beginning of each row, before any header columns. The default is <code>0</code>.</dd>
        <dt><dfn>header column count</dfn></dt>
        <dd>The number of header columns (following the skipped columns) in each row. The default is <code>0</code>.</dd>
        <dt><dfn>skip blank rows</dfn></dt>
        <dd>Indicates whether to ignore wholly empty rows (ie rows in which all the cells are empty). The default is <code>false</code>.</dd>
        <dt><dfn>trim</dfn></dt>
        <dd>Indicates whether to trim whitespace around cells; may be <code>true</code>, <code>false</code>, <code>start</code> or <code>end</code>. The default is <code>false</code>.</dd>
      </dl>
      <div class="issue" data-number="47">
        <p>
          When parsing, should we:
        </p>
        <ul>
          <li>always trim whitespace around cells?</li>
          <li>always create empty cells for missing cells?</li>
        </ul>
      </div>
      <p>
        The algorithm for parsing a document containing tabular data is as follows:
      </p>
      <ol>
        <li>Read the file using the specified <a>encoding</a>.</li>
        <li>Find the rows. Each row ends with a <a>line terminator</a>, but values that are enclosed within the <a>quote character</a> may contain the <a>line terminator</a> without it indicating the end of the row. The <a>quote character</a> may be escaped using the <a>escape character</a> where it appears within cells. If the <a>escape character</a> is not the same as the <a>quote character</a> then the <a>escape character</a> is also used to escape the character that immediately follows it.</li>
        <li>Skip the number of rows indicated by the <a>skip rows</a> parameter. These form comment annotations on the table. If a skipped row begins with the <a>comment prefix</a>, strip that prefix from the beginning of the row to create the content of the comment annotation.</li>
        <li>Gather the number of header rows indicated by the <a>header row count</a> parameter; the remaining rows are data rows.</li>
        <li>
          <p>
            Split the header and data rows into cells using the <a>delimiter</a>. Values that are enclosed within the <a>quote character</a> may contain the <a>delimiter</a>. The <a>quote character</a> may be escaped using the <a>escape character</a> where it appears within cells. If the <a>escape character</a> is not the same as the <a>quote character</a> then the <a>escape character</a> is also used to escape the character that immediately follows it.
          </p>
          <p>
            If <a>trim</a> is <code>true</code> or <code>start</code> then whitespace from the start of values that are not enclosed must be removed from the value. If <a>trim</a> is <code>true</code> or <code>end</code> then whitespace from the end of values that are not enclosed must be removed from the value.
          </p>
        </li>
        <li>In each row, ignore the number of columns indicated by the <a>skip columns</a> parameter. Always start from the first character in the row when counting columns (see <a href="#bidirectionality-in-csv-files" class="sectionRef"></a>).</li>
        <li>Gather the number of header columns indicated by the <a>header column count</a> parameter. Always start from the first character in the row when counting columns (see <a href="#bidirectionality-in-csv-files" class="sectionRef"></a>).</li>
        <li>Each cell within a header row that is not in a skipped or header column is a label annotation on that column.</li>
        <li>Each cell within a header column is an annotation on the row it appears in; if there is a header row then that provides the type of the annotation for the row, otherwise it is a label annotation.</li>
        <li>If <a>skip blank rows</a> is <code>true</code> then ignore any rows in which all the cell values are empty strings.</li>
      </ol>
      <!-- alternative, more procedural appraoch would be something like this:
      <p>
        To <dfn>read a row</dfn>:
      </p>
      <ol>
        <li>set <var>cells</var> to an empty list</li>
        <li>set <var>skipped rows</var> to <code>0</code></li>
        <li>set <var>header rows</var> to an empty list</li>
        <li><a>read a cell</a> and add that value to the <var>cells</var> list</li>
        <li>if the next character is whitespace, then if <a>trim</a> is <code>true</code> or <code>end</code> then ignore the next whitespace characters, otherwise raise an error.</li>
        <li>otherwise, if the next character is the <a>delimiter</a> then go back to step 2.</li>
        <li>otherwise, if the next character is the <a>row terminator</a> then return the list of <var>cells</var> as the content of the row.</li>
      </ol>
    -->
    </section>
    <section class="appendix" id="standards">
      <h2>Existing Standards</h2>
      <p>
        This appendix outlines various ways in which CSV is defined.
      </p>
      <section id="rfc">
        <h3>RFC 4180</h3>
        <p>
          [[!RFC4180]] defines CSV with the following ABNF grammar:
        </p>
        <pre>
file = [header CRLF] record *(CRLF record) [CRLF]
header = name *(COMMA name)
record = field *(COMMA field)
name = field
field = (escaped / non-escaped)
escaped = DQUOTE *(TEXTDATA / COMMA / CR / LF / 2DQUOTE) DQUOTE
non-escaped = *TEXTDATA
COMMA = %x2C
CR = %x0D
DQUOTE =  %x22
LF = %x0A
CRLF = CR LF
TEXTDATA =  %x20-21 / %x23-2B / %x2D-7E
        </pre>
        <p>
          Of particular note here are:
        </p>
        <ul>
          <li>The production for <code>TEXTDATA</code> indicates that only non-control ASCII characters are permitted within a CSV file. This restriction is routinely ignored in practice, and is impractical on the international web.</li>
          <li>Lines should be ended with <code>CRLF</code>. This makes it harder to produce CSV files on Unix-based systems where the usual line ending is <code>LF</code>.</li>
          <li>The header line is optional; a <code>header</code> parameter on the media type indicates whether the header is present or not.</li>
          <li>Fields may be escaped by wrapping them in double quotes; any double quotes within the field must be escaped with two double quotes (<code>""</code>).</li>
        </ul>
      </section>
      <section id="excel">
        <h3>Excel</h3>
        <p>
          Excel is a common tool for both creating and reading CSV documents, and therefore the CSV that it produces is a de facto standard.
        </p>
        <p class="note">
          The following describes the behaviour of Microsoft Excel for Mac 2011 with an English locale. Further testing is needed to see the behaviour of Excel in other situations.
        </p>
        <section>
          <h4>Saved CSV</h4>
          <p>
            Excel generates CSV files encoded using Windows-1252 with <code>LF</code> line endings. Characters that cannot be represented within Windows-1252 are replaced by underscores. Only those cells that need escaping (eg because they contain commas or double quotes) are escaped, and double quotes are escaped with two double quotes.
          </p>
          <p>
            Dates and numbers are formatted as displayed, which means that formatting can lead to information being lost or becoming inconsistent.
          </p>
        </section>
        <section>
          <h4>Opened CSV</h4>
          <p>
            When opening CSV files, Excel interprets CSV files saved in UTF-8 as being encoded as Windows-1252 (whether or not a <a href="http://en.wikipedia.org/wiki/Byte_order_mark"><abbr title="Byte Order Mark">BOM</abbr></a> is present). It correctly deals with double quoted cells, except that it converts line breaks within cells into spaces. It understands <code>CRLF</code> as a line break. It detects dates (formatted as <code>YYYY-MM-DD</code>) and formats them in the default date formatting for files.
          </p>
        </section>
        <section>
          <h4>Imported CSV</h4>
          <p>
            Excel provides more control when importing CSV files into Excel. However, it does not properly understand UTF-8 (with or without BOM). It does however properly understand UTF-16 and can read non-ASCII characters from a UTF-16-encoded file.
          </p>
          <p>
            A particular quirk in the importing of CSV is that if a cell contains a line break, the final double quote that escapes the cell will be included within it.
          </p>
        </section>
        <section>
          <h4>Copied Tabular Data</h4>
          <p>
            When tabular data is copied from Excel, it is copied in a tab-delimited format, with <code>LF</code> line breaks.
          </p>
        </section>
      </section>
      <section id="google">
        <h3>Google Spreadsheets</h3>
        <section>
          <h4>Downloading CSV</h4>
          <p>
            Downloaded CSV files are encoded in UTF-8, without a <a href="http://en.wikipedia.org/wiki/Byte_order_mark"><abbr title="Byte Order Mark">BOM</abbr></a>, and with <code>LF</code> line endings. Dates and numbers are formatted as they appear within the spreadsheet.
          </p>
        </section>
        <section>
          <h4>Importing CSV</h4>
          <p>
            CSV files can be imported as UTF-8 (with or without BOM). <code>CRLF</code> line endings are correctly recognised. Dates are reformatted to the default date format on load.
          </p>
        </section>
      </section>
      <section id="">
        <h3>CSV Files in a Tabular Data Package</h3>
        <p>
          <a href="http://dataprotocols.org/tabular-data-package/#csv-files">Tabular Data Packages</a> place the following restrictions on CSV files:
        </p>
        <blockquote>
          <p>As a starting point, CSV files included in a Tabular Data Package package must conform to the RFC for CSV (4180 - Common Format and MIME Type for Comma-Separated Values (CSV) Files). In addition:</p>

          <ul>
            <li>File names MUST end with <code>.csv</code></li>
            <li>Files MUST be encoded as UTF-8</li>
            <li>
              <p>Files MUST have a single header row. This row MUST be the first row in the
          file.</p>

              <ul>
                <li>Terminology: each column in the CSV file is termed a <em>field</em> and
          its <code>name</code> is the string in that column in the header row.</li>
                <li>The <code>name</code> MUST be unique amongst fields and MUST contain at
          least one character</li>
                <li>There are no further restrictions on the form of the <code>name</code> but
          it is RECOMMENDED that it contain only alphanumeric characters
          together with “ .-_”</li>
              </ul>
            </li>
            <li>Rows in the file MUST NOT contain more fields than are in the header row (though they may
          contain less)</li>
            <li>Each file MUST have an entry in the <code>resources</code> array in the <code>datapackage.json</code> file</li>
            <li>The resource metadata MUST include a <code>schema</code> attribute whose value MUST conform to the JSON
          Table Schema</li>
            <li>All fields in the CSV files MUST be described in the <code>schema</code></li>
          </ul>

          <p>CSV files generated by different applications often vary in their syntax, e.g. use of quoting characters, delimiters, etc. To encourage conformance, CSV files in a CSV files in a Tabular Data Package SHOULD</p>

          <ul>
            <li>Use “,” as field delimiters</li>
            <li>Use “rn” or “n” as line terminators</li>
          </ul>

          <p>If a CSV file does not follow these rules then its specific CSV dialect MUST be documented. The resource 
          hash for the resource in the <code>datapackage.json</code> descriptor MUST:</p>

          <ul>
            <li>Include a <code>dialect</code> key that conforms to that described in the <a href="http://dataprotocols.org/csv-dialect/">CSV Dialect Description Format</a></li>
          </ul>

          <p>Applications processing the CSV file SHOULD read use the <code>dialect</code> of the CSV file to guide parsing.</p>
        </blockquote>
      </section>
      <div class="issue">
        <p>
          More details of behaviour of other tools should go here. This should include the most popular CSV parsing/generating libraries in common programming languages. Test files which include non-ASCII characters, double quotes and line breaks within cells are:
        </p>
        <ul>
          <li><a href="test-utf8.csv">test-utf8.csv</a></li>
          <li><a href="test-utf8-bom.csv">test-utf8-bom.csv</a></li>
          <li><a href="test-utf16.csv">test-utf16.csv</a></li>
          <li><a href="test-utf16-bom.csv">test-utf16-bom.csv</a></li>
          <li><a href="test.xlsx">test.xslx</a></li>
          <li><a href="test.xls">test.xsl</a></li>
        </ul>
      </div>
    </section>
  </body>
</html>

