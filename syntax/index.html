<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta content="width=device-width,initial-scale=1" name="viewport" />
    <title>Model for Tabular Data and Metadata on the Web</title>
    <script class="remove" src="https://www.w3.org/Tools/respec/respec-w3c-common">
		</script>
    <script class="remove">
var respecConfig = {
    localBiblio: {
       "tabular-metadata": {
            "authors": [
              "Rufus Pollock",
              "Jeni Tennison",
              "Gregg Kellogg"
            ],
            "title": "Metadata Vocabulary for Tabular Data",
            "href" : "http://www.w3.org/TR/2014/WD-tabular-metadata-20150108/",
            "rawDate": "2015-01-08",
            "status" : "WD",
            "publisher": "W3C"
        },
        "EBNF-NOTATION" : {
          "authors" : [
            "Tim Bray",
            "Jean Paoli",
            "C. Michael Sperberg-McQueen",
            "Eve Maler",
            "François Yergau"
          ],
          "title" : "EBNF Notation",
          "rawDate" : "2008-11-26",
          "status" : "REC",
          "publisher" : "W3C",
          "href" : "http://www.w3.org/TR/REC-xml/#sec-notation"
        },
        "RFC7111" : {
          "authors" : [
            "Michael Hausenblas",
            "Erik Wilde",
            "Jenni Tennison"
          ],
          "title" : "URI Fragment Identifiers for the text/csv Media Type",
          "rawDate" : "2014-01",
          "status": "Internet RFC",
          "publisher" : "IETF",
          "href" : "http://www.ietf.org/rfc/rfc7111.txt"
        },
        "UNICODE-BIDI" : {
          "authors" : [
            "Mark Davis",
            "Aharon Lanin",
            "Andrew Glass"
          ],
          "title": "TR9, Unicode Bidirectional Algorithm",
          "href": "http://unicode.org/reports/tr9/",
          "rawDate" : "2013-09-24",
          "publisher" : "Unicode Consortium",
          "status" : "Report"
        }
    },
    specStatus: "ED",
    shortName: "tabular-data-model",
    //publishDate:  "2014-03-27",
    previousPublishDate: "2015-01-08",
    previousMaturity: "WD",
    previousURI: "http://www.w3.org/TR/2014/WD-tabular-data-model-20150108/",
    edDraftURI: "http://w3c.github.io/csvw/syntax/",
    // lcEnd: "3000-01-01",
    // crEnd: "3000-01-01",
    editors: [{
      name: "Jeni Tennison",
      company: "Open Data Institute",
      companyURL: "http://theodi.org/",
      w3cid: "33715"
    }, { 
      name: "Gregg Kellogg", 
      url: "http://greggkellogg.net/",
      company: "Kellogg Associates", 
      companyURL: "http://kellogg-assoc.com/",
      w3cid: "44770"
    }],
    wg: "CSV on the Web Working Group",
    wgURI: "http://www.w3.org/2013/csvw/",
    wgPublicList: "public-csv-wg",
    wgPatentURI: "http://www.w3.org/2004/01/pp-impl/68238/status",
    otherLinks: [{
      key: "Repository",
      data: [{
          value: "We are on Github",
          href: "https://github.com/w3c/csvw"
      }, {
          value: "File a bug",
          href: "https://github.com/w3c/csvw"
      }]
      }, {
      key: "Changes",
        data: [{
          value: "Diff to previous version",
          href: "diff-20150108.html"
        }, {
          value: "Commit history",
          href: "https://github.com/w3c/csvw/commits/gh-pages"
      }]
    }],
    inlineCSS: true,
    issueBase: "https://github.com/w3c/csvw/issues/",
    noIDLIn: true,
    noLegacyStyle: false
    };
    </script>
    <style type="text/css">
      .grammar td { font-family: monospace; vertical-align: top; }
      .grammar-literal { color: gray;}
      ol.algorithm {
        counter-reset: numsection;
        list-style-type: none;
      }
      ol.algorithm li {
        margin: 0.5em 0;
      }
      ol.algorithm li:before {
        font-weight: bold;
        counter-increment: numsection;
        content: counters(numsection, ".") ") ";
      }
    </style>
  </head>
  <body>
    <section id="abstract">
      <p>
        Tabular data is routinely transferred on the web in a variety of formats, including variants on CSV, tab-delimited files, fixed field formats, spreadsheets, HTML tables and SQL dumps. This document outlines a data model or infoset for tabular data and metadata about that tabular data that can be used as a basis for validation, display or creating other formats. It also contains some non-normative guidance for publishing tabular data as CSV and how that maps into the tabular data model.
      </p>
      <p>
        Creating an annotated model of tabular data relies on the provision of separate metadata about the table. This specification defines how implementations should locate that metadata, given a file containing tabular data. The syntax for that metadata is defined in [[!tabular-metadata]].
      </p>
    </section>
    <section id="sotd">
      <p>
        The CSV on the Web Working Group was chartered to produce a Recommendation "Access methods for CSV Metadata" as well as Recommendations for "Metadata vocabulary for CSV data" and "Mapping mechanism to transforming CSV into various Formats (e.g., RDF, JSON, or XML)". This document aims to primarily satisfy the first of those Recommendations (see <a href="#locating-metadata" class="sectionRef"></a>), though it also specifies an underlying model and is therefore a basis for the other chartered Recommendations.
      </p>
      <p>
        This definition of CSV used in this document is based on IETF's [[!RFC4180]] which is an Informational RFC. The working group's expectation is that future suggestions to refine RFC 4180 will be relayed to the IETF (e.g. around I18N and multi-part packaging) and contribute to its discussions about moving CSV to the Standards track.
      </p>
      <p>
        Many files containing tabular data embed metadata, for example in lines before the header row of an otherwise standard CSV document. This specification does not define any formats for embedding metadata within CSV files, aside from the names of columns in the header row which is defined in CSV. We would encourage groups that define tabular data formats to also define a mapping into the annotated tabular data model defined in this document.
      </p>
    </section>
    <section id="intro">
      <h2>Introduction</h2>
      <p>
        <dfn title="tabular data">Tabular data</dfn> is data that is structured into rows, each of which contains information about some thing. Each row contains the same number of cells (although some of these cells may be empty), which provide values of properties of the thing described by the row. In tabular data, cells within the same column provide values for the same property of the thing described by the particular row. This is what differentiates tabular data from other line-oriented formats. 
      </p>
    	<p>
        Tabular data is routinely transferred on the web in a textual format called "CSV", but the definition of "CSV" in practice is very loose. Some people use the term to mean any delimited text file. Others stick more closely to the most standard definition of CSV that there is, [[!RFC4180]]. <a href="#standards" class="sectionRef">Appendix A</a> describes the various ways in which CSV is defined.
      </p>
      <p>
        Tabular data is also transferred on the web in tab-delimited files, fixed field formats, spreadsheets, HTML tables and SQL dumps.
      </p>
      <p>
        In <a href="#model" class="sectionRef"></a>, this document defines a model for tabular data that abstracts away from the varying syntaxes that are used for when exchanging tabular data. The model includes annotations, or metadata, about collections of and individual tables, rows, columns and cells. These annotations are typically supplied through separate metadata files; <a href="#locating-metadata" class="sectionRef"></a> defines how these metadata files can be located, while [[!tabular-metadata]] defines what they contain.
      </p>
      <p>
        Once an <a>annotated table</a> has been created, it can be processed in various ways, such as display, validation or conversion into other formats. This processing is described in <a href="#processing-tables" class="sectionRef"></a>.
      </p>
      <p>
        This specification does not normatively define a format for exchanging tabular data. However, it does provide some best practice guidelines for publishing tabular data as CSV, in section <a href="#syntax" class="sectionRef"></a>, and for parsing both this syntax and those similar to it, in <a href="#parsing" class="sectionRef"></a>.
      </p>
    </section>
    <section id="model">
      <h2>Tabular Data Models</h2>
      <p>
        This section defines an <dfn>annotated tabular data model</dfn>: a model for tables that are annotated with metadata. <dfn title="annotation">Annotations</dfn> provide information about the cells, rows, columns, tables and groups of tables with which they are associated. The <dfn title="value">values</dfn> of these annotations may be lists, structured objects, or atomic values. <dfn>Core annotations</dfn> are those that affect the behavior of processors defined in this specification, but other annotations may also be present on any of the components of the model.
      </p>
      <p class="note">
        In this document, the term <a>annotation</a> refers to any metadata associated with an object in the annotated tabular data model. These are not necessarily web annotations in the sense of [[annotation-model]].
      </p>
      <section>
        <h3>Table groups</h3>
        <p>
          A <dfn>group of tables</dfn> comprises a set of <a title="annotated table">annotated tables</a> and a set of annotations that relate to those tables. The <a>core annotations</a> of a group of tables are:
        </p>
        <ul>
          <li><dfn title="table group id">id</dfn> &mdash; an identifier for this group of tables, or <code>null</code> if this is undefined</li>
          <li><dfn title="table group resources">resources</dfn> &mdash; the list of <a title="table">tables</a> in the group of tables. A group of tables MUST have one or more tables.</li>
        </ul>
        <p>
          Groups of tables MAY in addition have any number of <a title="annotation">annotations</a> which provide information about the group of tables. Annotations on a group of tables may include:
        </p>
        <ul>
          <li>information about the source or provenance of the group of tables</li>
          <li>links to other groups of tables (eg to those that provide similar data from a different time period)</li>
        </ul>
      </section>
      <section>
        <h3>Tables</h3>
        <p>
          An <dfn>annotated table</dfn> is a <dfn>table</dfn> that is annotated with additional metadata. The <a>core annotations</a> of a table are:
        </p>
        <ul>
          <li><dfn title="table columns">columns</dfn> &mdash; the list of <a title="column">columns</a> in the table. A table MUST have one or more columns and the order of the columns within the list is significant and MUST be preserved by applications</li>
          <li><dfn title="table rows">rows</dfn> &mdash; the list of <a title="row">rows</a> in the table</li>
          <li><dfn title="table id">id</dfn> &mdash; an identifier for this table, or <code>null</code> if this is undefined</li>
          <li><dfn title="table url">url</dfn> &mdash; the URL of the source of the data in the table, or <code>null</code> if this is undefined</li>
          <li><dfn title="table direction">direction</dfn> &mdash; the direction in which the columns in the table should be displayed, as described in <a href="#bidirectional-tables" class="sectionRef"></a></li>
          <li><dfn title="table suppress output">suppress output</dfn> &mdash; a boolean that indicates whether or not this table should be suppressed in any output generated from the converting the table group that this table belongs to into another format, as described in <a href="#converting-tables" class="sectionRef"></a></li>
          <li><dfn title="table notes">notes</dfn> &mdash; a list of notes on the table, as described in [[!tabular-metadata]], which may be an empty list</li>
          <li><dfn title="table foreign keys">foreign keys</dfn> &mdash; a list of foreign keys on the table, as defined in [[!tabular-metadata]], which may be an empty list</li>
          <li><dfn title="table conversions">conversions</dfn> &mdash; a (possibly empty) list of specifications for converting this table into other formats, as defined in [[!tabular-metadata]].</li>
        </ul>
        <p>
          The table MAY in addition have any number of other <a title="annotation">annotations</a>. Annotations on a table may include:
        </p>
        <ul>
          <li>titles or descriptions of the table</li>
          <li>information about the source or provenance of the data in the table</li>
          <li>links to other tables (eg to indicate tables that include related information)</li>
        </ul>
        <p>
          These arise from <a href="http://w3c.github.io/csvw/metadata/#dfn-common-property" class="externalDFN">common properties</a> defined within metadata documents, as defined in [[!tabular-metadata]].
        </p>
      </section>
      <section>
        <h3>Columns</h3>
        <p>
          A <dfn>column</dfn> represents a vertical arrangement of <a title="cell">cells</a> within a <a>table</a>. The <a>core annotations</a> of a column are:
        </p>
        <ul>
          <li><dfn title="column table">table</dfn> &mdash; the <a>table</a> that the column appears in</li>
          <li><dfn title="column number">number</dfn> &mdash; the position of the column amongst the <a title="table columns">columns</a> for the associated <a title="column table">table</a>, starting from 1</li>
          <li><dfn title="column source number">source number</dfn> &mdash; the position of the column in the original <a title="table url">url</a> of the table, or <code>null</code></li>
          <li><dfn title="column name">name</dfn> &mdash; the name of the column</li>
          <li><dfn title="column titles">titles</dfn> &mdash; any number of human-readable titles for the column, each of which has an associated language</li>
          <li><dfn title="column required">required</dfn> &mdash; a boolean that indicates whether cells within the column can be <code>null</code>; if <code>false</code> then they cannot be</li>
          <li><dfn title="column datatype">datatype</dfn> &mdash; the expected datatype for the <a title="cell value">values</a> of <a title="cell">cells</a> in this column, as defined in [[!tabular-metadata]]</li>
          <li><dfn title="column virtual">virtual</dfn> &mdash; a boolean that indicates whether the column is a <a>virtual column</a>. <dfn title="virtual column">Virtual columns</dfn> are used to extend the source data with additional empty columns to support more advanced conversions; when this annotation is <code>false</code>, the column is a <dfn>real column</dfn>, which exists in the source data for the table.</li>
          <li><dfn title="column suppress output">suppress output</dfn> &mdash; a boolean that indicates whether or not this column should be suppressed in any output generated from converting the table, as described in <a href="#converting-tables" class="sectionRef"></a></li>
          <li><dfn title="column cells">cells</dfn> &mdash; the list of <a title="cell">cells</a> in the column. A column MUST contain one cell from each <a>row</a> in the table. The order of the cells in the list MUST match the order of the rows in which they appear within the <a title="table rows">rows</a> for the associated <a title="column table">table</a>.</li>
        </ul>
        <p>
          Columns MAY in addition have any number of other <a title="annotation">annotations</a>. These arise from <a href="http://w3c.github.io/csvw/metadata/#dfn-common-property" class="externalDFN">common properties</a> defined within metadata documents, as defined in [[!tabular-metadata]].
        </p>
      </section>
      <section>
        <h3>Rows</h3>
        <p>
          A <dfn>row</dfn> represents a horizontal arrangement of <a title="cell">cells</a> within a <a>table</a>. The <a>core annotations</a> of a row are:
        </p>
        <ul>
          <li><dfn title="row table">table</dfn> &mdash; the <a>table</a> that the row appears in</li>
          <li><dfn title="row number">number</dfn> &mdash; the position of the row amongst the <a title="table rows">rows</a> for the <a title="row table">table</a>, starting from 1</li>
          <li><dfn title="row source number">source number</dfn> &mdash; the position of the row in the original <a title="table url">url</a> of the table, or <code>null</code></li>
          <li><dfn title="row primary key">primary key</dfn> &mdash; a possibly empty list of <a title="cell">cells</a> whose values together provide a unique identifier for this row</li>
          <li><dfn title="row referenced rows">referenced rows</dfn> &mdash; a possibly empty list of pairs of a <a title="table foreign keys">foreign key</a> and a row in a table within the same table group (which may be another row in the table that this row appears in)</li>
          <li><dfn title="row cells">cells</dfn> &mdash; the list of <a title="cell">cells</a> in the row. A row MUST contain one cell from each <a>column</a> in the table. The order of the cells in the list MUST match the order of the columns in which they appear within the <a>table columns</a> for the row's table.</li>
        </ul>
        <p>
          Rows MAY have any number of additional <a title="annotation">annotations</a>. The annotations on a row provide additional metadata about the information held in the row, such as:
        </p>
        <ul>
          <li>the certainty of the information in that row</li>
          <li>information about the source or provenance of the data in that row</li>
        </ul>
      </section>
      <section>
        <h3>Cells</h3>
        <p>
          A <dfn>cell</dfn> represents a cell at the intersection of a <a>row</a> and a <a>column</a> within a <a>table</a>. The <a>core annotations</a> of a cell are:
        </p>
        <ul>
          <li><dfn title="cell table">table</dfn> &mdash; the <a>table</a> that the cell appears in</li>
          <li><dfn title="cell column">column</dfn> &mdash; the <a>column</a> that the cell appears in; the cell MUST be in the <a title="column cells">cells</a> for that column</li>
          <li><dfn title="cell row">row</dfn> &mdash; the <a>row</a> that the cell appears in; the cell MUST be in the <a title="row cells">cells</a> for that row</li>
          <li><dfn>string value</dfn> &mdash; a string that is the original syntactic representation of the value of the cell, eg how the cell appears within a CSV file; this may be an empty string</li>
          <li><dfn title="cell value">value</dfn> &mdash; the semantic value of the cell; this MAY be of a datatype other than a string, MAY be a list, and MAY be <code>null</code>. For example, annotations might enable a processor to understand the <a>string value</a> of the cell as representing a number or a date. By default, if the <a>string value</a> is an empty string, the semantic value of the cell is <code>null</code>. See <a href="http://w3c.github.io/csvw/metadata/#parsing-cells">Parsing Cells</a> in [[!tabular-metadata]] for further requirements on obtaining a cell value.</li>
          <li><dfn title="cell ordered">ordered</dfn> &mdash; a boolean that, if the value of this cell is a list, indicates whether the order of that list should be preserved or not</li>
          <li><dfn title="cell errors">errors</dfn> &mdash; a (possibly empty) list of validation errors generated while parsing the value of the cell</li>
          <li><dfn title="cell text direction">text direction</dfn> &mdash; which direction the text within the cell should be displayed, as described in <a href="#bidirectional-tables" class="sectionRef"></a></li>
          <li><dfn title="cell about URL">about URL</dfn> &mdash; a URL for the entity that this cell provides information about</li>
          <li><dfn title="cell property URL">property URL</dfn> &mdash; a URL for the property that this cell provides</li>
          <li><dfn title="cell value URL">value URL</dfn> &mdash; a URL for this cell's value</li>
        </ul>
        <p class="note">
          There presence or absence of quotes around a value within a CSV file is a syntactic detail that is not reflected in the tabular data model. In other words, there is no distinction in the model between the second value in <code>a,,z</code> and the second value in <code>a,"",z</code>.
        </p>
        <p>
          Cells MAY have any number of additional <a title="annotation">annotations</a>. The annotations on a cell provide metadata about the value held in the cell, particularly when this overrides the information provided for the <a>column</a> and <a>row</a> that the cell falls within. Annotations on a cell might be:
        </p>
        <ul>
          <li>notes to aid the interpretation of the value</li>
          <li>information about the source or provenance of the data in that cell</li>
        </ul>
      </section>
    </section>
    <section>
      <h2>Locating Metadata</h2>
      <p>
        As described in <a href="#annotated-tabular-data-model" class="sectionRef"></a>, tabular data may have a number of annotations associated with it. Here we describe the different methods that can be used to locate metadata that provides those annotations.
      </p>
      <p>
        In most methods of locating metadata described here, metadata is provided within separate documents. The syntax of these documents is defined in [[!tabular-metadata]]. These documents can include things like:
      </p>
      <ul>
        <li>metadata about groups of tables, such as provenance, and links to other groups of tables</li>
        <li>metadata about tables, such as titles, descriptions, provenance, and links to other tables</li>
        <li>metadata about columns in the table, such as titles, data types and other constraints, or flags to indicate values in the column are unique</li>
        <li>metadata about rows in the table, such as certainty or provenance</li>
        <li>metadata about values in the table, such as notes or type annotations</li>
      </ul>
      <p>
        When creating a set of annotations from metadata, if the same property is specified in two locations then information "closer" to the end user or interpreter of the document overrides other information, and information "closer" to the document itself overrides information "further" from the document. Explicitly, the order of precedence is:
      </p>
      <ol>
        <li>metadata supplied by the user of the implementation that is processing the tabular data, see <a href="#overriding-metadata" class="sectionRef"></a></li>
        <li>metadata embedded within the tabular data file itself, see <a href="#embedded-metadata" class="sectionRef"></a></li>
        <li>metadata in a document linked to using a <code>Link</code> header associated with the tabular data file, see <a href="#link-header" class="sectionRef"></a></li>
        <li>file-specific metadata in a document located based on the location of the tabular data file, see <a href="#standard-file-metadata" class="sectionRef"></a></li>
        <li>directory-specific metadata in a document located based on the location of the tabular data file, see <a href="#standard-directory-metadata" class="sectionRef"></a></li>
      </ol>
      <p>
        Processors MUST attempt to locate metadata documents based on each of these locations in order, and use all metadata documents that are successfully located in this way, merging them in the order found as defined in <a href="http://w3c.github.io/csvw/metadata/#merging-metadata"></a> in [[!tabular-metadata]].
      </p>
      <p>If no metadata is supplied or found, then the following Metadata is used as the default for extracted <a>embedded metadata</a>:</p>
      <pre>
{
  "@type": "TableGroup",
  "resources": []
}
      </pre>
      <p class="issue" data-number="175">
        This particular value for default metadata will allow a header line to be extracted from the tabular data file to create simple metadata using header cells as column names and titles.
      </p>
      <section>
        <h3>Overriding Metadata</h3>
        <p>
          Processors SHOULD provide users with the facility to provide their own metadata for tabular data files that they process. This might be provided:
        </p>
        <ul>
          <li>by providing processor options, such as using command-line options for a command-line implementation or checkboxes in a GUI</li>
          <li>by enabling the user to select an existing metadata file, which may be local or remote</li>
          <li>by enabling the user to specify a series of metadata files, which are merged by the processor and handled as if they were a single file</li>
        </ul>
        <p>
          For example, a processor might be invoked with:
        </p>
        <pre class="example" title="Command-line CSV processing with column types">
$ csvlint data.csv --datatypes:string,float,string,string
        </pre>
        <p>
          to enable the testing of the types of values in the columns of a CSV file, or with:
        </p>
        <pre class="example" title="Command-line CSV processing with a schema">
$ csvlint data.csv --schema:schema.json
        </pre>
        <p>
          to supply a schema that describes the contents of the file, against which it can be validated.
        </p>
        <p>
          Metadata supplied in this way is called overriding, or user-supplied, metadata. Implementations should define how this is mapped into the vocabulary defined in [[!tabular-metadata]].
        </p>
      </section>
      <section>
        <h3>Embedded Metadata</h3>
        <p>
          Most syntaxes for tabular data provide a facility for <dfn title="embedded metadata">embedding metadata</dfn> within the tabular data file itself. The definition of a syntax for tabular data SHOULD include a description of how the syntax maps to an annotated data model, and in particular how any embedded metadata is mapped into the vocabulary defined in [[!tabular-metadata]]. For example, the following tab-delimited file contains embedded metadata:
        </p>
        <pre class="example" title="Tab-separated file containing embedded metadata">
# publisher City of Palo Alto
# updated 12/31/2010
#name GID on_street species trim_cycle  inventory_date
#datatype string  string  string  string  date:M/D/YYYY
  GID On Street Species Trim Cycle  Inventory Date
  1 ADDISON AV  Celtis australis  Large Tree Routine Prune  10/18/2010
  2 EMERSON ST  Liquidambar styraciflua Large Tree Routine Prune  6/2/2010
        </pre>
        <p>
          A processor that recognises this format may be able to extract and make sense of this embedded metadata. <a href="#parsing" class="sectionRef"></a> provides an informative guide on how embedded metadata commonly used within "CSV" files can be extracted.
        </p>
      </section>
      <section>
        <h3>Link Header</h3>
        <p>
          When retrieving a tabular data file via HTTP, the response MAY include a <code>Link</code> header with <code>rel="describedby"</code> and <code>type="application/csvm+json"</code> that points to a metadata file that describes the tabular data file. If there is more than one valid metadata file linked to through multiple <code>Link</code> headers, then the metadata referenced by <code>Link</code> headers that appear later in the response are used instead of those referenced by earlier <code>Link</code> headers.
        </p>
        <p>
          For example, when the response to requesting a tab-separated file looks like:
        </p>
        <pre class="example highlight" title="HTTP response including Link headers">
HTTP/1.1 200 OK
Content-Type: text/tab-separated-values
...
Link: &lt;metadata.ttl&gt;; rel="describedBy"; type="text/turtle"
Link: &lt;metadata.json&gt;; rel="describedBy"; type="application/csvm+json"
        </pre>
        <p>
          an implementation should use the referenced <code>metadata.json</code> to supply metadata for processing the file.
        </p>
        <p>
          If the metadata file found at this location does not explicitly include a reference to the relevant tabular data file then it MUST be ignored.
        </p>
      </section>
      <section>
        <h3>Standard File Metadata</h3>
        <p>
          Processors MUST also attempt to locate a file-specific metadata document. This method MUST NOT be used if the URL of the tabular data file contains a query component.
        </p>
        <p>
          In this case, the file-specific metadata document should be located at <code><var>location</var>-metadata.json</code>, where <var>location</var> is the base URL of the tabular data file with the fragment component of the URL removed, if applicable.
        </p>
        <p>
          For example, if the tabular data file is at <code>http://example.org/south-west/devon.csv</code> then processors should attempt to locate a metadata document at <code>http://example.org/south-west/devon.csv-metadata.json</code>. On the other hand, if the tabular data file is at <code>http://example.com/index.php?file=43178.csv</code> then, because the URL of the tabular data file includes a query component, the processor should not attempt to look for a file-specific metadata document.
        </p>
        <p>
          If the metadata file found at this location does not explicitly include a reference to the relevant tabular data file then it MUST be ignored.
        </p>
      </section>
      <section>
        <h3>Standard Directory Metadata</h3>
        <p>
          Processors MUST attempt to locate a directory-level metadata document. This method MUST NOT be used if the URL of the tabular data file contains a query component.
        </p>
        <p>
          The common metadata document for a directory can be located by resolving the relative URL <code>metadata.json</code> against the base URL of the tabular data file.
        </p>
        <p>
          For example, if the tabular data file is at <code>http://example.org/south-west/devon.csv</code> then processors should attempt to locate a metadata file at <code>http://example.org/south-west/metadata.json</code>. On the other hand, if the tabular data file is at <code>http://example.com/index.php?file=43178.csv</code> then, because the URL of the tabular data file includes a query component, the processor should not attempt to look for a directory-level metadata document.
        </p>
        <p>
          If the metadata file found at this location does not explicitly include a reference to the relevant tabular data file then it MUST be ignored.
        </p>
      </section>
    </section>
    <section>
      <h2>Processing Tables</h2>
      <p>
        This section describes how particular types of applications should process tabular data and metadata files.
      </p>
      <p>
        In many cases, applications will start from a tabular data file, such as a CSV file, and <a href="#locating-metadata">locate metadata</a> from that file. This metadata will inform the processing of the tabular data file.
      </p>
      <p>
        In other cases, an application might start from a metadata file. In that case, the initial metadata file is treated as <a href="#overriding-metadata">overriding metadata</a> and the application SHOULD continue to retrieve other available metadata, located in the normal way, about each of the tabular data files referenced by that initial metadata file.
      </p>
      <p>
        For example, if a validator is passed a locally authored metadata file <code>spending.json</code>, which contains:
      </p>
      <pre class="example highlight" type="Metadata file referencing multiple tabular data files sharing a schema">
{
  "tableSchema": "government-spending.csv",
  "resources": [{
    "url": "http://example.org/east-sussex-2015-03.csv",
  }, {
    "url": "http://example.org/east-sussex-2015-02.csv"
  }, ... 
  ]
}
      </pre>
      <p>
        the validator would validate all the listed resources, using the locally defined schema at <code>government-spending.csv</code>. It would still use the metadata located from the referenced CSV files; for example, when processing <code>http://example.org/east-sussex-2015-03.csv</code>, it would use embedded metadata within that file, referenced from any <code>Link</code> header found when retrieving that file, and at <code>http://example.org/east-sussex-2015-03.csv-metadata.json</code> and <code>http://example.org/metadata.json</code>.
      </p>
      <section>
        <h2>Creating Annotated Tables</h2>
        <p>After locating metadata, all metadata documents discovered are <a href="http://w3c.github.io/csvw/metadata/#dfn-merged" class="externalDFN">merged</a> into a single description containing all <a title="annotation">annotations</a>. When starting with a metadata file, this involves merging any metadata located about the referenced tabular data files into that metadata file. When starting with a tabular data file this involves locating all metadata as described in <a href="#locating-metadata" class="sectionRef"></a> and merging all relevant metadata into a single descriptor.
        </p>
        <p>If processing starts with a tabular data file, implementations:</p>
        <ol class="algorithm">
          <li>Retrieve the tabular data file.</li>
          <li>Retrieve the metadata files described in <a href="#locating-metadata" class="sectionRef"></a>:
            <ol class="algorithm">
              <li>metadata supplied by the user (<code>UM</code>) (see <a href="#overriding-metadata" class="sectionRef"></a>)</li>
              <li>metadata referenced from a <em>Link Header</em> that may be returned when retrieving the tabular data file (<code>LM</code>) (see <a href="#link-header" class="sectionRef"></a>)</li>
              <li>file-specific metadata in a document located based on the location of the tabular data file (<code>FM</code>) (see <a href="#standard-file-metadata" class="sectionRef"></a>)</li>
              <li>directory-specific metadata in a document located based on the location of the tabular data file  (<code>DM</code>) (see <a href="#standard-directory-metadata" class="sectionRef"></a>)</li>
            </ol>
          </li>
          <li>Extract the <em>first available</em> <a href="http://www.w3.org/TR/tabular-metadata/#dialect-descriptions">dialect description</a> (<code>DD</code>) from the metadata files <code>UM</code>, <code>LM</code>, <code>FM</code>, <code>DM</code> (in this order) for the table description associated with the tabular data file. If there is no such dialect description, extract the first available dialect description from a table group description in which the tabular data file is described. Otherwise use the default dialect description.</li>
          <li>If the tabular data file was retrieved with <code>Content-Type</code> including the <code>header=absent</code> parameter set <code>header</code> to <code>false</code> in <code>DD</code>.</li>
          <li>
            Parse the tabular data file, using <code>DD</code> as a guide, to create a basic tabular data model (<code>T</code>). Extract embedded metadata (<code>EM</code>), for example from the <a>header line</a>.
            <p class="note">Note: This specification provides a non-normative definition for parsing tabular data files, including the extraction of embedded metadata, in <a href="#parsing-tabular-data" class="sectionRef"></a>. No definition of the format of embedded metadata is given here; whatever syntax is used, it's assumed that metadata can be mapped to the vocabulary defined in [[!tabular-metadata]].</p>
          </li>
          <li>Create the merged metadata <code>M = merge(UM, EM, LM, FM, DM)</code> using the <a href="http://w3c.github.io/csvw/metadata/#dfn-merged" class="externalDFN">merge algorithm</a> defined in [[!tabular-metadata]].</li>
          <li>Use the metadata <code>M</code> to add annotations to the tabular data model <code>T</code> as described in <a href="http://w3c.github.io/csvw/metadata/#annotating-tables">Section 2 Annotating Tables</a> in [[!tabular-metadata]].</li>
        </ol>
        <p>If the process starts with a Metadata file:</p>
        <ol class="algorithm">
          <li>Retrieve the metadata file yielding the metadata <code>UM</code> (which is treated as overriding metadata, see <a href="#overriding-metadata" class="sectionRef"></a>).</li>
          <li>For each table description in <code>UM</code>, run the steps for a tabular data file using the <code>url</code> from the table description with <code>UM</code> playing the role of <code>UM</code> to create one or more <a title="annotated table">annotated tables</a>.</li>
        </ol>
      </section>
      <section>
        <h3>Displaying Tables</h3>
        <div class="issue">
          <p>
            We intend to include other sections here about:
          </p>
          <ul>
            <li>displaying metadata about groups of tables, tables, columns, rows, cells and regions</li>
            <li>what headings to use for columns when displaying tabular content</li>
            <li>how to format values in cells</li>
          </ul>
          <p>
            Much of this is likely to be non-normative. We invite comment on whether it's useful to provide this kind of guidance.
          </p>
        </div>
        <section>
          <h4>Bidirectional Tables</h4>
          <p>
            There are two levels of bidirectionality to consider when displaying tables: the directionality of the table (ie whether the columns should be arranged left-to-right or right-to-left) and the directionality of the content of individual cells.
          </p>
          <p>
            The <a href="http://w3c.github.io/csvw/metadata/#tableDirection"><code>tableDirection</code> annotation</a> provides information about the desired display of the table. If <code>tableDirection=ltr</code> then the first column SHOULD be displayed on the left and the last column on the right. If <code>tableDirection=rtl</code> then the first column SHOULD be displayed on the right and the last column on the left.
          </p>
          <p>
            If <code>tableDirection=default</code> then tables SHOULD be displayed with attention to the bidirectionality of the content of the file. Specifically, the values of the cells in the table should be scanned breadth first: from the first cell in the first column through to the last cell in the first column, down to the last cell in the last column. If the first character in the table with a <a href="http://unicode.org/reports/tr9/#Bidirectional_Character_Types">strong type</a> as defined in [[!UNICODE-BIDI]] indicates a <abbr title="right-to-left">RTL</abbr> directionality, the table should be displayed with the first column on the right and the last column on the left. Otherwise, the table should be displayed with the first column on the left and the last column on the right. Characters such as whitespace, quotes, commas and numbers do not have a strong type, and therefore are skipped when identifying the character that determines the directionality of the table.
          </p>
          <p>
            Implementations SHOULD enable user preferences to override the indicated metadata about the directionality of the table.
          </p>
          <p>
            Once the directionality of the table has been determined, each cell within the table should be considered as a separate <a href="http://unicode.org/reports/tr9/#The_Paragraph_Level">paragraph</a>, as defined by the <abbr title="Unicode Bidirectional Algorithm">UBA</abbr> in [[!UNICODE-BIDI]]. The default directionality for the cell is determined by looking at the <a href="http://w3c.github.io/csvw/metadata/#cell-textDirection"><code>textDirection</code> property</a>, which is an <a href="http://w3c.github.io/csvw/metadata/#dfn-inherited-property" class="externalDFN">inherited property</a>.
          </p>
          <p>
            Thus, as defined by the <abbr title="Unicode Bidirectional Algorithm">UBA</abbr>, if a cell contains no characters with a strong type (if it's a number or date for example) then the way the cell is displayed should be determined by the <a href="http://w3c.github.io/csvw/metadata/#cell-textDirection"><code>textDirection</code> property</a> of the cell. However, when the cell contains characters with a strong type (such as letters) then they MUST be displayed according to the Unicode Bidirectional Algorithm as described in [[!UNICODE-BIDI]].
          </p>
        </section>
      </section>
      <section>
        <h3>Validating Tables</h3>
        <p>
          <a href="http://w3c.github.io/csvw/metadata/#dfn-validators" class="externalDFN">Validators</a> test whether given tabular data files adhere to the structure defined within a <a href="http://w3c.github.io/csvw/metadata/#dfn-schema" class="externalDFN">schema</a>. Validators MUST raise errors as defined in [[!tabular-metadata]] and in the following situations:
        </p>
        <ul>
          <li>if there is more than one <a>row</a> with the same <a title="row primary key">primary key</a>, that is where the <a title="cell">cells</a> listed for the primary key for the row have the same <a title="cell value">values</a> as the cells listed for the primary key for another row</li>
          <li>for each <a>row</a> that does not have a <a title="row referenced rows">referenced row</a> for each of the <a title="table foreign keys">foreign keys</a> on the <a>table</a> the row appears in</li>
          <li>for each <a>cell</a> in a <a>column</a> whose <a title="column required">required</a> annotation is <code>true</code></li>
          <li>for each <a title="cell errors">error</a> on each <a>cell</a></li>
        </ul>
        <p class="note">
          There is no obligation for processors to halt processing at the first error.
        </p>
      </section>
      <section>
        <h3>Converting Tables</h3>
        <p>
          Conversions of tabular data to other formats operate over a <a>annotated table</a> constructed as defined in <cite><a href="http://w3c.github.io/csvw/metadata/#annotating-tables">Annotating Tables</a></cite> in [[!tabular-metadata]]. The mechanics of these conversions to other formats are defined in other specifications.
        </p>
        <p>
          Conversion specifications MUST define a default mapping from an annotated table that lacks any annotations (ie that is equivalent to an un-annotated table).
        </p>
        <p>
          Conversion specifications MUST use the <a href="http://w3c.github.io/csvw/metadata/#dfn-inherited-property" class="externalDFN">property value</a> of the <a href="http://w3c.github.io/csvw/metadata/#cell-propertyUrl"><code>propertyUrl</code></a> of a column as the basis for naming machine-readable fields in the target format, such as the name of the equivalent element or attribute in XML, property in JSON or property URI in RDF.
        </p>
        <p>
          Conversion specifications MAY use any of the annotations defined in [[!tabular-metadata]] to adjust the mapping of an annotated table into another format.
        </p>
        <p>
          Conversion specifications MAY define additional annotations, not defined in [[!tabular-metadata]], which are specifically used when converting to the target format of the conversion. For example, a conversion to XML might specify a <code>http://example.org/conversion/xml/element-or-attribute</code> property on columns that determines whether a particular column is represented through an element or an attribute in the data.
        </p>
        <p>
          Conversion specifications SHOULD specify format-specific properties specifying external processing steps to provide more control to people defining conversions. If these are specified, the conversion specification MUST specify at what point in the processing this external processing takes place, and what it takes place on. Examples might be:
        </p>
        <ul>
          <li>the URL of an XSLT file that is used to process XML after it is generated</li>
          <li>a string containing a SPARQL CONSTRUCT pattern that is executed on RDF after it is generated</li>
          <li>properties that contain definitions of Javascript callback functions that are used when processing particular columns or individual rows</li>
        </ul>
      </section>
    </section>
    <section id="syntax" class="informative">
      <h2>Best Practice CSV</h2>
      <p>
        There is no standard for CSV, and there are many variants of CSV used on the web today. This section defines a method for expressing tabular data adhering to the <a>annotated tabular data model</a> defined in <a href="#annotated-tabular-data-model" class="sectionRef"></a> in CSV. Authors are encouraged to adhere to the constraints described in this section as implementations should process such CSV files consistently.
      </p>
      <div class="note">
        <p>
          This syntax is not compliant with <code>text/csv</code> as defined in [[!RFC4180]] in that it permits line endings other than <code>CRLF</code>. Supporting <code>LF</code> line endings are important characteristics for data formats that are used on non-Windows platforms. However, all files that adhere to [[!RFC4180]]'s definition of CSV meet the constraints described in this section.
        </p>
        <p>
          We are actively working with the IETF to develop a standard for CSV, which is outside the scope of the Working Group. The details here aim to help shape that standard based on our requirements.
        </p>
      </div>
      <section id="content-type">
        <h3>Content Type</h3>
        <p>
          The appropriate content type for a CSV file is <code>text/csv</code>. For example, when a CSV file is transmitted via HTTP, the HTTP response MUST include a <code>Content-Type</code> header with the value <code>text/csv</code>:
        </p>
        <pre>
Content-Type: text/csv
        </pre>
      </section>
      <section id="encoding">
        <h3>Encoding</h3>
        <p>
          CSV files SHOULD be encoded using UTF-8. If a CSV file is not encoded using UTF-8, the encoding MUST be specified through the <code>charset</code> parameter in the <code>Content-Type</code> header:
        </p>
        <pre>
Content-Type: text/csv;charset=ISO-8859-1
        </pre>
      </section>
      <section id="line-endings">
        <h3>Line Endings</h3>
        <p>
          The ends of rows in a CSV file MUST be either <code>CRLF</code> (<code>U+000D U+000A</code>) or <code>LF</code> (<code>U+000A</code>). Line endings within escaped <a title="cell">cells</a> are not normalised.
        </p>
      </section>
      <section id="lines">
        <h3>Lines</h3>
        <p>
          Each line of a CSV file MUST contain the same number of comma-separated values.
        </p>
        <p>
          Values that contain commas, line endings or double quotes MUST be escaped by having the entire value wrapped in double quotes. There MUST NOT be whitespace before or after the double quotes. Within these escaped cells, any double quotes MUST be escaped with two double quotes (<code>""</code>).
        </p>
        <section id="headers">
          <h4>Headers</h4>
          <p>
            The first line of a CSV file SHOULD contain a comma-separated list of names of <a title="column">columns</a>. This is known as the <dfn>header line</dfn> and provides titles for the columns. There are no constraints on these titles.
          </p>
          <p>
            If a CSV file does not include a header line, this MUST be specified using the <code>header</code> parameter of the media type:
          </p>
          <pre>
Content-Type: text/csv;header=absent
          </pre>
        </section>
        <section>
          <h4>Bidirectionality in CSV Files</h4>
          <p>
            Bidirectional content does not alter the definition of rows or the assignment of cells to columns. Whether or not a CSV file contains right-to-left characters, the first column's content is the first cell of each row, which is the text prior to the first occurrence of a comma within that row.
          </p>
          <div class="example" title="Bidirectional CSV file">
            <p>
              For example, <a href="http://referendum2012.elections.eg/results/referendum-results">Egyptian Referendum results</a> are available as a CSV file at <a href="https://egelections-2011.appspot.com/Referendum2012/results/csv/EG.csv">https://egelections-2011.appspot.com/Referendum2012/results/csv/EG.csv</a>. Over the wire and in non-Unicode-aware text editors, the CSV looks like:
            </p>
            <pre>
              <bdo dir="ltr">
&#8204;ا&#8204;ل&#8204;م&#8204;ح&#8204;ا&#8204;ف&#8204;ظ&#8204;ة&#8204;,&#8204;ن&#8204;س&#8204;ب&#8204;ة&#8204; &#8204;م&#8204;و&#8204;ا&#8204;ف&#8204;ق&#8204;,&#8204;ن&#8204;س&#8204;ب&#8204;ة&#8204; &#8204;غ&#8204;ي&#8204;ر&#8204; &#8204;م&#8204;و&#8204;ا&#8204;ف&#8204;ق&#8204;,&#8204;ع&#8204;د&#8204;د&#8204; &#8204;ا&#8204;ل&#8204;ن&#8204;ا&#8204;خ&#8204;ب&#8204;ي&#8204;ن&#8204;,&#8204;ا&#8204;ل&#8204;أ&#8204;ص&#8204;و&#8204;ا&#8204;ت&#8204; &#8204;ا&#8204;ل&#8204;ص&#8204;ح&#8204;ي&#8204;ح&#8204;ة&#8204;,&#8204;ا&#8204;ل&#8204;أ&#8204;ص&#8204;و&#8204;ا&#8204;ت&#8204; &#8204;ا&#8204;ل&#8204;ب&#8204;ا&#8204;ط&#8204;ل&#8204;ة&#8204;,&#8204;ن&#8204;س&#8204;ب&#8204;ة&#8204; &#8204;ا&#8204;ل&#8204;م&#8204;ش&#8204;ا&#8204;ر&#8204;ك&#8204;ة&#8204;,&#8204;م&#8204;و&#8204;ا&#8204;ف&#8204;ق&#8204;,&#8204;غ&#8204;ي&#8204;ر&#8204; &#8204;م&#8204;و&#8204;ا&#8204;ف&#8204;ق&#8204;
&#8204;ا&#8204;ل&#8204;ق&#8204;ل&#8204;ي&#8204;و&#8204;ب&#8204;ي&#8204;ة&#8204;,60.0,40.0,"2,639,808","853,125","15,224",32.9,"512,055","341,070"
&#8204;ا&#8204;ل&#8204;ج&#8204;ي&#8204;ز&#8204;ة&#8204;,66.7,33.3,"4,383,701","1,493,092","24,105",34.6,"995,417","497,675"
&#8204;ا&#8204;ل&#8204;ق&#8204;ا&#8204;ه&#8204;ر&#8204;ة&#8204;,43.2,56.8,"6,580,478","2,254,698","36,342",34.8,"974,371","1,280,327"
&#8204;ق&#8204;ن&#8204;ا&#8204;,84.5,15.5,"1,629,713","364,509","6,743",22.8,"307,839","56,670"
...
              </bdo>
            </pre>
            <p>
              Within this CSV file, the first column appears as the content of each line before the first comma and is named <code>المحافظة</code> (appearing at the start of each row as <code><bdo dir="ltr">&#8204;ا&#8204;ل&#8204;م&#8204;ح&#8204;ا&#8204;ف&#8204;ظ&#8204;ة&#8204;</bdo></code> in the example, which is displaying the relevant characters from left to right in the order they appear "on the wire").
            </p>
            <p>
              The CSV translates to a table model that looks like:
            </p>
            <table style="width: 100%; text-align: right">
              <col style="width: 10%"/>
              <col style="width: 10%"/>
              <col style="width: 10%"/>
              <col style="width: 10%"/>
              <col style="width: 10%"/>
              <col style="width: 10%"/>
              <col style="width: 10%"/>
              <col style="width: 10%"/>
              <col style="width: 10%"/>
              <col style="width: 10%"/>
              <thead>
                <tr style="text-align: center">
                  <th>Column / Row</th>
                  <th>column 1</th>
                  <th>column 2</th>
                  <th>column 3</th>
                  <th>column 4</th>
                  <th>column 5</th>
                  <th>column 6</th>
                  <th>column 7</th>
                  <th>column 8</th>
                  <th>column 9</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <th>column names</th><th>المحافظة</th><th>نسبة موافق</th><th>نسبة غير موافق</th><th>عدد الناخبين</th><th>الأصوات الصحيحة</th><th>الأصوات الباطلة</th><th>نسبة المشاركة</th><th>موافق</th><th>غير موافق</th>
                </tr>
                <tr>
                  <th>row 1</th><td>القليوبية</td><td>60.0</td><td>40.0</td><td>2,639,808</td><td>853,125</td><td>15,224</td><td>32.9</td><td>512,055</td><td>341,070</td>
                </tr>
                <tr>
                  <th>row 2</th><td>الجيزة</td><td>66.7</td><td>33.3</td><td>4,383,701</td><td>1,493,092</td><td>24,105</td><td>34.6</td><td>995,417</td><td>497,675</td>
                </tr>
                <tr>
                  <th>row 3</th><td>القاهرة</td><td>43.2</td><td>56.8</td><td>6,580,478</td><td>2,254,698</td><td>36,342</td><td>34.8</td><td>974,371</td><td>1,280,327</td>
                </tr>
                <tr>
                  <th>row 4</th><td>قنا</td><td>84.5</td><td>15.5</td><td>1,629,713</td><td>364,509</td><td>6,743</td><td>22.8</td><td>307,839</td><td>56,670</td>
                </tr>
              </tbody>
            </table>
            <p>
              The fragment identifier <code>#col=3</code> identifies the third of the columns, named <code>نسبة غير موافق</code> (appearing as <code><bdo dir="ltr">&#8204;ن&#8204;س&#8204;ب&#8204;ة&#8204; &#8204;غ&#8204;ي&#8204;ر&#8204; &#8204;م&#8204;و&#8204;ا&#8204;ف&#8204;ق&#8204;</bdo></code> in the example).
            </p>
            <p>
              <a href="#bidirectional-tables" class="sectionRef"></a> defines how this table model should be displayed by compliant applications, and how metadata can affect the display. The default is for the display to be determined by the content of the table. For example, if this CSV were turned into an HTML table for display into a web page, it should be displayed with the first column on the right and the last on the left, as follows:
            </p>
            <table style="width: 100%; text-align: right">
              <thead>
                <tr>
                  <th>غير موافق</th>
                  <th>موافق</th>
                  <th>نسبة المشاركة</th>
                  <th>الأصوات الباطلة</th>
                  <th>الأصوات الصحيحة</th>
                  <th>عدد الناخبين</th>
                  <th>نسبة غير موافق</th>
                  <th>نسبة موافق</th>
                  <th>المحافظة</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>341,070</td>
                  <td>512,055</td>
                  <td>32.9</td>
                  <td>15,224</td>
                  <td>853,125</td>
                  <td>2,639,808</td>
                  <td>40.0</td>
                  <td>60.0</td>
                  <td>القليوبية</td>
                </tr>
                <tr>
                  <td>497,675</td>
                  <td>995,417</td>
                  <td>34.6</td>
                  <td>24,105</td>
                  <td>1,493,092</td>
                  <td>4,383,701</td>
                  <td>33.3</td>
                  <td>66.7</td>
                  <td>الجيزة</td>
                </tr>
                <tr>
                  <td>1,280,327</td>
                  <td>974,371</td>
                  <td>34.8</td>
                  <td>36,342</td>
                  <td>2,254,698</td>
                  <td>6,580,478</td>
                  <td>56.8</td>
                  <td>43.2</td>
                  <td>القاهرة</td>
                </tr>
                <tr>
                  <td>56,670</td>
                  <td>307,839</td>
                  <td>22.8</td>
                  <td>6,743</td>
                  <td>364,509</td>
                  <td>1,629,713</td>
                  <td>15.5</td>
                  <td>84.5</td>
                  <td>قنا</td>
                </tr>
              </tbody>
            </table>
            <p>
              The fragment identifier <code>#col=3</code> still identifies the third of the columns, named <code>نسبة غير موافق</code>, which appears in the HTML display as the third column from the right and is what those who read right-to-left would think of as the third column.
            </p>
            <p>
              Note that this display matches that shown <a href="http://referendum2012.elections.eg/results/referendum-results">on the original website</a>.
            </p>
          </div>
          <div class="issue" data-number="46">
            <p>
              An alternative approach is for the CSV to be parsed into a table model in which the columns are numbered in the reverse, for tables which are either marked as or detected to be right-to-left tables. For example, we could introduce a <code>bidi=rtl</code> or similar media type parameter, and use this to determine whether the first column in table generated from the CSV is the text before the first comma in each line or the text after the last comma in the line.
            </p>
            <p>
             In the example above, if the CSV were served with <code>bidi=rtl</code>, or the table was detected as being a right-to-left table, then the column numbering in the model would be reversed:
            </p>
            <table style="width: 100%; text-align: right">
              <col style="width: 10%"/>
              <col style="width: 10%"/>
              <col style="width: 10%"/>
              <col style="width: 10%"/>
              <col style="width: 10%"/>
              <col style="width: 10%"/>
              <col style="width: 10%"/>
              <col style="width: 10%"/>
              <col style="width: 10%"/>
              <col style="width: 10%"/>
              <thead>
                <tr style="text-align: center">
                  <th>Column / Row</th>
                  <th>column 9</th>
                  <th>column 8</th>
                  <th>column 7</th>
                  <th>column 6</th>
                  <th>column 5</th>
                  <th>column 4</th>
                  <th>column 3</th>
                  <th>column 2</th>
                  <th>column 1</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <th>row 1 (header)</th><th>المحافظة</th><th>نسبة موافق</th><th>نسبة غير موافق</th><th>عدد الناخبين</th><th>الأصوات الصحيحة</th><th>الأصوات الباطلة</th><th>نسبة المشاركة</th><th>موافق</th><th>غير موافق</th>
                </tr>
                <tr>
                  <th>row 2</th><td>القليوبية</td><td>60.0</td><td>40.0</td><td>2,639,808</td><td>853,125</td><td>15,224</td><td>32.9</td><td>512,055</td><td>341,070</td>
                </tr>
                <tr>
                  <th>row 3</th><td>الجيزة</td><td>66.7</td><td>33.3</td><td>4,383,701</td><td>1,493,092</td><td>24,105</td><td>34.6</td><td>995,417</td><td>497,675</td>
                </tr>
                <tr>
                  <th>row 4</th><td>القاهرة</td><td>43.2</td><td>56.8</td><td>6,580,478</td><td>2,254,698</td><td>36,342</td><td>34.8</td><td>974,371</td><td>1,280,327</td>
                </tr>
                <tr>
                  <th>row 5</th><td>قنا</td><td>84.5</td><td>15.5</td><td>1,629,713</td><td>364,509</td><td>6,743</td><td>22.8</td><td>307,839</td><td>56,670</td>
                </tr>
              </tbody>
            </table>
            <p>
              This would require a change to [[RFC7111]] but that might be required by updates to the definition of <code>text/csv</code> in any case. With the change, the fragment identifier <code>#col=3</code> would then refer to the third column from the right, named <code>نسبة المشاركة</code>.
            </p>
            <p>
              If the model were defined in this way, there would be no need to determine the order of the columns when displayed using a metadata property. Columns would always be displayed with the first column (numbered 1 in the model) on the left. The final display in HTML, for example, would be exactly as above. The only difference would be that <code>#col=3</code> would refer to the third column from the left.
            </p>
            <p>
              We note that using media type parameters is problematic because publishers might not have the ability to set them on their servers, and because they can easily get lost as a file is republished or emailed between people.
            </p>
            <p>
              We invite comment on the best way to approach bidirectionality in CSV files.
            </p>
          </div>
        </section>
      </section>

      <section id="ebnf">
        <h3>Grammar</h3>
        <p>This grammar is a generalization of that defined in [[!RFC4180]] and is included for reference only.</p>
        <p>The <abbr title="Extended Backus–Naur Form">EBNF</abbr> used here is defined in XML 1.0 [[EBNF-NOTATION]].</p>
        <div data-include="csv-plus.html"></div>
        <p class="note">
          We should probably place further restrictions on QCHAR and SCHAR to avoid control characters. If header weren’t optional, it would be better defined as in RFC4180, but if the syntax allows it to be optional, this would make it not an LL(1) grammar, which isn’t too much of an issue.
        </p>
      </section>
    </section>
    <section id="parsing" class="informative">
      <h2>Parsing Tabular Data</h2>
      <p>
        As described in <a href="#syntax" class="sectionRef"></a>, there may be many formats which an application might interpret into the tabular data model described in <a href="#model" class="sectionRef"></a>, including using different separators or fixed format tables, multiple tables within a single file, or ones that have metadata lines before a table header.
      </p>
      <p class="note">
        Standardising the parsing of CSV is outside the chartered scope of the Working Group. This non-normative section is intended to help the creators of parsers handle the wide variety of CSV-based formats that they may encounter due to the current lack of standardisation of the format.
      </p>
      <p>
        This section describes an algorithm for parsing formats that do not adhere to the constraints described in <a href="#syntax" class="sectionRef"></a>, as well as those that do, and extracting <a>embedded metadata</a>. The parsing algorithm uses the following flags. These may be set by metadata properties found while <a href="#locating-metadata" class="sectionRef">Locating Metadata</a>, including through user input (see <a href="overriding-metadata" class="sectionRef">Overriding Metadata</a>) or through the inclusion of a <a href="http://w3c.github.io/csvw/metadata/#dialect-descriptions">dialect description</a> within a metadata file:
      </p>
      <dl>
        <dt><dfn>encoding</dfn></dt>
        <dd>The character encoding for the file, one of the encodings listed in [[!encoding]]. The default is <code>utf-8</code>.</dd>
        <dt><dfn>line terminator</dfn></dt>
        <dd>The character that is used at the end of a row. The default is <code>CRLF</code>.</dd>
        <dt><dfn>quote character</dfn></dt>
        <dd>The character that is used around escaped cells. The default is <code>"</code>.</dd>
        <dt><dfn>escape character</dfn></dt>
        <dd>The character that is used to escape the <a>quote character</a> within escaped cells. The default is <code>"</code> (such that <code>""</code> is used to escape <code>"</code> within an escaped cell).</dd>
        <dt><dfn>skip rows</dfn></dt>
        <dd>The number of rows to skip at the beginning of the file, before a header row or tabular data. The default is <code>0</code>.</dd>
        <dt><dfn>comment prefix</dfn></dt>
        <dd>A character that, when it appears at the beginning of a skipped row, indicates a comment that should be associated as a comment annotation to the table. The default is <code>#</code>.</dd>
        <dt><dfn>header row count</dfn></dt>
        <dd>The number of header rows (following the skipped rows) in the file. The default is <code>1</code>.</dd>
        <dt><dfn>delimiter</dfn></dt>
        <dd>The separator between cells. The default is <code>,</code>.</dd>
        <dt><dfn>skip columns</dfn></dt>
        <dd>The number of columns to skip at the beginning of each row, before any header columns. The default is <code>0</code>.</dd>
        <dt><dfn>header column count</dfn></dt>
        <dd>The number of header columns (following the skipped columns) in each row. The default is <code>0</code>.</dd>
        <dt><dfn>skip blank rows</dfn></dt>
        <dd>Indicates whether to ignore wholly empty rows (ie rows in which all the cells are empty). The default is <code>false</code>.</dd>
        <dt><dfn>trim</dfn></dt>
        <dd>Indicates whether to trim whitespace around cells; may be <code>true</code>, <code>false</code>, <code>start</code> or <code>end</code>. The default is <code>false</code>.</dd>
      </dl>
      <p>
        The algorithm for parsing a document containing tabular data is as follows:
      </p>
      <ol class="algorithm">
        <li>Create <dfn>merged metadata</dfn> by locating all sources of metadata, other than embedded, as defined in <a href="#locating-metadata" class="sectionRef">Locating Metadata</a> and merge together in priority order as defined in <a href="http://w3c.github.io/csvw/metadata/#merging-metadata">Merging Metadata</a> in [[!tabular-metadata]].</li>
        <li>Read the file using the specified <a>encoding</a>.</li>
        <li>Find the rows. Each row ends with a <a>line terminator</a>, but values that are enclosed within the <a>quote character</a> may contain the <a>line terminator</a> without it indicating the end of the row. The <a>quote character</a> may be escaped using the <a>escape character</a> where it appears within cells. If the <a>escape character</a> is not the same as the <a>quote character</a> then the <a>escape character</a> is also used to escape the character that immediately follows it.</li>
        <li>Skip the number of rows indicated by the <a>skip rows</a> parameter. These form <code>rdfs:comment</code> annotations on the table. If a skipped row begins with the <a>comment prefix</a>, strip that prefix from the beginning of the row to create the content of the <code>rdfs:comment</code> annotation.</li>
        <li>Gather the number of header rows indicated by the <a>header row count</a> parameter; the remaining rows are data rows.</li>
        <li>
          Split the header and data rows into cells using the <a>delimiter</a>. Values that are enclosed within the <a>quote character</a> may contain the <a>delimiter</a>. The <a>quote character</a> may be escaped using the <a>escape character</a> where it appears within cells. If the <a>escape character</a> is not the same as the <a>quote character</a> then the <a>escape character</a> is also used to escape the character that immediately follows it.<br/>If <a>trim</a> is <code>true</code> or <code>start</code> then whitespace from the start of values that are not enclosed within the <a>quote character</a> is removed from the value. If <a>trim</a> is <code>true</code> or <code>end</code> then whitespace from the end of values that are not enclosed within the <a>quote character</a> is removed from the value.
        </li>
        <li>
          Construct <a>embedded metadata</a> as Table Metadata (see <cite><a href="http://w3c.github.io/csvw/metadata/#tables"></a></cite> in [[!tabular-metadata]]).
        </li>
        <li>In each row, ignore the number of columns indicated by the <a>skip columns</a> parameter. Always start from the first character in the row when counting columns (see <a href="#bidirectionality-in-csv-files" class="sectionRef"></a>).</li>
        <li>Gather the number of header columns indicated by the <a>header column count</a> parameter. Always start from the first character in the row when counting columns (see <a href="#bidirectionality-in-csv-files" class="sectionRef"></a>).</li>
        <li>Each cell within a header row that is not in a skipped or header column is a <code>title</code> annotation on that column.</li>
        <li>Each cell within a header column is an annotation on the row it appears in; if there is a header row then that provides the type of the annotation for the row, otherwise it is a <code>title</code> annotation.</li>
        <li>If <a>skip blank rows</a> is <code>true</code> then ignore any rows in which all the cell values are empty strings.</li>
        <li>Re-create <a>merged metadata</a> using by locating all sources of metadata, included embedded metadata as constructed above, as defined in <a href="#locating-metadata" class="sectionRef">Locating Metadata</a> and merge together in priority order as defined in <a href="http://w3c.github.io/csvw/metadata/#merging-metadata">Merging Metadata</a> in [[!tabular-metadata]].</li>
        <li>Generate row data for each row using <a>merged metadata</a> by parsing the cells from each row as defined in <cite><a href="http://w3c.github.io/csvw/metadata/#parsing-cells"></a>Parsing Cells</cite> in [[!tabular-metadata]] and adding empty cells for <a title="virtual column">virtual columns</a>.</li>
      </ol>
      <p class="note">
        This parsing algorithm does not account for the possibility of there being more than one area of tabular data within a single CSV file.
      </p>
      <section>
        <h3>Examples</h3>
        <section>
          <h4>Simple Example</h4>
          <p>
            A simple CSV file that complies to the constraints described in <a href="#syntax" class="sectionRef"></a>, at <code>http://example.org/tree-ops.csv</code>, might look like:
          </p>
          <pre class="example" title="Simple CSV file">
GID,On Street,Species,Trim Cycle,Inventory Date
1,ADDISON AV,Celtis australis,Large Tree Routine Prune,10/18/2010
2,EMERSON ST,Liquidambar styraciflua,Large Tree Routine Prune,6/2/2010
          </pre>
          <p>
            Parsing this file results in an <a>annotated tabular data model</a> of a single <a>table</a> <var>T</var> with five columns and two rows. The columns have the annotations shown in the following table:
          </p>
          <table style="width: 100%; text-align: left">
            <thead>
              <tr><th rowspan="2">id</th><th colspan="5">core annotations</th></tr>
              <tr><th>table</th><th>number</th><th>source number</th><th>cells</th><th>titles</th></tr>
            </thead>
            <tbody>
              <tr><td><var>C1</var></td><td><var>T</var></td><td>1</td><td>1</td><td><var>C1.1</var>, <var>C2.1</var></td><td><code>GID</code></td></tr>
              <tr><td><var>C2</var></td><td><var>T</var></td><td>2</td><td>2</td><td><var>C1.2</var>, <var>C2.2</var></td><td><code>On Street</code></td></tr>
              <tr><td><var>C3</var></td><td><var>T</var></td><td>3</td><td>3</td><td><var>C1.3</var>, <var>C2.3</var></td><td><code>Species</code></td></tr>
              <tr><td><var>C4</var></td><td><var>T</var></td><td>4</td><td>4</td><td><var>C1.4</var>, <var>C2.4</var></td><td><code>Trim Cycle</code></td></tr>
              <tr><td><var>C5</var></td><td><var>T</var></td><td>5</td><td>5</td><td><var>C1.5</var>, <var>C2.5</var></td><td><code>Inventory Date</code></td></tr>
            </tbody>
          </table>
          <p>The extracted embedded metadata, as defined in [[!tabular-metadata]], would look like:</p>
          <pre class="highlight">
{
  "@type": "Table",
  "url": "http://example.org/tree-ops.csv",
  "tableSchema": {
    "columns": [
      {"title": "GID"},
      {"title": "On Street"},
      {"title": "Species"},
      {"title": "Trim Cycle"},
      {"title": "Inventory Date"}
    ]
  }
}
          </pre>
          <p>
            The rows have the annotations shown in the following table:
          </p>
          <table style="width: 100%; text-align: left">
            <thead>
              <tr><th rowspan="2">id</th><th colspan="4">core annotations</th></tr>
              <tr><th>table</th><th>number</th><th>source number</th><th>cells</th></tr>
            </thead>
            <tbody>
              <tr><td><var>R1</var></td><td><var>T</var></td><td>1</td><td>2</td><td><var>C1.1</var>, <var>C1.2</var>, <var>C1.3</var>, <var>C1.4</var>, <var>C1.5</var></td></tr>
              <tr><td><var>R2</var></td><td><var>T</var></td><td>2</td><td>3</td><td><var>C2.1</var>, <var>C2.2</var>, <var>C2.3</var>, <var>C2.4</var>, <var>C2.5</var></td></tr>
            </tbody>
          </table>
          <p class="note">
            The <a title="row source number">source number</a> of each row is offset by one from the <a title="row number">number</a> of each row because in the source CSV file, the header line is the first line. It is possible to reconstruct a [[RFC7111]] compliant reference to the first record in the original CSV file (<code>http://example.org/tree-ops.csv#row=2</code>) using the value of the row's source number. This enables implementations to retain provenance between the table model and the original file.
          </p>
          <p>
            The cells have the annotations shown in the following table (note that the <a title="cell value">values</a> of all the cells in the table are strings, denoted by the double quotes in the table below):
          </p>
          <table style="width: 100%; text-align: left">
            <thead>
              <tr><th rowspan="2">id</th><th colspan="5">core annotations</th></tr>
              <tr><th>table</th><th>column</th><th>row</th><th>string value</th><th>value</th></tr>
            </thead>
            <tbody>
              <tr><td><var>C1.1</var></td><td><var>T</var></td><td><var>C1</var></td><td><var>R1</var></td><td><code>"1"</code></td><td><code>"1"</code></td></tr>
              <tr><td><var>C1.2</var></td><td><var>T</var></td><td><var>C2</var></td><td><var>R1</var></td><td><code>"ADDISON AV"</code></td><td><code>"ADDISON AV"</code></td></tr>
              <tr><td><var>C1.3</var></td><td><var>T</var></td><td><var>C3</var></td><td><var>R1</var></td><td><code>"Celtis australis"</code></td><td><code>"Celtis australis"</code></td></tr>
              <tr><td><var>C1.4</var></td><td><var>T</var></td><td><var>C4</var></td><td><var>R1</var></td><td><code>"Large Tree Routine Prune"</code></td><td><code>"Large Tree Routine Prune"</code></td></tr>
              <tr><td><var>C1.5</var></td><td><var>T</var></td><td><var>C5</var></td><td><var>R1</var></td><td><code>"10/18/2010"</code></td><td><code>"10/18/2010"</code></td></tr>
              <tr><td><var>C2.1</var></td><td><var>T</var></td><td><var>C1</var></td><td><var>R2</var></td><td><code>"2"</code></td><td><code>"2"</code></td></tr>
              <tr><td><var>C2.2</var></td><td><var>T</var></td><td><var>C2</var></td><td><var>R2</var></td><td><code>"EMERSON ST"</code></td><td><code>"EMERSON ST"</code></td></tr>
              <tr><td><var>C2.3</var></td><td><var>T</var></td><td><var>C3</var></td><td><var>R2</var></td><td><code>"Liquidambar styraciflua"</code></td><td><code>"Liquidambar styraciflua"</code></td></tr>
              <tr><td><var>C2.4</var></td><td><var>T</var></td><td><var>C4</var></td><td><var>R2</var></td><td><code>"Large Tree Routine Prune"</code></td><td><code>"Large Tree Routine Prune"</code></td></tr>
              <tr><td><var>C2.5</var></td><td><var>T</var></td><td><var>C5</var></td><td><var>R2</var></td><td><code>"6/2/2010"</code></td><td><code>"6/2/2010"</code></td></tr>
            </tbody>
          </table>
          <section>
          	<h5>Using Overriding Metadata</h5>
          	<p>
          		The tools that the consumer of this data uses may provide a mechanism for overriding the metadata that has been provided within the file itself. For example, they might enable the consumer to add machine-readable names to the columns, or to mark the fifth column as holding a date in the format <code>M/D/YYYY</code>. These facilities are implementation defined; the code for a Javascript-based parser might look like:
          	</p>
          	<pre class="highlight example" title="Javascript implementation configuration">
data.parse({
  "column-names": ["GID", "on_street", "species", "trim_cycle", "inventory_date"],
  "datatypes": ["string", "string", "string", "string", "date"],
  "formats": [null,null,null,null,"M/D/YYYY"]
});
          	</pre>
            <p>
              This is equivalent to a metadata file expressed in the syntax defined in [[!tabular-metadata]], looking like:
            </p>
            <pre class="example highlight" title="Equivalent metadata syntax">
{
  "@type": "Table",
  "url": "http://example.org/tree-ops.csv",
  "tableSchema": {
    "columns": [{
      "name": "GID",
      "datatype": "string"
    }, {
      "name": "on_street",
      "datatype": "string"
    }, {
      "name": "species",
      "datatype": "string"
    }, {
      "name": "trim_cycle",
      "datatype": "string"
    }, {
      "name": "inventory_date",
      "datatype": {
        "base": "date",
        "format": "M/d/yyyy"
      }
    }]
  }
}
            </pre>
            <p>
              This would be merged with the <a>embedded metadata</a> found in the CSV file, providing the titles for the columns to create:
            </p>
            <pre class="example highlight" title="Merged metadata">
{
  "@type": "Table",
  "url": "http://example.org/tree-ops.csv",
  "tableSchema": {
    "columns": [{
      "name": "GID", 
      "title": "GID", 
      "datatype": "string"
    }, {
      "name": "on_street", 
      "title": "On Street", 
      "datatype": "string"
    }, {
      "name": "species", 
      "title": "Species", 
      "datatype": "string"
    }, {
      "name": "trim_cycle", 
      "title": "Trim Cycle", 
      "datatype": "string"
    }, {
      "name": "inventory_date",
      "title": "Inventory Date",
      "datatype": {
        "base": "date", 
        "format": "M/d/yyyy"
      }
    }]
  }
}
            </pre>
          	<p>
          		The processor can then create an <a>annotated tabular data model</a> that included <code>name</code> annotations on the columns, <code>datatype</code> and <code>format</code> annotations on the cells, and created cells whose <a title="cell value">values</a> were of appropriate types (in the case of this Javascript implementation, the cells in the last column would be <code>Date</code> objects, for example).
          	</p>
						<p>
							Assuming this kind of implementation-defined parsing, the columns would then have the annotations shown in the following table:
	          </p>
	          <table style="width: 100%; text-align: left">
	            <thead>
	              <tr><th rowspan="2">id</th><th colspan="4">core annotations</th><th colspan="2">annotations</th></tr>
	              <tr><th>table</th><th>number</th><th>source number</th><th>cells</th><th><code>name</code></th><th><code>title</code></th></tr>
	            </thead>
	            <tbody>
	              <tr><td><var>C1</var></td><td><var>T</var></td><td>1</td><td>1</td><td><var>C1.1</var>, <var>C2.1</var></td><td><code>GID</code></td><td><code>GID</code></td></tr>
	              <tr><td><var>C2</var></td><td><var>T</var></td><td>2</td><td>2</td><td><var>C1.2</var>, <var>C2.2</var></td><td><code>on_street</code></td><td><code>On Street</code></td></tr>
	              <tr><td><var>C3</var></td><td><var>T</var></td><td>3</td><td>3</td><td><var>C1.3</var>, <var>C2.3</var></td><td><code>species</code></td><td><code>Species</code></td></tr>
	              <tr><td><var>C4</var></td><td><var>T</var></td><td>4</td><td>4</td><td><var>C1.4</var>, <var>C2.4</var></td><td><code>trim_cycle</code></td><td><code>Trim Cycle</code></td></tr>
	              <tr><td><var>C5</var></td><td><var>T</var></td><td>5</td><td>5</td><td><var>C1.5</var>, <var>C2.5</var></td><td><code>inventory_date</code></td><td><code>Inventory Date</code></td></tr>
	            </tbody>
	          </table>
	          <p>
	            The cells have the annotations shown in the following table. Because of the overrides provided by the consumer to guide the parsing, and the way the parser works, the cells in the <code>Inventory Date</code> column (cells <var>C1.5</var> and <var>C2.5</var>) have <a title="cell value">values</a> that are parsed dates rather than unparsed strings.
	          </p>
	          <table style="width: 100%; text-align: left">
	            <thead>
	              <tr><th rowspan="2">id</th><th colspan="5">core annotations</th></tr>
	              <tr><th>table</th><th>column</th><th>row</th><th>string value</th><th>value</th></tr>
	            </thead>
	            <tbody>
	              <tr><td><var>C1.1</var></td><td><var>T</var></td><td><var>C1</var></td><td><var>R1</var></td><td><code>"1"</code></td><td><code>"1"</code></td></tr>
	              <tr><td><var>C1.2</var></td><td><var>T</var></td><td><var>C2</var></td><td><var>R1</var></td><td><code>"ADDISON AV"</code></td><td><code>"ADDISON AV"</code></td></tr>
	              <tr><td><var>C1.3</var></td><td><var>T</var></td><td><var>C3</var></td><td><var>R1</var></td><td><code>"Celtis australis"</code></td><td><code>"Celtis australis"</code></td></tr>
	              <tr><td><var>C1.4</var></td><td><var>T</var></td><td><var>C4</var></td><td><var>R1</var></td><td><code>"Large Tree Routine Prune"</code></td><td><code>"Large Tree Routine Prune"</code></td></tr>
	              <tr><td><var>C1.5</var></td><td><var>T</var></td><td><var>C5</var></td><td><var>R1</var></td><td><code>"10/18/2010"</code></td><td><code>2010-10-18</code></td></tr>
	              <tr><td><var>C2.1</var></td><td><var>T</var></td><td><var>C1</var></td><td><var>R2</var></td><td><code>"2"</code></td><td><code>"2"</code></td></tr>
	              <tr><td><var>C2.2</var></td><td><var>T</var></td><td><var>C2</var></td><td><var>R2</var></td><td><code>"EMERSON ST"</code></td><td><code>"EMERSON ST"</code></td></tr>
	              <tr><td><var>C2.3</var></td><td><var>T</var></td><td><var>C3</var></td><td><var>R2</var></td><td><code>"Liquidambar styraciflua"</code></td><td><code>"Liquidambar styraciflua"</code></td></tr>
	              <tr><td><var>C2.4</var></td><td><var>T</var></td><td><var>C4</var></td><td><var>R2</var></td><td><code>"Large Tree Routine Prune"</code></td><td><code>"Large Tree Routine Prune"</code></td></tr>
	              <tr><td><var>C2.5</var></td><td><var>T</var></td><td><var>C5</var></td><td><var>R2</var></td><td><code>"6/2/2010"</code></td><td><code>2010-06-02</code></td></tr>
	            </tbody>
	          </table>
          </section>
          <section>
          	<h5>Using a Metadata File</h5>
          	<p>
          		A similar set of annotations could be provided through a metadata file, located as discussed in <a href="#locating-metadata" class="sectionRef"></a> and defined in [[!tabular-metadata]]. For example, this might look like:
          	</p>
      			<pre class="example highlight" title="Metadata file">
{
  "@context": ["http://www.w3.org/ns/csvw", {"@language": "en"}],
  "url": "tree-ops.csv",
  "dc:title": "Tree Operations",
  "dc:keywords": ["tree", "street", "maintenance"],
  "dc:publisher": [{
    "schema:name": "Example Municipality",
    "schema:url": "http://example.org"
  }],
  "dc:license": "http://opendefinition.org/licenses/cc-by/",
  "dc:modified": "2010-12-31",
  "tableSchema": {
    "columns": [{
      "name": "GID",
      "title": [
        "GID",
        "Generic Identifier"
      ],
      "dc:description": "An identifier for the operation on a tree.",
      "datatype": "string",
      "required": true
    }, {
      "name": "on_street",
      "title": "On Street",
      "dc:description": "The street that the tree is on.",
      "datatype": "string"
    }, {
      "name": "species",
      "title": "Species",
      "dc:description": "The species of the tree.",
      "datatype": "string"
    }, {
      "name": "trim_cycle",
      "title": "Trim Cycle",
      "dc:description": "The operation performed on the tree.",
      "datatype": "string"
    }, {
      "name": "inventory_date",
      "title": "Inventory Date",
      "dc:description": "The date of the operation that was performed.",
      "datatype": {"base": "date", "format": "M/d/yyyy"}
    }],
    "primaryKey": "GID"
  }
}
			      </pre>
          	<p>
          		The <a>annotated tabular data model</a> generated from this would be more sophisticated again. The <a>table</a> itself would have the following annotations:
          	</p>
          	<dl>
          		<dt><code>dc:title</code></dt>
          		<dd><code>"Tree Operations"</code></dd>
          		<dt><code>dc:keywords</code></dt>
          		<dd><code>["tree", "street", "maintenance"]</code></dd>
          		<dt><code>dc:publisher</code></dt>
          		<dd><code>[{ "schema:name": "Example Municipality", "schema:url": "http://example.org" }]</code></dd>
          		<dt><code>dc:license</code></dt>
          		<dd><code>"http://opendefinition.org/licenses/cc-by/"</code></dd>
          		<dt><code>dc:modified</code></dt>
          		<dd><code>"2010-12-31"</code></dd>
          	</dl>
						<p>
							The columns would have the annotations shown in the following table:
	          </p>
	          <table style="width: 100%; text-align: left">
	            <thead>
	              <tr><th rowspan="2">id</th><th colspan="6">core annotations</th><th colspan="1">other annotations</th></tr>
	              <tr><th>table</th><th>number</th><th>source number</th><th>cells</th><th>name</th><th>titles</th><th><code>dc:description</code></th></tr>
	            </thead>
	            <tbody>
	              <tr><td><var>C1</var></td><td><var>T</var></td><td>1</td><td>1</td><td><var>C1.1</var>, <var>C2.1</var></td><td><code>GID</code></td><td><code>GID</code>, <code>Generic Identifier</code></td><td><code>An identifier for the operation on a tree.</code></td></tr>
	              <tr><td><var>C2</var></td><td><var>T</var></td><td>2</td><td>2</td><td><var>C1.2</var>, <var>C2.2</var></td><td><code>on_street</code></td><td><code>On Street</code></td><td><code>The street that the tree is on.</code></td></tr>
	              <tr><td><var>C3</var></td><td><var>T</var></td><td>3</td><td>3</td><td><var>C1.3</var>, <var>C2.3</var></td><td><code>species</code></td><td><code>Species</code></td><td><code>The species of the tree.</code></td></tr>
	              <tr><td><var>C4</var></td><td><var>T</var></td><td>4</td><td>4</td><td><var>C1.4</var>, <var>C2.4</var></td><td><code>trim_cycle</code></td><td><code>Trim Cycle</code></td><td><code>The operation performed on the tree.</code></td></tr>
	              <tr><td><var>C5</var></td><td><var>T</var></td><td>5</td><td>5</td><td><var>C1.5</var>, <var>C2.5</var></td><td><code>inventory_date</code></td><td><code>Inventory Date</code></td><td><code>The date of the operation that was performed.</code></td></tr>
	            </tbody>
	          </table>
            <p>
              The rows have an additional <a title="row primary key">primary key</a> annotation, as shown in the following table:
            </p>
            <table style="width: 100%; text-align: left">
              <thead>
                <tr><th rowspan="2">id</th><th colspan="5">core annotations</th></tr>
                <tr><th>table</th><th>number</th><th>source number</th><th>cells</th><th>primary key</th></tr>
              </thead>
              <tbody>
                <tr><td><var>R1</var></td><td><var>T</var></td><td>1</td><td>2</td><td><var>C1.1</var>, <var>C1.2</var>, <var>C1.3</var>, <var>C1.4</var>, <var>C1.5</var></td><td>C1.1</td></tr>
                <tr><td><var>R2</var></td><td><var>T</var></td><td>2</td><td>3</td><td><var>C2.1</var>, <var>C2.2</var>, <var>C2.3</var>, <var>C2.4</var>, <var>C2.5</var></td><td>C2.1</td></tr>
              </tbody>
            </table>
	          <p>
	            Thanks to the provided metadata, the cells again have the annotations shown in the following table. The metadata file has provided the information to supplement the model with additional annotations but also, for the <code>Inventory Date</code> column (cells <var>C1.5</var> and <var>C2.5</var>), have a <a title="cell value">value</a> that is a parsed date rather than an unparsed string.
	          </p>
	          <table style="width: 100%; text-align: left">
	            <thead>
	              <tr><th rowspan="2">id</th><th colspan="5">core annotations</th></tr>
	              <tr><th>table</th><th>column</th><th>row</th><th>string value</th><th>value</th></tr>
	            </thead>
	            <tbody>
	              <tr><td><var>C1.1</var></td><td><var>T</var></td><td><var>C1</var></td><td><var>R1</var></td><td><code>"1"</code></td><td><code>"1"</code></td></tr>
	              <tr><td><var>C1.2</var></td><td><var>T</var></td><td><var>C2</var></td><td><var>R1</var></td><td><code>"ADDISON AV"</code></td><td><code>"ADDISON AV"</code></td></tr>
	              <tr><td><var>C1.3</var></td><td><var>T</var></td><td><var>C3</var></td><td><var>R1</var></td><td><code>"Celtis australis"</code></td><td><code>"Celtis australis"</code></td></tr>
	              <tr><td><var>C1.4</var></td><td><var>T</var></td><td><var>C4</var></td><td><var>R1</var></td><td><code>"Large Tree Routine Prune"</code></td><td><code>"Large Tree Routine Prune"</code></td></tr>
	              <tr><td><var>C1.5</var></td><td><var>T</var></td><td><var>C5</var></td><td><var>R1</var></td><td><code>"10/18/2010"</code></td><td><code>2010-10-18</code></td></tr>
	              <tr><td><var>C2.1</var></td><td><var>T</var></td><td><var>C1</var></td><td><var>R2</var></td><td><code>"2"</code></td><td><code>"2"</code></td></tr>
	              <tr><td><var>C2.2</var></td><td><var>T</var></td><td><var>C2</var></td><td><var>R2</var></td><td><code>"EMERSON ST"</code></td><td><code>"EMERSON ST"</code></td></tr>
	              <tr><td><var>C2.3</var></td><td><var>T</var></td><td><var>C3</var></td><td><var>R2</var></td><td><code>"Liquidambar styraciflua"</code></td><td><code>"Liquidambar styraciflua"</code></td></tr>
	              <tr><td><var>C2.4</var></td><td><var>T</var></td><td><var>C4</var></td><td><var>R2</var></td><td><code>"Large Tree Routine Prune"</code></td><td><code>"Large Tree Routine Prune"</code></td></tr>
	              <tr><td><var>C2.5</var></td><td><var>T</var></td><td><var>C5</var></td><td><var>R2</var></td><td><code>"6/2/2010"</code></td><td><code>2010-06-02</code></td></tr>
	            </tbody>
	          </table>
          </section>
        </section>
        <section>
          <h4>Empty and Quoted Cells</h4>
          <p>
            The following slightly amended CSV file contains quoted and missing cell values:
          </p>
          <pre class="example" title="CSV file containing quoted and missing cell values">
GID,On Street,Species,Trim Cycle,Inventory Date
1,ADDISON AV,"Celtis australis","Large Tree Routine Prune",10/18/2010
2,,"Liquidambar styraciflua","Large Tree Routine Prune",
          </pre>
          <p>
            Parsing this file similarly results in an <a>annotated tabular data model</a> of a single <a>table</a> <var>T</var> with five columns and two rows. The columns and rows have exactly the same annotations as previously, but there are two <code>null</code> cell values for <var>C2.2</var> and <var>C2.5</var>. Note that the quoting of values within the CSV makes no difference to either the <a>string value</a> or <a title="cell value">value</a> of the cell.
          </p>
          <table style="width: 100%; text-align: left">
            <thead>
              <tr><th rowspan="2">id</th><th colspan="5">core annotations</th></tr>
              <tr><th>table</th><th>column</th><th>row</th><th>string value</th><th>value</th></tr>
            </thead>
            <tbody>
              <tr><td><var>C1.1</var></td><td><var>T</var></td><td><var>C1</var></td><td><var>R1</var></td><td><code>"1"</code></td><td><code>"1"</code></td></tr>
              <tr><td><var>C1.2</var></td><td><var>T</var></td><td><var>C2</var></td><td><var>R1</var></td><td><code>"ADDISON AV"</code></td><td><code>"ADDISON AV"</code></td></tr>
              <tr><td><var>C1.3</var></td><td><var>T</var></td><td><var>C3</var></td><td><var>R1</var></td><td><code>"Celtis australis"</code></td><td><code>"Celtis australis"</code></td></tr>
              <tr><td><var>C1.4</var></td><td><var>T</var></td><td><var>C4</var></td><td><var>R1</var></td><td><code>"Large Tree Routine Prune"</code></td><td><code>"Large Tree Routine Prune"</code></td></tr>
              <tr><td><var>C1.5</var></td><td><var>T</var></td><td><var>C5</var></td><td><var>R1</var></td><td><code>"10/18/2010"</code></td><td><code>"10/18/2010"</code></td></tr>
              <tr><td><var>C2.1</var></td><td><var>T</var></td><td><var>C1</var></td><td><var>R2</var></td><td><code>"2"</code></td><td><code>"2"</code></td></tr>
              <tr><td><var>C2.2</var></td><td><var>T</var></td><td><var>C2</var></td><td><var>R2</var></td><td><code>""</code></td><td><code>null</code></td></tr>
              <tr><td><var>C2.3</var></td><td><var>T</var></td><td><var>C3</var></td><td><var>R2</var></td><td><code>"Liquidambar styraciflua"</code></td><td><code>"Liquidambar styraciflua"</code></td></tr>
              <tr><td><var>C2.4</var></td><td><var>T</var></td><td><var>C4</var></td><td><var>R2</var></td><td><code>"Large Tree Routine Prune"</code></td><td><code>"Large Tree Routine Prune"</code></td></tr>
              <tr><td><var>C2.5</var></td><td><var>T</var></td><td><var>C5</var></td><td><var>R2</var></td><td><code>""</code></td><td><code>null</code></td></tr>
            </tbody>
          </table>
        </section>
	      <section>
	        <h4>Tabular Data Embedding Annotations</h4>
	        <p>
	          The following example illustrates some of the complexities that can be involved in parsing tabular data, how the flags described above can be used, and how new tabular data formats could be defined that embed additional annotations into the tabular data model.
	        </p>
	        <p>
	          In this example, the publishers of the data are using an internal convention to supply additional metadata about the tabular data embedded within the file itself. They are also using a tab as a separator rather than a comma.
	        </p>
	        <pre class="example" title="Tab-separated file containing embedded metadata">
#	publisher	City of Palo Alto
#	updated	12/31/2010
#name	GID	on_street	species	trim_cycle	inventory_date
#datatype	string	string	string	string	date:M/D/YYYY
	GID	On Street	Species	Trim Cycle	Inventory Date
	1	ADDISON AV	Celtis australis	Large Tree Routine Prune	10/18/2010
	2	EMERSON ST	Liquidambar styraciflua	Large Tree Routine Prune	6/2/2010
	        </pre>
	        <section>
	          <h5>Naive Parsing</h5>
	          <p>
	            Naive parsing of the above data will assume a comma separator and thus results in a single <a>table</a> <var>T</var> with a single column and six rows. The column has the annotations shown in the following table:
	          </p>
	          <table style="width: 100%; text-align: left">
	            <thead>
	              <tr><th rowspan="2">id</th><th colspan="5">core annotations</th></tr>
	              <tr><th>table</th><th>number</th><th>source number</th><th>cells</th><th>titles</th></tr>
	            </thead>
	            <tbody>
	              <tr><td><var>C1</var></td><td><var>T</var></td><td>1</td><td>1</td><td><var>C1.1</var>, <var>C2.1</var>, <var>C3.1</var>, <var>C4.1</var>, <var>C5.1</var></td><td><code># publisher City of Palo Alto</code></td></tr>
	            </tbody>
	          </table>
	          <p>
	            The rows have the annotations shown in the following table:
	          </p>
	          <table style="width: 100%; text-align: left">
	            <thead>
	              <tr><th rowspan="2">id</th><th colspan="4">core annotations</th></tr>
	              <tr><th>table</th><th>number</th><th>source number</th><th>cells</th></tr>
	            </thead>
	            <tbody>
	              <tr><td><var>R1</var></td><td><var>T</var></td><td>1</td><td>2</td><td><var>C1.1</var></td></tr>
	              <tr><td><var>R2</var></td><td><var>T</var></td><td>2</td><td>3</td><td><var>C2.1</var></td></tr>
	              <tr><td><var>R3</var></td><td><var>T</var></td><td>3</td><td>4</td><td><var>C3.1</var></td></tr>
	              <tr><td><var>R4</var></td><td><var>T</var></td><td>4</td><td>5</td><td><var>C4.1</var></td></tr>
	              <tr><td><var>R5</var></td><td><var>T</var></td><td>5</td><td>6</td><td><var>C5.1</var></td></tr>
	              <tr><td><var>R6</var></td><td><var>T</var></td><td>6</td><td>7</td><td><var>C6.1</var></td></tr>
	            </tbody>
	          </table>
	          <p>
	            The cells have the annotations shown in the following table (note that the <a title="cell value">values</a> of all the cells in the table are strings, denoted by the double quotes in the table below):
	          </p>
	          <table style="width: 100%; text-align: left">
	            <thead>
	              <tr><th rowspan="2">id</th><th colspan="5">core annotations</th></tr>
	              <tr><th>table</th><th>column</th><th>row</th><th>string value</th><th>value</th></tr>
	            </thead>
	            <tbody>
	              <tr><td><var>C1.1</var></td><td><var>T</var></td><td><var>C1</var></td><td><var>R1</var></td><td><code>"# updated 12/31/2010"</code></td><td><code>"# updated 12/31/2010"</code></td></tr>
	              <tr><td><var>C1.1</var></td><td><var>T</var></td><td><var>C1</var></td><td><var>R1</var></td><td><code>"#name	GID	on_street	species	trim_cycle	inventory_date"</code></td><td><code>"#name	GID	on_street	species	trim_cycle	inventory_date"</code></td></tr>
	              <tr><td><var>C2.1</var></td><td><var>T</var></td><td><var>C1</var></td><td><var>R2</var></td><td><code>"#datatype	string	string	string	string	date:M/D/YYYY"</code></td><td><code>"#datatype	string	string	string	string	date:M/D/YYYY"</code></td></tr>
	              <tr><td><var>C3.1</var></td><td><var>T</var></td><td><var>C1</var></td><td><var>R3</var></td><td><code>"	GID	On Street	Species	Trim Cycle	Inventory Date"</code></td><td><code>"	GID	On Street	Species	Trim Cycle	Inventory Date"</code></td></tr>
	              <tr><td><var>C4.1</var></td><td><var>T</var></td><td><var>C1</var></td><td><var>R4</var></td><td><code>"	1 ADDISON AV	Celtis australis	Large Tree Routine Prune	10/18/2010"</code></td><td><code>"	1 ADDISON AV	Celtis australis	Large Tree Routine Prune	10/18/2010"</code></td></tr>
	              <tr><td><var>C5.1</var></td><td><var>T</var></td><td><var>C1</var></td><td><var>R5</var></td><td><code>"	2 EMERSON ST	Liquidambar styraciflua Large Tree Routine Prune	6/2/2010"</code></td><td><code>"	2 EMERSON ST	Liquidambar styraciflua Large Tree Routine Prune	6/2/2010"</code></td></tr>
	            </tbody>
	          </table>
	        </section>
	        <section>
	          <h5>Parsing with Flags</h5>
	          <p>
	            The consumer of the data may use the flags described above to create a more useful set of data from this file. Specifically, they could set:
	          </p>
	          <ul>
	            <li><a>delimiter</a> to a tab character</li>
	            <li><a>skip rows</a> to 4</li>
	            <li><a>skip columns</a> to 1</li>
	          </ul>
	          <p>
	            Setting these is done in an implementation-defined way. It could be done, for example, by sniffing the contents of the file itself, through command-line options, or by embedding a dialect description into a metadata file associated with the tabular data, which would look like:
	          </p>
	          <pre class="example highlight" title="Dialect description">
{
  "delimiter": "\t",
  "skipRows": 4,
  "skipColumns": 1
}
	          </pre>
	          <p>
	            With these flags in operation, parsing this file results in an <a>annotated tabular data model</a> of a single <a>table</a> <var>T</var> with five columns and two rows which is largely the same as that created from the original simple example described in <a href="#simple-example" class="sectionRef"></a>. There are three differences.
            </p>
            <p>
              First, because the four skipped rows began with the default <a>comment prefix</a>, the table itself now has four <code>rdfs:comment</code> annotations, with the values:
	          </p>
	          <ol>
	            <li><code> publisher	City of Palo Alto</code></li>
	            <li><code> updated	12/31/2010</code></li>
	            <li><code>name	GID	on_street	species	trim_cycle	inventory_date</code></li>
	            <li><code>datatype	string	string	string	string	date:M/D/YYYY</code></li>
	          </ol>
            <p>
              Second, because the first column has been skipped, the <a title="column source number">source number</a> of each of the columns is offset by one from the <a title="column number">number</a> of each column:
            </p>
            <table style="width: 100%; text-align: left">
              <thead>
                <tr><th rowspan="2">id</th><th colspan="5">core annotations</th></tr>
                <tr><th>table</th><th>number</th><th>source number</th><th>cells</th><th>titles</th></tr>
              </thead>
              <tbody>
                <tr><td><var>C1</var></td><td><var>T</var></td><td>1</td><td>2</td><td><var>C1.1</var>, <var>C2.1</var></td><td><code>GID</code></td></tr>
                <tr><td><var>C2</var></td><td><var>T</var></td><td>2</td><td>3</td><td><var>C1.2</var>, <var>C2.2</var></td><td><code>On Street</code></td></tr>
                <tr><td><var>C3</var></td><td><var>T</var></td><td>3</td><td>4</td><td><var>C1.3</var>, <var>C2.3</var></td><td><code>Species</code></td></tr>
                <tr><td><var>C4</var></td><td><var>T</var></td><td>4</td><td>5</td><td><var>C1.4</var>, <var>C2.4</var></td><td><code>Trim Cycle</code></td></tr>
                <tr><td><var>C5</var></td><td><var>T</var></td><td>5</td><td>6</td><td><var>C1.5</var>, <var>C2.5</var></td><td><code>Inventory Date</code></td></tr>
              </tbody>
            </table>
            <p>
              Finally, because four additional rows have been skipped, the <a title="row source number">source number</a> of each of the rows is offset by five from the <a>row number</a> (the four skipped rows plus the single header row):
            </p>
            <table style="width: 100%; text-align: left">
              <thead>
                <tr><th rowspan="2">id</th><th colspan="4">core annotations</th></tr>
                <tr><th>table</th><th>number</th><th>source number</th><th>cells</th></tr>
              </thead>
              <tbody>
                <tr><td><var>R1</var></td><td><var>T</var></td><td>1</td><td>6</td><td><var>C1.1</var>, <var>C1.2</var>, <var>C1.3</var>, <var>C1.4</var>, <var>C1.5</var></td></tr>
                <tr><td><var>R2</var></td><td><var>T</var></td><td>2</td><td>7</td><td><var>C2.1</var>, <var>C2.2</var>, <var>C2.3</var>, <var>C2.4</var>, <var>C2.5</var></td></tr>
              </tbody>
            </table>
	        </section>
	        <section>
	        	<h5>Recognising Tabular Data Formats</h5>
	        	<p>
	        		The conventions used in this data (invented for the purpose of this example) are in fact intended to create an <a>annotated tabular data model</a> which includes named annotations on the table itself, on the columns and on the cells. The creator of these conventions could create a specification for this particular tabular data syntax and register a media type for it. The specification would include statements like:
	        	</p>
	        	<ul>
	        		<li>A tab delimiter is always used.</li>
	        		<li>The first column is always ignored.</li>
	        		<li>When the first column of a row has the value <code>"#"</code>, the second column is the name of an annotation on the table and the values of the remaining columns are concatenated to create the value of that annotation.</li>
	        		<li>When the first column of a row has the value <code>#name</code>, the remaining cells in the row provide a <code>name</code> annotation for each column in the table.</li>
	        		<li>When the first column of a row has the value <code>#datatype</code>, the remaining cells in the row provide <code>datatype</code> and <code>format</code> annotations for the cells within the relevant column, and these are interpreted to create the <a title="cell value">value</a> for each cell in that column.</li>
	        		<li>The first row where the first column is empty is a row of headers; these provide <code>title</code> annotations on the columns in the table.</li>
	        		<li>The remaining rows make up the data of the table.</li>
	        	</ul>
	        	<p>
							Parsers that recognised the format could then build a more sophisticated annotated tabular data model using only the embedded information in the tabular data file. They would extract metadata looking like:
            </p>
{
  "@context": "http://www.w3.org/ns/csvw",
  "url": "tree-ops.csv",
  "dc:publisher": "City of Palo Alto",
  "dc:updated": "12/31/2010",
  "tableSchema": {
    "columns": [{
      "name": "GID",
      "title": "GID",
      "datatype": "string",
    }, {
      "name": "on_street",
      "title": "On Street",
      "datatype": "string"
    }, {
      "name": "species",
      "title": "Species",
      "datatype": "string"
    }, {
      "name": "trim_cycle",
      "title": "Trim Cycle",
      "datatype": "string"
    }, {
      "name": "inventory_date",
      "title": "Inventory Date",
      "datatype": {
        "base": "date", 
        "format": "M/d/yyyy"
      }
    }]
  }
}
            </pre>
            <p>
              As before, the result would be a single <a>table</a> <var>T</var> with five columns and two rows. The table itself would have two annotations:
						</p>
						<dl>
							<dt><code>dc:publisher</code></dt>
							<dd><code>City of Palo Alto</code></dd>
							<dt><code>dc:updated</code></dt>
							<dd><code>12/31/2010</code></dd>
						</dl>
						<p>
							The columns have the annotations shown in the following table:
	          </p>
	          <table style="width: 100%; text-align: left">
	            <thead>
	              <tr><th rowspan="2">id</th><th colspan="6">core annotations</th></tr>
	              <tr><th>table</th><th>number</th><th>source number</th><th>cells</th><th>name</th><th>titles</th></tr>
	            </thead>
	            <tbody>
	              <tr><td><var>C1</var></td><td><var>T</var></td><td>1</td><td>2</td><td><var>C1.1</var>, <var>C2.1</var></td><td><code>GID</code></td><td><code>GID</code></td></tr>
	              <tr><td><var>C2</var></td><td><var>T</var></td><td>2</td><td>3</td><td><var>C1.2</var>, <var>C2.2</var></td><td><code>on_street</code></td><td><code>On Street</code></td></tr>
	              <tr><td><var>C3</var></td><td><var>T</var></td><td>3</td><td>4</td><td><var>C1.3</var>, <var>C2.3</var></td><td><code>species</code></td><td><code>Species</code></td></tr>
	              <tr><td><var>C4</var></td><td><var>T</var></td><td>4</td><td>5</td><td><var>C1.4</var>, <var>C2.4</var></td><td><code>trim_cycle</code></td><td><code>Trim Cycle</code></td></tr>
	              <tr><td><var>C5</var></td><td><var>T</var></td><td>5</td><td>6</td><td><var>C1.5</var>, <var>C2.5</var></td><td><code>inventory_date</code></td><td><code>Inventory Date</code></td></tr>
	            </tbody>
	          </table>
	          <p>
	            The rows have the annotations shown in the following table, exactly as in previous examples:
	          </p>
	          <table style="width: 100%; text-align: left">
	            <thead>
	              <tr><th rowspan="2">id</th><th colspan="4">core annotations</th></tr>
	              <tr><th>table</th><th>number</th><th>source number</th><th>cells</th></tr>
	            </thead>
	            <tbody>
	              <tr><td><var>R1</var></td><td><var>T</var></td><td>1</td><td>6</td><td><var>C1.1</var>, <var>C1.2</var>, <var>C1.3</var>, <var>C1.4</var>, <var>C1.5</var></td></tr>
	              <tr><td><var>R2</var></td><td><var>T</var></td><td>2</td><td>7</td><td><var>C2.1</var>, <var>C2.2</var>, <var>C2.3</var>, <var>C2.4</var>, <var>C2.5</var></td></tr>
	            </tbody>
	          </table>
	          <p>
	            The cells have the annotations shown in the following table. Because of the way the particular tabular data format has been specified, these include additional annotations but also, for the <code>Inventory Date</code> column (cells <var>C1.5</var> and <var>C2.5</var>), have a <a title="cell value">value</a> that is a parsed date rather than an unparsed string.
	          </p>
	          <table style="width: 100%; text-align: left">
	            <thead>
	              <tr><th rowspan="2">id</th><th colspan="5">core annotations</th></tr>
	              <tr><th>table</th><th>column</th><th>row</th><th>string value</th><th>value</th></tr>
	            </thead>
	            <tbody>
	              <tr><td><var>C1.1</var></td><td><var>T</var></td><td><var>C1</var></td><td><var>R1</var></td><td><code>"1"</code></td><td><code>"1"</code></td></tr>
	              <tr><td><var>C1.2</var></td><td><var>T</var></td><td><var>C2</var></td><td><var>R1</var></td><td><code>"ADDISON AV"</code></td><td><code>"ADDISON AV"</code></td></tr>
	              <tr><td><var>C1.3</var></td><td><var>T</var></td><td><var>C3</var></td><td><var>R1</var></td><td><code>"Celtis australis"</code></td><td><code>"Celtis australis"</code></td></tr>
	              <tr><td><var>C1.4</var></td><td><var>T</var></td><td><var>C4</var></td><td><var>R1</var></td><td><code>"Large Tree Routine Prune"</code></td><td><code>"Large Tree Routine Prune"</code></td></tr>
	              <tr><td><var>C1.5</var></td><td><var>T</var></td><td><var>C5</var></td><td><var>R1</var></td><td><code>"10/18/2010"</code></td><td><code>2010-10-18</code></td></tr>
	              <tr><td><var>C2.1</var></td><td><var>T</var></td><td><var>C1</var></td><td><var>R2</var></td><td><code>"2"</code></td><td><code>"2"</code></td></tr>
	              <tr><td><var>C2.2</var></td><td><var>T</var></td><td><var>C2</var></td><td><var>R2</var></td><td><code>"EMERSON ST"</code></td><td><code>"EMERSON ST"</code></td></tr>
	              <tr><td><var>C2.3</var></td><td><var>T</var></td><td><var>C3</var></td><td><var>R2</var></td><td><code>"Liquidambar styraciflua"</code></td><td><code>"Liquidambar styraciflua"</code></td></tr>
	              <tr><td><var>C2.4</var></td><td><var>T</var></td><td><var>C4</var></td><td><var>R2</var></td><td><code>"Large Tree Routine Prune"</code></td><td><code>"Large Tree Routine Prune"</code></td></tr>
	              <tr><td><var>C2.5</var></td><td><var>T</var></td><td><var>C5</var></td><td><var>R2</var></td><td><code>"6/2/2010"</code></td><td><code>2010-06-02</code></td></tr>
	            </tbody>
	          </table>
	        </section>
	      </section>
        <section>
          <h4>Parsing Multiple Header Lines</h4>
          <p>
            The following example shows a CSV file with multiple header lines:
          </p>
          <pre class="example highlight" title="CSV file with multiple header lines">
Who,What,,Where,
Organisation,Sector,Subsector,Department,Municipality
#org,#sector,#subsector,#adm1,#adm2
UNICEF,Education,Teacher training,Chocó,Quidbó
UNICEF,Education,Teacher training,Chocó,Bojayá
          </pre>
          <p>
            Here, the first line contains some grouping titles, which are not particularly helpful. The lines following those contain useful titles for the columns. Thus the appropriate configuration for a dialect description is:
          </p>
          <pre class="example highlight" title="Dialect description for multiple header lines">
{
  "skipRows": 1,
  "headerRowCount": 2
}
          </pre>
          <p>
            With this configuration, the table model contains five columns, each of which have two titles, summarised in the following table:
          </p>
          <table style="width: 100%; text-align: left">
            <thead>
              <tr><th rowspan="2">id</th><th colspan="5">core annotations</th></tr>
              <tr><th>table</th><th>number</th><th>source number</th><th>cells</th><th>titles</th></tr>
            </thead>
            <tbody>
              <tr><td><var>C1</var></td><td><var>T</var></td><td>1</td><td>1</td><td><var>C1.1</var>, <var>C2.1</var></td><td><code>Organisation</code>, <code>#org</code></td></tr>
              <tr><td><var>C2</var></td><td><var>T</var></td><td>2</td><td>2</td><td><var>C1.2</var>, <var>C2.2</var></td><td><code>Sector</code>, <code>#sector</code></td></tr>
              <tr><td><var>C3</var></td><td><var>T</var></td><td>3</td><td>3</td><td><var>C1.3</var>, <var>C2.3</var></td><td><code>Subsector</code>, <code>#subsector</code></td></tr>
              <tr><td><var>C4</var></td><td><var>T</var></td><td>4</td><td>4</td><td><var>C1.4</var>, <var>C2.4</var></td><td><code>Department</code>, <code>#adm1</code></td></tr>
              <tr><td><var>C5</var></td><td><var>T</var></td><td>5</td><td>5</td><td><var>C1.5</var>, <var>C2.5</var></td><td><code>Municipality</code>, <code>#adm2</code></td></tr>
            </tbody>
          </table>
          <p>
            As metadata, this would look like:
          </p>
          <pre class="example highlight" title="Extracted metadata">
{
  "tableSchema": {
    "columns": [
      { "title": ["Organisation", "#org"] }, 
      { "title": ["Sector", "#sector"] }, 
      { "title": ["Subsector", "#subsector"] }, 
      { "title": ["Department", "#adm1"] }, 
      { "title": ["Municipality", "#adm2"] }, 
    ]
  }
}
          </pre>
          <p>
            A separate metadata file could contain just the second of each of these titles, for example:
          </p>
          <pre class="example highlight" title="Metadata file">
{
  "tableSchema": {
    "columns": [
      { "name": "org", "title": #org" }, 
      { "name": "sector", "title": #sector" }, 
      { "name": "subsector", "title": #subsector" }, 
      { "name": "adm1", "title": #adm1" }, 
      { "name": "adm2", "title": #adm2" }, 
    ]
  }
}
          </pre>
          <p>
            This enables people from multiple jurisdictions to use the same tabular data structures without having to use exactly the same titles within their documents.
          </p>
        </section>
      </section>
    </section>
    <section class="appendix" id="standards">
      <h2>Existing Standards</h2>
      <p>
        This appendix outlines various ways in which CSV is defined.
      </p>
      <section id="rfc">
        <h3>RFC 4180</h3>
        <p>
          [[!RFC4180]] defines CSV with the following ABNF grammar:
        </p>
        <pre>
file = [header CRLF] record *(CRLF record) [CRLF]
header = name *(COMMA name)
record = field *(COMMA field)
name = field
field = (escaped / non-escaped)
escaped = DQUOTE *(TEXTDATA / COMMA / CR / LF / 2DQUOTE) DQUOTE
non-escaped = *TEXTDATA
COMMA = %x2C
CR = %x0D
DQUOTE =  %x22
LF = %x0A
CRLF = CR LF
TEXTDATA =  %x20-21 / %x23-2B / %x2D-7E
        </pre>
        <p>
          Of particular note here are:
        </p>
        <ul>
          <li>The production for <code>TEXTDATA</code> indicates that only non-control ASCII characters are permitted within a CSV file. This restriction is routinely ignored in practice, and is impractical on the international web.</li>
          <li>Lines should be ended with <code>CRLF</code>. This makes it harder to produce CSV files on Unix-based systems where the usual line ending is <code>LF</code>.</li>
          <li>The header line is optional; a <code>header</code> parameter on the media type indicates whether the header is present or not.</li>
          <li>Fields may be escaped by wrapping them in double quotes; any double quotes within the field must be escaped with two double quotes (<code>""</code>).</li>
        </ul>
      </section>
      <section id="excel">
        <h3>Excel</h3>
        <p>
          Excel is a common tool for both creating and reading CSV documents, and therefore the CSV that it produces is a de facto standard.
        </p>
        <p class="note">
          The following describes the behaviour of Microsoft Excel for Mac 2011 with an English locale. Further testing is needed to see the behaviour of Excel in other situations.
        </p>
        <section>
          <h4>Saved CSV</h4>
          <p>
            Excel generates CSV files encoded using Windows-1252 with <code>LF</code> line endings. Characters that cannot be represented within Windows-1252 are replaced by underscores. Only those cells that need escaping (eg because they contain commas or double quotes) are escaped, and double quotes are escaped with two double quotes.
          </p>
          <p>
            Dates and numbers are formatted as displayed, which means that formatting can lead to information being lost or becoming inconsistent.
          </p>
        </section>
        <section>
          <h4>Opened CSV</h4>
          <p>
            When opening CSV files, Excel interprets CSV files saved in UTF-8 as being encoded as Windows-1252 (whether or not a <a href="http://en.wikipedia.org/wiki/Byte_order_mark"><abbr title="Byte Order Mark">BOM</abbr></a> is present). It correctly deals with double quoted cells, except that it converts line breaks within cells into spaces. It understands <code>CRLF</code> as a line break. It detects dates (formatted as <code>YYYY-MM-DD</code>) and formats them in the default date formatting for files.
          </p>
        </section>
        <section>
          <h4>Imported CSV</h4>
          <p>
            Excel provides more control when importing CSV files into Excel. However, it does not properly understand UTF-8 (with or without BOM). It does however properly understand UTF-16 and can read non-ASCII characters from a UTF-16-encoded file.
          </p>
          <p>
            A particular quirk in the importing of CSV is that if a cell contains a line break, the final double quote that escapes the cell will be included within it.
          </p>
        </section>
        <section>
          <h4>Copied Tabular Data</h4>
          <p>
            When tabular data is copied from Excel, it is copied in a tab-delimited format, with <code>LF</code> line breaks.
          </p>
        </section>
      </section>
      <section id="google">
        <h3>Google Spreadsheets</h3>
        <section>
          <h4>Downloading CSV</h4>
          <p>
            Downloaded CSV files are encoded in UTF-8, without a <a href="http://en.wikipedia.org/wiki/Byte_order_mark"><abbr title="Byte Order Mark">BOM</abbr></a>, and with <code>LF</code> line endings. Dates and numbers are formatted as they appear within the spreadsheet.
          </p>
        </section>
        <section>
          <h4>Importing CSV</h4>
          <p>
            CSV files can be imported as UTF-8 (with or without BOM). <code>CRLF</code> line endings are correctly recognised. Dates are reformatted to the default date format on load.
          </p>
        </section>
      </section>
      <section>
        <h3>CSV Files in a Tabular Data Package</h3>
        <p>
          <a href="http://dataprotocols.org/tabular-data-package/#csv-files">Tabular Data Packages</a> place the following restrictions on CSV files:
        </p>
        <blockquote>
          <p>As a starting point, CSV files included in a Tabular Data Package package must conform to the RFC for CSV (4180 - Common Format and MIME Type for Comma-Separated Values (CSV) Files). In addition:</p>

          <ul>
            <li>File names MUST end with <code>.csv</code></li>
            <li>Files MUST be encoded as UTF-8</li>
            <li>
              <p>Files MUST have a single header row. This row MUST be the first row in the
          file.</p>

              <ul>
                <li>Terminology: each column in the CSV file is termed a <em>field</em> and
          its <code>name</code> is the string in that column in the header row.</li>
                <li>The <code>name</code> MUST be unique amongst fields and MUST contain at
          least one character</li>
                <li>There are no further restrictions on the form of the <code>name</code> but
          it is RECOMMENDED that it contain only alphanumeric characters
          together with “ .-_”</li>
              </ul>
            </li>
            <li>Rows in the file MUST NOT contain more fields than are in the header row (though they may
          contain less)</li>
            <li>Each file MUST have an entry in the <code>resources</code> array in the <code>datapackage.json</code> file</li>
            <li>The resource metadata MUST include a <code>tableSchema</code> attribute whose value MUST conform to the JSON
          Table Schema</li>
            <li>All fields in the CSV files MUST be described in the <code>tableSchema</code></li>
          </ul>

          <p>CSV files generated by different applications often vary in their syntax, e.g. use of quoting characters, delimiters, etc. To encourage conformance, CSV files in a CSV files in a Tabular Data Package SHOULD</p>

          <ul>
            <li>Use “,” as field delimiters</li>
            <li>Use <code>CRLF</code> (<code>U+000D U+000A</code>) or <code>LF</code> (<code>U+000A</code>) as line terminators</li>
          </ul>

          <p>If a CSV file does not follow these rules then its specific CSV dialect MUST be documented. The resource 
          hash for the resource in the <code>datapackage.json</code> descriptor MUST:</p>

          <ul>
            <li>Include a <code>dialect</code> key that conforms to that described in the <a href="http://dataprotocols.org/csv-dialect/">CSV Dialect Description Format</a></li>
          </ul>

          <p>Applications processing the CSV file SHOULD read use the <code>dialect</code> of the CSV file to guide parsing.</p>
        </blockquote>
      </section>
      <div class="issue">
        <p>
          More details of behaviour of other tools should go here. This should include the most popular CSV parsing/generating libraries in common programming languages. Test files which include non-ASCII characters, double quotes and line breaks within cells are:
        </p>
        <ul>
          <li><a href="test-utf8.csv">test-utf8.csv</a></li>
          <li><a href="test-utf8-bom.csv">test-utf8-bom.csv</a></li>
          <li><a href="test-utf16.csv">test-utf16.csv</a></li>
          <li><a href="test-utf16-bom.csv">test-utf16-bom.csv</a></li>
          <li><a href="test.xlsx">test.xslx</a></li>
          <li><a href="test.xls">test.xsl</a></li>
        </ul>
      </div>
    </section>
  </body>
</html>

