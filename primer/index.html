<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta content="width=device-width,initial-scale=1" name="viewport" />
    <title>CSV on the Web: A Primer</title>
    <script class="remove" src="../local-biblio.js"></script>
    <script class="remove" src="https://www.w3.org/Tools/respec/respec-w3c"></script>
    <script class="remove" src="../replace-ed-uris.js"></script>
    <script class="remove">
      var respecConfig = {
          specStatus: "CG-DRAFT",
          shortName: "tabular-data-primer",
          //publishDate:  "2014-03-27",
          previousPublishDate: "2016-02-25",
          previousMaturity: "WG-NOTE",
          previousURI: "https://www.w3.org/TR/2016/NOTE-tabular-data-primer-20160225/",
          edDraftURI: "https://w3c.github.io/csvw/primer/",
          //testSuiteURI: "https://www.w3.org/2013/csvw/tests/",
          //implementationReportURI: "https://www.w3.org/2013/csvw/tests/reports/index.html",
          // lcEnd: "3000-01-01",
          //crEnd: "2015-10-30",
          editors: [{
            name: "Jeni Tennison",
            company: "Open Data Institute",
            companyURL: "https://theodi.org/",
            w3cid: "33715"
          }],
          wg: "CSV on the Web Working Group",
          wgURI: "https://www.w3.org/2013/csvw/",
          wgPublicList: "public-csv-wg",
          wgPatentURI: "https://www.w3.org/2004/01/pp-impl/68238/status",
          otherLinks: [{
            key: "Repository",
            data: [{
                value: "We are on Github",
                href: "https://github.com/w3c/csvw"
            }, {
                value: "File a bug",
                href: "https://github.com/w3c/csvw"
            }]
          }],
          alternateFormats: [
            {
              uri: "tabular-data-primer.epub",
              label: "ePub"
            }
          ],
          localBiblio: {
              "csvw-html": {
                    "authors": [
                      "Gregg Kellogg"
                    ],
                    "title": "Embedding Tabular Metadata in HTML",
                    "href" : "https://www.w3.org/TR/csvw-html/",
                    "rawDate": "2016-02-25",
                    "status" : "NOTE",
                    "publisher": "W3C"
              },
          },
          inlineCSS: true,
          issueBase: "https://github.com/w3c/csvw/issues/",
          noIDLIn: true,
          noLegacyStyle: false,
          group: "csvw"
          };
    </script>
    <script class="remove">
    function escapeContent(doc, content) {
          var utils = require("core/utils");
    // perform transformations to make it render and prettier
      return utils.xmlEscape(content);
    }
    </script>
    <style>
      td, th { padding-left: 1em; padding-right: 1em; }
      tbody tr th { text-align: left; }
    </style>
  </head>
  <body>
    <section id="abstract">
      <p>
        CSV is one of the most popular formats for publishing data on the web. It is concise, easy to understand by both humans and computers, and aligns nicely to the tabular nature of most data.
      </p>
      <p>
        But CSV is also a poor format for data. There is no mechanism within CSV to indicate the type of data in a particular column, or whether values in a particular column must be unique. It is therefore hard to validate and prone to errors such as missing values or differing data types within a column.
      </p>
      <p>
        The <a href="https://www.w3.org/2013/csvw">CSV on the Web Working Group</a> has developed standard ways to express useful metadata about CSV files and other kinds of tabular data. This primer takes you through the ways in which these standards work together, covering:
      </p>
      <ul>
        <li>What we mean by "tabular data" and "CSV"</li>
        <li>Where files that provide metadata about CSV live</li>
        <li>How to create a schema to validate the content of a CSV file</li>
        <li>How to specify how a CSV file should be converted to RDF or JSON</li>
        <li>How to provide other documentation and metadata about a CSV file</li>
      </ul>
      <p>
        Where possible, this primer links back to the normative definitions of terms and properties in the standards. Nothing in this primer overrides those normative definitions.
      </p>
    </section>
    <section id="sotd">
      <p>
        The <a href="https://www.w3.org/2013/csvw">CSV on the Web Working Group</a> was <a href="https://www.w3.org/2013/05/lcsv-charter.html">chartered</a> to produce a recommendation "Access methods for CSV Metadata" as well as recommendations for "Metadata vocabulary for CSV data" and "Mapping mechanism to transforming CSV into various formats (e.g. RDF, JSON, or XML)". This non-normative document is a primer that describes how these standards work together for new readers. The normative standards are:
      </p>
      <ul>
        <li><a href="https://w3c.github.io/csvw/syntax/">Model for Tabular Data and Metadata on the Web</a></li>
        <li><a href="https://w3c.github.io/csvw/metadata/">Metadata Vocabulary for Tabular Data</a></li>
        <li><a href="https://w3c.github.io/csvw/csv2json/">Generating JSON from Tabular Data on the Web</a></li>
        <li><a href="https://w3c.github.io/csvw/csv2rdf/">Generating RDF from Tabular Data on the Web</a></li>
      </ul>
    </section>
    <section>
      <h1>Introduction</h1>
      <p>
        We'll begin with some basic concepts.
      </p>
      <section id="tabular-data">
        <h2>What is tabular data and CSV?</h2>
        <p>
          Tabular data is any data that can be arranged in a table, like the one here:
        </p>
        <table>
          <tr><th></th><th>column 1</th><th>column 2</th><th>column 3</th></tr>
          <tr><th>row 1</th><td>cell in column 1 and row 1</td><td>cell in column 2 and row 1</td><td>cell in column 3 and row 1</td></tr>
          <tr><th>row 2</th><td>cell in column 1 and row 2</td><td>cell in column 2 and row 2</td><td>cell in column 3 and row 2</td></tr>
          <tr><th>row 3</th><td>cell in column 1 and row 3</td><td>cell in column 2 and row 3</td><td>cell in column 3 and row 3</td></tr>
        </table>
        <p>
          There are lots of syntaxes for expressing tabular data on the web. You can put it in HTML tables, pass it around as Excel spreadsheets, or store it in an SQL database.
        </p>
        <p>
          One easy way to pass around tabular data is as CSV: as comma-separated values. A CSV file writes each row on a separate line and each cell is separated from the next with a comma. The values of cells can be written with double quotes around them; this is necessary when a cell value contains a line break or a comma. So the tabular data above can be expressed in CSV as:
        </p>
        <pre class="example">
cell in column 1 and row 1,cell in column 2 and row 1,cell in column 3 and row 1
cell in column 1 and row 2,cell in column 2 and row 2,cell in column 3 and row 2
cell in column 1 and row 3,cell in column 2 and row 3,cell in column 3 and row 3
</pre>
        <p>
          or, with double quotes around cell values:
        </p>
        <pre class="example">
"cell in column 1 and row 1","cell in column 2 and row 1","cell in column 3 and row 1"
"cell in column 1 and row 2","cell in column 2 and row 2","cell in column 3 and row 2"
"cell in column 1 and row 3","cell in column 2 and row 3","cell in column 3 and row 3"
</pre>
        <p>
          CSV files usually have an additional row at the top called a header row, which gives human-readable names or titles for each of the columns. Here is a sample CSV file that contains a header row:
        </p>
        <pre class="example">
<strong>"country","country group","name (en)","name (fr)","name (de)","latitude","longitude"</strong>
"at","eu","Austria","Autriche","Österreich","47.6965545","13.34598005"
"be","eu","Belgium","Belgique","Belgien","50.501045","4.47667405"
"bg","eu","Bulgaria","Bulgarie","Bulgarien","42.72567375","25.4823218"
</pre>
        <p>
          Column titles are a type of annotation on a column, not part of the data itself. For example, they aren't included when you're counting the rows of data in a table:
        </p>
        <table class="overlarge">
          <tr><th></th><th>column 1</th><th>column 2</th><th>column 3</th><th>column 4</th><th>column 5</th><th>column 6</th><th>column 7</th></tr>
          <tr><th>titles</th><th>country</th><th>country group</th><th>name (en)</th><th>name (fr)</th><th>name (de)</th><th>latitude</th><th>longitude</th></tr>
          <tr><th>row 1</th><td>AT</td><td>eu</td><td>Austria</td><td>Autriche</td><td>Österreich</td><td>47.6965545</td><td>13.34598005</td>
          <tr><th>row 2</th><td>BE</td><td>eu</td><td>Belgium</td><td>Belgique</td><td>Belgien</td><td>50.501045</td><td>4.47667405</td>
          <tr><th>row 3</th><td>BG</td><td>eu</td><td>Bulgaria</td><td>Bulgarie</td><td>Bulgarien</td><td>42.72567375</td><td>25.4823218</td>
        </table>
        <p>See also:</p>
        <ul>
          <li><a href="#dialects" class="sectionRef"></a></li>
          <li><a href="#tables-from-html" class="sectionRef"></a></li>
          <li><a href="https://w3c.github.io/csvw/syntax/#model">Tabular Data Models</a> in [[tabular-data-model]]</li>
        </ul>
      </section>
      <section id="metadata">
        <h2>How can you provide extra information about CSV data?</h2>
        <p>
          You can provide extra information, known as metadata, about CSV files using a JSON metadata file. If you're just providing metadata about one file, the easiest thing to do is to name the metadata file by adding <code>-metadata.json</code> to the end of the name of the CSV file. For example, if your CSV file is called <code>countries.csv</code> then call the metadata file <code>countries.csv-metadata.json</code>.
        </p>
        <p>
          The simplest metadata file you can create contains a single table description and looks like:
        </p>
        <pre class="example">
{
  "@context": "https://www.w3.org/ns/csvw",
  "url": "countries.csv"
}
        </pre>
        <p>
          Metadata files must always include the <a href="https://w3c.github.io/csvw/metadata/#top-level-properties"><code>@context</code></a> property with a value <code>"https://www.w3.org/ns/csvw"</code>: this enables implementations to tell that these are CSV metadata files. The <a href="https://w3c.github.io/csvw/metadata/#table-url"><code>url</code></a> property points to the CSV file that the metadata file describes.
        </p>
        <p class="note">
          These metadata documents should be served from a web server with a media type of <code>application/csvm+json</code> if possible.
        </p>
        <p>
          The description of a table within a metadata file can include:
        </p>
        <ul>
          <li>documentation about the CSV file, such as a description, authorship or licensing information, which can provide context for people using the CSV file</li>
          <li>a definition of the structure of the CSV file, which can be used to validate the data that it holds</li>
          <li>instructions that enable processors to transform the CSV file into other formats, such as JSON or RDF</li>
        </ul>
        <p>
          By default, if implementations can't find a metadata file by appending <code>-metadata.json</code> to the filename of the CSV file, they'll just look for a file called <code>csv-metadata.json</code> in the same directory as the CSV file.
        </p>
        <p>
          Metadata files can also describe several CSV files at once, using a slightly different syntax:
        </p>
        <pre class="example">
  {
    "@context": "https://www.w3.org/ns/csvw",
    <strong>"tables": [{
      "url": "countries.csv"
    }, {
      "url": "country-groups.csv"
    }, {
      "url": "unemployment.csv"
    }]</strong>
  }
        </pre>
        <p>
          Here, the <a href="https://w3c.github.io/csvw/metadata/#table-group-tables"><code>tables</code></a> property holds an array of table descriptions, each with the URL of the CSV file that it's describing. The metadata file as a whole describes a group of tables. This is usually used when the tables relate to each other in some way: perhaps they're data in the same format from different periods of time, or perhaps they reference each other.
        </p>
        <p>See also:</p>
        <ul>
          <li><a href="#dialects" class="sectionRef"></a></li>
          <li><a href="#well-known-location" class="sectionRef"></a></li>
          <li><a href="https://w3c.github.io/csvw/syntax/#locating-metadata">Locating Metadata</a> in [[tabular-data-model]]</a></li>
          <li><a href="https://w3c.github.io/csvw/metadata/#metadata-format">Metadata Format</a> in [[tabular-metadata]]</li>
        </ul>
      </section>
      <section id="column-info">
        <h2>How can you provide extra information about the columns in a CSV file?</h2>
        <p>
          You can give information about the columns in a CSV file through a table schema. The simplest thing you can do is say what those columns are called. For example, if you have some CSV like this:
        </p>
        <pre class="example">
"country","country group","name (en)","name (fr)","name (de)","latitude","longitude"
"at","eu","Austria","Autriche","Österreich","47.6965545","13.34598005"
"be","eu","Belgium","Belgique","Belgien","50.501045","4.47667405"
"bg","eu","Bulgaria","Bulgarie","Bulgarien","42.72567375","25.4823218"
</pre>
        <p>
          You can say that the table contains seven columns named as they are in this CSV file like so:
        </p>
        <pre class="example">
{
  "@context": "https://www.w3.org/ns/csvw",
  "url": "countries.csv"
  <strong>"tableSchema": {
    "columns": [{
      "titles": "country"
    },{
      "titles": "country group"
    },{
      "titles": "name (en)"
    },{
      "titles": "name (fr)"
    },{
      "titles": "name (de)"
    },{
      "titles": "latitude"
    },{
      "titles": "longitude"
    }]
  }</strong>
}
</pre>
        <p>
          A validator can check that the CSV file holds the expected columns (both the right number of columns and columns with the expected titles).
        </p>
        <p>See also:</p>
        <ul>
          <li><a href="#validating-csvs" class="sectionRef"></a></li>
          <li><a href="#shared-schemas" class="sectionRef"></a></li>
          <li><a href="#column-title-languages" class="sectionRef"></a></li>
          <li><a href="https://w3c.github.io/csvw/metadata/#schemas">Schemas</a> in [[tabular-metadata]]</li>
          <li><a href="https://w3c.github.io/csvw/metadata/#columns">Columns</a> in [[tabular-metadata]]</li>
        </ul>
      </section>
      <section id="tools">
        <h2>What tools implement or use CSV on the Web?</h2>
        <p>
          This Note can't keep an up-to-date list of the tools that implement or otherwise use CSV on the Web. Instead, look at:
        </p>
        <ul>
          <li><a href="https://w3c.github.io/csvw/tests/reports/index.html">CSV on the Web implementation reports</a></li>
          <li><a href="https://www.w3.org/community/csvw/category/tools/">Entries tagged as CSV on the Web tools on the CSV on the Web Community Group blog</a></li>
        </ul>
      </section>
    </section>
    <section>
      <h1>Documenting CSVs</h1>
      <p>
        Providing metadata about CSVs can be useful simply in providing extra information to anyone who wants to work with them.
      </p>
      <section id="documentation">
        <h2>How can you provide documentation about a CSV file?</h2>
        <p>
          Here's an example that includes some extra descriptive documentation about a number of CSV files:
        </p>
        <pre class="example">
{
  "@context": "https://www.w3.org/ns/csvw",
  <strong>"dc:title": "Unemployment in Europe (monthly)"
  "dc:description": "Harmonized unemployment data for European countries."
  "dc:creator": "Eurostat",</strong>
  "tables": [{
    "url": "countries.csv",
    <strong>"dc:title": "Countries"</strong>
  }, {
    "url": "country-groups.csv",
    <strong>"dc:title": "Country groups"</strong>
  }, {
    "url": "unemployment.csv",
    <strong>"dc:title": "Unemployment (monthly)",
    "dc:description": "The total number of people unemployed"</strong>
  }]
}
</pre>
        <p>
          This example uses <a href="https://dublincore.org/documents/dcmi-terms/">Dublin Core</a> as a vocabulary for providing metadata. You can tell that's the vocabulary that's being used because the terms like <code>dc:title</code> and <code>dc:description</code> begin with the prefix <code>dc</code>, which stands for Dublin Core.
        </p>
        <p>
          There are several different metadata vocabularies in common use around the web. Some people use <a href="https://dublincore.org/documents/dcmi-terms/">Dublin Core</a>. Some people use <a href="https://schema.org">schema.org</a>. Some people use <a href="https://www.w3.org/TR/vocab-dcat/">DCAT</a>. All of these vocabularies can be used independently or together. A publisher could alternatively use:
        </p>
        <pre class="example">
{
  "@context": "https://www.w3.org/ns/csvw",
  <strong>"schema:name": "Unemployment in Europe (monthly)",
  "schema:description": "Harmonized unemployment data for European countries."
  "schema:creator": { "schema:name": "Eurostat" },</strong>
  "tables": [{
    "url": "countries.csv",
    <strong>"schema:name": "Countries"</strong>
  }, {
    "url": "country-groups.csv",
    <strong>"schema:name": "Country groups"</strong>
  }, {
    "url": "unemployment.csv",
    <strong>"schema:name": "Unemployment (monthly)",
    "schema:description": "The total number of people unemployed"</strong>
  }]
}
</pre>
        <p class="note">
          It's not clear at the moment which metadata vocabulary will give publishers the most benefits. Search engines are likely to recognise <a href="https://schema.org">schema.org</a>. RDF-based systems are more likely to recognise Dublin Core.
        </p>
        <p>
          More generally, you can use prefixed properties like these on any of the objects in a metadata document. The prefixes that are recognised are those used in the <a href="https://www.w3.org/2011/rdfa-context/rdfa-1.1">RDFa 1.1 Initial Context</a>. Other properties must be named with full URLs.
        </p>
        <p>See also:</p>
        <ul>
          <li><a href="#structured-metadata" class="sectionRef"></a></li>
          <li><a href="#metadata-language" class="sectionRef"></a></li>
          <li><a href="#multilingual-metadata" class="sectionRef"></a></li>
          <li><a href="https://w3c.github.io/csvw/metadata/#common-properties">Common Properties</a> in [[tabular-metadata]]</li>
        </ul>
      </section>
      <section id="documentation-columns">
        <h2>How can you provide documentation about the columns in a CSV file?</h2>
        <p>
          You can use metadata properties like the ones used for tables for individual columns as well. For example:
        </p>
        <pre class="example">
{
  "@context": "https://www.w3.org/ns/csvw",
  "url": "countries.csv"
  "tableSchema": {
    "columns": [{
      "titles": "country",
      <strong>"dc:description": "The ISO two-letter code for a country, in lowercase."</strong>
    },{
      "titles": "country group",
      <strong>"dc:description": "A lowercase two-letter code for a group of countries."</strong>
    },{
      "titles": "name (en)",
      <strong>"dc:description": "The official name of the country in English."</strong>
    },{
      "titles": "name (fr)",
      <strong>"dc:description": "The official name of the country in French."</strong>
    },{
      "titles": "name (de)",
      <strong>"dc:description": "The official name of the country in German."</strong>
    },{
      "titles": "latitude",
      <strong>"dc:description": "The latitude of an indicative point in the country."</strong>
    },{
      "titles": "longitude",
      <strong>"dc:description": "The longitude of an indicative point in the country."</strong>
    }]
  }
}
</pre>
        <p>See also:</p>
        <ul>
          <li><a href="#units-of-measure" class="sectionRef"></a></li>
          <li><a href="https://w3c.github.io/csvw/metadata/#columns">Columns</a> in [[tabular-metadata]]</li>
          <li><a href="https://w3c.github.io/csvw/metadata/#common-properties">Common Properties</a> in [[tabular-metadata]]</li>
        </ul>
      </section>
      <section id="structured-metadata">
        <h2>What about when metadata like this is structured?</h2>
        <p>
          We've already seen an example where metadata supplied about a table is structured. Look at the <code>schema:creator</code> here:
        </p>
        <pre class="example">
{
  "@context": "https://www.w3.org/ns/csvw",
  "schema:name": "Unemployment in Europe (monthly)",
  "schema:description": "Harmonized unemployment data for European countries."
  <strong>"schema:creator": { "schema:name": "Eurostat" },</strong>
  "tables": [{
    "url": "countries.csv"
  }, {
    "url": "country-groups.csv"
  }, {
    "url": "unemployment.csv"
  }]
}
</pre>
        <p>
          The metadata supplied for a table or group of tables can have nested objects within it. You can provide arrays of values. It will be interpreted as if it is (a minimal version of) [[json-ld]]. Particular patterns that are useful are:
        </p>
        <ul>
          <li>Use nested objects to create structure; for example you could supply the website and telephone number of the creator of a table as well as their name:
            <pre class="example">
"schema:creator": {
  "schema:name": "Eurostat",
  "schema:url": "https://ec.europa.eu/eurostat",
  "schema:contactPoint": [{
    "schema:telephone": "+44 20 300 63103",
    "schema:availableLanguage": "English"
  }, {
    "schema:telephone": "+49 30 223 86 029",
    "schema:availableLanguage": "Deutsch"
  }, {
    "schema:telephone": "+33 1 77 68 89 07"
    "schema:availableLanguage": "français"
  }]
}
</pre>
          </li>
          <li>Use <code>@type</code> to indicate the type of objects if there's an appropriate type to use, for example in this case Eurostat is a governmental organisation:
            <pre class="example">
"schema:creator": {
  "schema:name": "Eurostat",
  <strong>"@type": "schema:GovernmentOrganization"</strong>
}
</pre>
          </li>
          <li>Use an <code>@id</code> property to provide values that are URLs for things about which more information is available at that URL. For example, rather than providing all the information about Eurostat embedded within the metadata, you could just reference out to it:
            <pre class="example">
"schema:creator": { "@id": "https://ec.europa.eu/eurostat" }
</pre>
            or you could include the <code>@id</code> along with other basic properties to make it more readable for humans.
          </li>
        </ul>
        <p>See also:</p>
        <ul>
          <li><a href="#extra-metadata" class="sectionRef"></a></li>
          <li><a href="#data-cube" class="sectionRef"></a></li>
          <li><a href="https://w3c.github.io/csvw/metadata/#common-properties">Common Properties</a> in [[tabular-metadata]]</li>
        </ul>
      </section>
      <section id="cell-annotations">
        <h2>How should you annotate individual cells?</h2>
        <p>
          There's no standardised facility in the CSV on the Web specifications for annotating individual cells, but there is a hook that will enable best practice about how to do that to emerge: the <a href="https://w3c.github.io/csvw/metadata/#table-notes"><code>notes</code></a> property on a table description can contain objects that represent annotations.
        </p>
        <p>
          The <a href="https://www.w3.org/annotation/">W3C Web Annotation Working Group</a> is working on a vocabulary for annotations themselves. This vocabulary includes the concept of a <em>target</em> for an annotation and its <em>body</em> (the content of the annotation).
        </p>
        <p>
          If you are annotating a single cell, the target needs to point to that cell. The easiest way to do that is to use fragment identifiers for CSV files as defined in [[RFC7111]]. These fragment identifiers reference cells based on their position within the original CSV file, with the first row in the CSV file (usually the header row) counted as 1. For example, with the CSV file:
        </p>
        <pre class="example">
"country","country group","name (en)","name (fr)","name (de)","latitude","longitude"
"at","eu","Austria","Autriche","Österreich","47.6965545","13.34598005"
"be","eu","Belgium","Belgique","Belgien","50.501045","4.47667405"
"bg","eu","Bulgaria","Bulgarie","Bulgarien","42.72567375","25.4823218"
</pre>
        <p>
          the cell containing <code>Belgique</code> is at <code>#cell=3,4</code>. It's also possible to refer to ranges of cells with this syntax and to use <code>*</code> to refer to the last row in the file. For example, to target a comment on all the locations in the CSV file you could use the fragment identifier <code>#cell=2,6-*,7</code>.
        </p>
        <p>
          To create comments, then, the <a href="https://w3c.github.io/csvw/metadata/#table-notes"><code>notes</code></a> property can hold an array of objects that use the Web Annotation structure. For example:
        </p>
        <pre class="example">
{
  "@context": "https://www.w3.org/ns/csvw",
  "url": "countries.csv",
  "notes": [{
    "type": "Annotation",
    "target": "countries.csv#cell=2,6-*,7",
    "body": "These locations are of representative points.",
    "motivation": "commenting"
  }, {
    "type": "Annotation",
    "target": "countries.csv#cell=3,4",
    "body": "Corrected.",
    "motivation": "editing"
  }]
}
</pre>
        <p>See also:</p>
        <ul>
          <li><a href="#html-display" class="sectionRef"></a></li>
          <li><a href="https://w3c.github.io/csvw/metadata/#table-notes">Table <code>notes</code></a> in [[tabular-metadata]]</li>
        </ul>
      </section>
    </section>
    <section>
      <h1>Validating CSVs</h1>
      <p>
        Validation is all about checking whether a file contains what you expect it to contain. For CSV files, this can be about:
      </p>
      <ul>
        <li>the number of columns there are and what they're called (see <a href="#column-info" class="sectionRef"></a>)</li>
        <li>what kind of values columns contain</li>
        <li>whether any of those values are unique</li>
        <li>whether they match values in other CSV files</li>
      </ul>
      <section id="datatypes">
        <h2>How can you say what kinds of values are expected in a column?</h2>
        <p>
          There's lots more that you can say about the expected content of columns in a CSV file. The most obvious thing is to indicate the data type. For example, with the CSV file:
        </p>
        <pre class="example">
"country","country group","name (en)","name (fr)","name (de)","latitude","longitude"
"at","eu","Austria","Autriche","Österreich","47.6965545","13.34598005"
"be","eu","Belgium","Belgique","Belgien","50.501045","4.47667405"
"bg","eu","Bulgaria","Bulgarie","Bulgarien","42.72567375","25.4823218"
</pre>
        <p>
          The first five columns are strings and the last two are numbers. You can indicate this with the <a href="https://w3c.github.io/csvw/metadata/#cell-datatype"><code>datatype</code></a> property for each column:
        </p>
        <pre class="example">
{
  "@context": "https://www.w3.org/ns/csvw",
  "url": "countries.csv"
  "tableSchema": {
    "columns": [{
      "titles": "country",
      "datatype": "string"
    },{
      "titles": "country group",
      "datatype": "string"
    },{
      "titles": "name (en)",
      "datatype": "string"
    },{
      "titles": "name (fr)",
      "datatype": "string"
    },{
      "titles": "name (de)",
      "datatype": "string"
    },{
      "titles": "latitude",
      "datatype": "number"
    },{
      "titles": "longitude",
      "datatype": "number"
    }]
  }
}
</pre>
        <p class="note">
          You don't have to include <code>"datatype": "string"</code> for columns that are strings &mdash; columns are assumed to hold strings if no datatype is explicitly specified.
        </p>
        <p>
          There are a number of different datatypes supported by CSV on the Web implementations, based on the set defined in [[xmlschema11-2]]. The complete set is shown in the following diagram:
        </p>
        <figure id="fig-datatypes" style="text-align:center">
          <img src="datatypes.svg" style="max-width: 600px" alt="Built-in Datatype Hierarchy diagram" longdesc="datatypes.html#imageDescription" />
          <figcaption>Diagram showing the built-in datatypes, based on [[xmlschema11-2]]; names in parentheses denote aliases to the [[xmlschema11-2]] terms (see the diagram in <a href="datatypes.svg">SVG</a> or <a href="datatypes.png">PNG</a> formats)</figcaption>
        </figure>
        <p>See also:</p>
        <ul>
          <li><a href="#new-datatypes" class="sectionRef"></a></li>
          <li><a href="#enumerations" class="sectionRef"></a></li>
          <li><a href="#mixed-datatypes" class="sectionRef"></a></li>
          <li><a href="#sequence-values" class="sectionRef"></a></li>
          <li><a href="https://w3c.github.io/csvw/metadata/#datatypes">Datatypes</a> in [[tabular-metadata]]</li>
          <li><a href="https://w3c.github.io/csvw/syntax/#datatypes">Datatypes</a> in [[tabular-data-model]]</li>
        </ul>
      </section>
      <section id="new-datatypes">
        <h2>How do you define new datatypes?</h2>
        <p>
          You can define new datatypes based on the built-in datatypes using an object as the value of the <a href="https://w3c.github.io/csvw/metadata/#cell-datatype"><code>datatype</code></a> property rather than a string. For example:
        </p>
        <pre class="example">
"datatype": {
  "base": "integer",
  "minimum": "1",
  "maximum": "5"
}</pre>
        <p>
          The <a href="https://w3c.github.io/csvw/metadata/#datatype-base"><code>base</code></a> property must be an existing datatype. The other properties on the new datatype define extra restrictions on values of the new datatype. You can give the new datatype a name and description to provide extra documentation for people using the data:
        </p>
        <pre class="example">
"datatype": {
  "dc:title": "Star Rating",
  "dc:description": "A star rating between 1 and 5."
  "base": "integer",
  "minimum": "1",
  "maximum": "5"
}</pre>
        <p>See also:</p>
        <ul>
          <li><a href="#string-restriction" class="sectionRef"></a></li>
          <li><a href="#number-restriction" class="sectionRef"></a></li>
          <li><a href="#number-precision" class="sectionRef"></a></li>
          <li><a href="#number-format" class="sectionRef"></a></li>
          <li><a href="#date-restriction" class="sectionRef"></a></li>
          <li><a href="#date-format" class="sectionRef"></a></li>
          <li><a href="#boolean-format" class="sectionRef"></a></li>
          <li><a href="#units-of-measure" class="sectionRef"></a></li>
          <li><a href="#geospatial" class="sectionRef"></a></li>
          <li><a href="https://w3c.github.io/csvw/metadata/#derived-datatypes">Derived Datatypes</a> in [[tabular-metadata]]</li>
          <li><a href="https://w3c.github.io/csvw/syntax/#datatypes">Datatypes</a> in [[tabular-data-model]]</li>
        </ul>
      </section>
      <section id="string-restriction">
        <h2>How do you restrict what kind of strings a column contains?</h2>
        <p>
          In the example we've been using, the first column always contains a country code consisting of two lowercase letters. This is a new datatype based on <code>string</code>. You can specify the format for string values in a column using a regular expression, like this:
        </p>
        <pre class="example">{
  "titles": "country",
  "datatype": {
    "dc:title": "Country Code",
    "dc:description": "Country codes as specified in ISO 3166.",
    "base": "string",
    <strong>"format": "[a-z]{2}"</strong>
  }
}
  </pre>
        <p>
          It's also possible to restrict the length of a string-based datatype using the <a href="https://w3c.github.io/csvw/metadata/#datatype-length"><code>length</code></a> or <a href="https://w3c.github.io/csvw/metadata/#datatype-minLength"><code>minLength</code></a> and/or <a href="https://w3c.github.io/csvw/metadata/#datatype-maxLength"><code>maxLength</code></a> properties. For example the following says that the column holding the English names of countries must have values between 3 and 128 characters long:
        </p>
        <pre class="example">{
  "titles": "name (en)",
  "datatype": {
    "base": "string",
    <strong>"minLength": "3",
    "maxLength": "128"</strong>
  }
}</pre>
        <p>See also:</p>
        <ul>
          <li><a href="#number-restriction" class="sectionRef"></a></li>
          <li><a href="#date-restriction" class="sectionRef"></a></li>
          <li><a href="#boolean-format" class="sectionRef"></a></li>
          <li><a href="#enumeration-regexp" class="sectionRef"></a></li>
          <li><a href="#column-language" class="sectionRef"></a></li>
          <li><a href="#geospatial" class="sectionRef"></a></li>
          <li><a href="https://w3c.github.io/csvw/syntax/#formats-for-other-types">Formats for other types</a> in [[tabular-data-model]]</li>
          <li><a href="https://w3c.github.io/csvw/syntax/#length-constraints">Length Constraints</a> in [[tabular-data-model]]</li>
        </ul>
      </section>
      <section id="number-restriction">
        <h2>How do you restrict the size of numbers a column contains?</h2>
        <p>
          The size of numbers in a column can be restricted using the <a href="https://w3c.github.io/csvw/metadata/#datatype-minimum"><code>minimum</code></a> and <a href="https://w3c.github.io/csvw/metadata/#datatype-maximum"><code>maximum</code></a> properties and/or the <a href="https://w3c.github.io/csvw/metadata/#datatype-minExclusive"><code>minExclusive</code></a> and <a href="https://w3c.github.io/csvw/metadata/#datatype-maxExclusive"><code>maxExclusive</code></a> properties. In our example, one column contains latitudes, which can range between -90 and +90:
        </p>
        <pre class="example">{
  "titles": "latitude",
  "datatype": {
    "base": "number",
    <strong>"minimum": "-90",
    "maximum": "90"</strong>
  }
}</pre>
        <p>See also:</p>
        <ul>
          <li><a href="#number-precision" class="sectionRef"></a></li>
          <li><a href="#number-format" class="sectionRef"></a></li>
          <li><a href="https://w3c.github.io/csvw/syntax/#value-constraints">Value Constraints</a> in [[tabular-data-model]]</li>
        </ul>
      </section>
      <section id="number-precision">
        <h2>How do you ensure that decimal numbers have a particular precision or leading zeros?</h2>
        <p>
          In the example we're using, the latitudes are provided to between six and eight decimal places and there are no leading or trailing zeros. You can use the <a href="https://w3c.github.io/csvw/metadata/#datatype-format"><code>format</code></a> property to provide a pattern that matches these numbers. In the pattern, <code>0</code> represents a required digit and <code>#</code> represents an optional digit. For the <code>latitude</code>, the definition looks like:
        </p>
        <pre class="example">{
  "titles": "latitude",
  "datatype": {
    "base": "number",
    "minimum": "-90",
    "maximum": "90",
    <strong>"format": "#0.000000##"</strong>
  }
}</pre>
        <p>
          The <a href="https://w3c.github.io/csvw/metadata/#datatype-format"><code>format</code></a> property can also be used to indicate that values in a column should have leading zeros. For example, if a column were supposed to hold a three digit number you could use the pattern <code>000</code>.
        </p>
        <p>See also:</p>
        <ul>
          <li><a href="#number-restriction" class="sectionRef"></a></li>
          <li><a href="#number-format" class="sectionRef"></a></li>
          <li><a href="https://w3c.github.io/csvw/syntax/#formats-for-numeric-types">Formats for numeric types</a> in [[tabular-data-model]]</li>
        </ul>
      </section>
      <section id="number-format">
        <h2>How do you validate numbers that aren't in standard numeric formats?</h2>
        <p>
          Sometimes numbers within a CSV file won't be in a standard numeric format. For example, they might include commas as grouping characters (eg <code>12,345,678</code>) or as decimal points (eg <code>12,3</code>). In these cases, you can use the <a href="https://w3c.github.io/csvw/metadata/#datatype-format"><code>format</code></a> property with an object value.
        </p>
        <p>
          To match numbers with grouping separators as in <code>12,345,678</code> you should specify <code>","</code> as the <a href="https://w3c.github.io/csvw/syntax/#dfn-datatype-format-groupchar"><code>groupChar</code></a> for the format. The <a href="https://w3c.github.io/csvw/syntax/#dfn-datatype-format-pattern"><code>pattern</code></a> property then holds the pattern that indicates how many digits should be in each group. This example validates numbers with groups of three digits separated by commas:
        </p>
        <pre class="example">
"datatype": {
  "base": "integer",
  <strong>"format": {
    "groupChar": ",",
    "pattern": "#,##0"
  }</strong>
}</pre>
        <p>
          To match numbers with decimal separators other than <code>.</code>, as in <code>12,3</code>, you should specify <code>","</code> as the <a href="https://w3c.github.io/csvw/syntax/#dfn-datatype-format-decimalchar"><code>decimalChar</code></a> for the format. This example validates numbers with commas as decimal points:
        </p>
        <pre class="example">
"datatype": {
  "base": "integer",
  <strong>"format": {
    "decimalChar": ","
  }</strong>
}</pre>
        <p>
          You can mix and match decimal and grouping characters and patterns. For example, in France it's standard to use commas for decimal points and spaces for grouping characters, so CSV files produced in France might contain numbers like <code>1 234 567,89</code>. These could be validated with a datatype like:
        </p>
        <pre class="example">
"datatype": {
  "base": "integer",
  <strong>"format": {
    "decimalChar": ",",
    "groupChar": " ",
    "pattern": "# ##0,0#"
  }</strong>
}</pre>
        <p>See also:</p>
        <ul>
          <li><a href="#number-restriction" class="sectionRef"></a></li>
          <li><a href="#number-precision" class="sectionRef"></a></li>
          <li><a href="https://w3c.github.io/csvw/syntax/#formats-for-numeric-types">Formats for numeric types</a> in [[tabular-data-model]]</li>
        </ul>
      </section>
      <section id="date-restriction">
        <h2>How do you restrict what kind of dates and times a column contains?</h2>
        <p>
          Dates and times are treated similarly to numbers. You can use the <a href="https://w3c.github.io/csvw/metadata/#datatype-minimum"><code>minimum</code></a>, <a href="https://w3c.github.io/csvw/metadata/#datatype-maximum"><code>maximum</code></a>, <a href="https://w3c.github.io/csvw/metadata/#datatype-minExclusive"><code>minExclusive</code></a> and/or <a href="https://w3c.github.io/csvw/metadata/#datatype-maxExclusive"><code>maxExclusive</code></a> properties to restrict their values.
        </p>
        <p>
          For example, to indicate that the column should contain dates later than 1st January 2000, you can use the datatype:
        </p>
        <pre class="example">
"datatype": {
  "base": "date",
  <strong>"minimum": "2000-01-01"</strong>
}</pre>
        <p>
          To indicate that the column should contain times before midday (exclusive), you can use the datatype:
        </p>
        <pre class="example">
"datatype": {
  "base": "time",
  <strong>"minExclusive": "12:00:00"</strong>
}</pre>
        <p class="note">
          The format of dates or times used for minimum or maximum values is always the <a href="https://en.wikipedia.org/wiki/ISO_8601">ISO 8601</a> format: <code>yyyy-MM-dd</code> for dates, <code>HH:mm:ss.S</code> for times and <code>yyyy-MM-ddTHH:mm:ss.S</code> for date/times.
        </p>
        <p>See also:</p>
        <ul>
          <li><a href="#date-format" class="sectionRef"></a></li>
          <li><a href="https://w3c.github.io/csvw/syntax/#value-constraints">Value Constraints</a> in [[tabular-data-model]]</li>
        </ul>
      </section>
      <section id="date-format">
        <h2>How do you validate dates that aren't in standard date or time formats?</h2>
        <p>
          Dates and times in CSV files often come in formats other than the standard <a href="https://en.wikipedia.org/wiki/ISO_8601">ISO 8601</a> format. You can use the <a href="https://w3c.github.io/csvw/metadata/#datatype-format"><code>format</code></a> property to indicate the expected format of the date or time.
        </p>
        <p>
          For example, to recognise dates in the usual UK format such as 31/10/2015 for 31st October 2015, you could use:
        </p>
        <pre class="example">
"datatype": {
  "base": "date",
  <strong>"format": "dd/MM/yyyy"</strong>
}</pre>
        <p>
          Implementations are only required to understand a particular set of common formats for dates and times. These formats are, for dates:
        </p>
        <ul>
          <li><code>yyyy-MM-dd</code> e.g. <code>2015-03-22</code></li>
          <li><code>yyyyMMdd</code> e.g. <code>20150322</code></li>
          <li><code>dd-MM-yyyy</code> e.g. <code>22-03-2015</code></li>
          <li><code>d-M-yyyy</code> e.g. <code>22-3-2015</code></li>
          <li><code>MM-dd-yyyy</code> e.g. <code>03-22-2015</code></li>
          <li><code>M-d-yyyy</code> e.g. <code>3-22-2015</code></li>
          <li><code>dd/MM/yyyy</code> e.g. <code>22/03/2015</code></li>
          <li><code>d/M/yyyy</code> e.g. <code>22/3/2015</code></li>
          <li><code>MM/dd/yyyy</code> e.g. <code>03/22/2015</code></li>
          <li><code>M/d/yyyy</code> e.g. <code>3/22/2015</code></li>
          <li><code>dd.MM.yyyy</code> e.g. <code>22.03.2015</code></li>
          <li><code>d.M.yyyy</code> e.g. <code>22.3.2015</code></li>
          <li><code>MM.dd.yyyy</code> e.g. <code>03.22.2015</code></li>
          <li><code>M.d.yyyy</code> e.g. <code>3.22.2015</code></li>
        </ul>
        <p>
          For times:
        </p>
        <ul>
          <li><code>HH:mm:ss.S</code> with one or more trailing <code>S</code> characters indicating the maximum number of fractional seconds e.g. <code>HH:mm:ss.SSS</code> for <code>15:02:37.143</code></li>
          <li><code>HH:mm:ss</code> e.g. <code>15:02:37</code></li>
          <li><code>HHmmss</code> e.g. <code>150237</code></li>
          <li><code>HH:mm</code> e.g. <code>15:02</code></li>
          <li><code>HHmm</code> e.g. <code>1502</code></li>
        </ul>
        <p>
          And for date/times:
        </p>
        <ul>
          <li><code>yyyy-MM-ddTHH:mm:ss.S</code> with one or more trailing <code>S</code> characters indicating the maximum number of fractional seconds e.g. <code>yyyy-MM-ddTHH:mm:ss.SSS</code> for <code>2015-03-15T15:02:37.143</code></li>
          <li><code>yyyy-MM-ddTHH:mm:ss</code> e.g. <code>2015-03-15T15:02:37</code></li>
          <li><code>yyyy-MM-ddTHH:mm</code> e.g. <code>2015-03-15T15:02</code></li>
          <li>any of the date formats above, followed by a single space, followed by any of the time formats above, e.g. <code>M/d/yyyy HH:mm</code> for <code>3/22/2015 15:02</code> or <code>dd.MM.yyyy HH:mm:ss</code> for <code>22.03.2015 15:02:37</code></li>
        </ul>
        <p class="note">
          None of these formats include names or abbreviations for months or days. The implementation you use might support other date and time formats as well, including specialised formats for the other date and time datatypes such as <code>gMonthYear</code>. Check your implementation's documentation to see what it supports.
        </p>
        <p>See also:</p>
        <ul>
          <li><a href="#date-restriction" class="sectionRef"></a></li>
          <li><a href="https://w3c.github.io/csvw/syntax/#formats-for-dates-and-times">Formats for dates and times</a> in [[tabular-data-model]]</li>
        </ul>
      </section>
      <section id="boolean-format">
        <h2>How do you validate boolean values that aren't <code>true</code> or <code>false</code>?</h2>
        <p>
          By default, validators will recognise boolean values that are <code>1</code> or <code>0</code> or <code>true</code> or <code>false</code>. If a CSV file contains boolean values like <code>T</code> and <code>F</code> or <code>Yes</code> and <code>No</code> then you can create a derived boolean datatype that uses that syntax using the <code>format</code> property, with the two possible values separated by a <code>|</code>, for example:
        </p>
        <pre class="example">
"datatype": {
  "base": "boolean",
  <strong>"format": "Yes|No"</strong>
}</pre>
        <p>See also:</p>
        <ul>
          <li><a href="#string-restriction" class="sectionRef"></a></li>
          <li><a href="https://w3c.github.io/csvw/syntax/#formats-for-booleans">Formats for booleans</a> in [[tabular-data-model]]</li>
        </ul>
      </section>
      <section id="enumerations">
        <h2>How do you specify a list of valid values for a column?</h2>
        <p>
          The example CSV file we're using is this:
        </p>
        <pre class="example">
"country","country group","name (en)","name (fr)","name (de)","latitude","longitude"
"at","eu","Austria","Autriche","Österreich","47.6965545","13.34598005"
"be","eu","Belgium","Belgique","Belgien","50.501045","4.47667405"
"bg","eu","Bulgaria","Bulgarie","Bulgarien","42.72567375","25.4823218"
</pre>
        <p>
          In it, the second column, <code>country group</code>, contains either the value <code>eu</code> or the value <code>non-eu</code>. Despite there being two values, this isn't a boolean column. Instead, it's a column that has only two valid values.
        </p>
        <p>
          There are two ways to specify that a column contains one of a list of values: using a regular expression to list the values and using a reference to a separate CSV file that contains the values.
        </p>
        <section id="enumeration-regexp">
          <h3>Using a regular expression to give a list of valid values</h3>
          <p>
            Using a regular expression to list values works best if those values are strings, if there are only a few of them, and if they are self-explanatory such that you don't want to provide any additional information about them.
          </p>
          <p>
            In this example, the <code>country group</code> column could be specified as:
          </p>
          <pre class="example">{
  "titles": "country group",
  "datatype": {
    "base": "string",
    <strong>"format": "eu|non-eu"</strong>
  }
}</pre>
          <p>
            As described in <a href="#string-restriction" class="sectionRef"></a>, the <a href="https://w3c.github.io/csvw/metadata/#datatype-format"><code>format</code></a> property contains a regular expression. List the options separated by <code>|</code> and ensure that you escape any of the characters in the options that have special meaning in regular expressions.
          </p>
          <p>See also:</p>
          <ul>
            <li><a href="#string-restriction" class="sectionRef"></a></li>
          <li><a href="https://w3c.github.io/csvw/syntax/#formats-for-other-types">Formats for other types</a> in [[tabular-data-model]]</li>
          </ul>
        </section>
        <section id="enumeration-reference">
          <h3>Using a separate CSV file to give a list of valid values</h3>
          <p>
            A more powerful method of listing the valid values in a particular column is to list those values in a separate CSV file. The CSV file can be very simple, containing just a single column that lists the valid values. In this example, we can create <code>country-groups.csv</code> containing:
          </p>
          <pre class="example">
group
eu
non-eu
</pre>
          <p>
            We can then provide definitions for both the <code>countries.csv</code> and <code>country-groups.csv</code> files, and state that the <code>country group</code> column in <code>countries.csv</code> references the <code>group</code> column in <code>country_groups.csv</code>. This reference from one file to another is called a <dfn>foreign key</dfn>.
          </p>
          <p>
            To use a <a>foreign key</a>, both files must be referenced in the same metadata document, and both columns must be given names. Column names are only used inside the metadata document and you can only use (ASCII) letters, numbers, <code>.</code> and <code>_</code> within them. So the basic metadata document, before adding the <a>foreign key</a>, should look like:
          </p>
          <pre class="example">
{
  "@context": "https://www.w3.org/ns/csvw",
  "tables": [{
    "url": "countries.csv",
    "tableSchema": {
      "columns": [{
        "titles": "country"
      },{
        <strong>"name": "country_group",</strong>
        "titles": "country group"
      },{
        "titles": "name (en)"
      },{
        "titles": "name (fr)"
      },{
        "titles": "name (de)"
      },{
        "titles": "latitude"
      },{
        "titles": "longitude"
      }]
    }
  }, {
    "url": "country-groups.csv",
    "tableSchema": {
      "columns": [{
        <strong>"name": "group",</strong>
        "titles": "group"
      }]
    }
  }]
}
</pre>
          <p>
            The <a>foreign key</a> is defined in the schema for the <code>countries.csv</code> table, as follows:
          </p>
          <pre class="example">
{
  "@context": "https://www.w3.org/ns/csvw",
  "tables": [{
    "url": "countries.csv",
    "tableSchema": {
      "columns": [{
        "titles": "country"
      },{
        "name": "country_group",
        "titles": "country group"
      },{
        "titles": "name (en)"
      },{
        "titles": "name (fr)"
      },{
        "titles": "name (de)"
      },{
        "titles": "latitude"
      },{
        "titles": "longitude"
      }],
      <strong>"foreignKeys": [{
        "columnReference": "country_group",
        "reference": {
          "resource": "country-groups.csv",
          "columnReference": "group"
        }
      }]</strong>
    }
  }, {
    "url": "country-groups.csv",
    "tableSchema": {
      "columns": [{
        "name": "group",
        "titles": "group"
      }]
    }
  }]
}
</pre>
          <p>
            The <a href="https://w3c.github.io/csvw/metadata/#schema-foreignKeys"><code>foreignKeys</code></a> property can hold several <a>foreign keys</a>. Each contains a <a href="https://w3c.github.io/csvw/metadata/#foreign-key-column-reference"><code>columnReference</code></a> to a column or list of columns in one CSV file, and a <a href="https://w3c.github.io/csvw/metadata/#foreign-key-reference"><code>reference</code></a> which defines a column or list of columns in another CSV file.
          </p>
          <p>
            The advantage of this method of listing the values allowed in a column is that the CSV file that contains the list of possible values can also provide additional information about those values. For example, we can provide expansions of what <code>eu</code> and <code>non-eu</code> mean in different languages:
          </p>
          <pre class="example">
group,name (en),name (fr),name (de)
eu,"European Union","Union européenne","Europäische Union"
non-eu,"Non EU countries","Pays hors Union européenne",Nicht-EU-Länder
</pre>
          <p>See also:</p>
          <ul>
            <li><a href="#shared-schemas" class="sectionRef"></a></li>
            <li><a href="https://w3c.github.io/csvw/metadata/#schema-examples">Foreign key examples</a> in [[tabular-metadata]]</li>
          </ul>
        </section>
      </section>
      <section id="mixed-datatypes">
        <h2>How do you enable a column to have a mix of value types?</h2>
        <p>
          Sometimes a column that contains numbers will contain special values, such as <code>X</code> or <code>NK</code>, when a value is unknown or redacted. If these columns are simply classified as numeric then the non-numeric values will be classed as errors.
        </p>
        <p>
          To avoid values being classified as errors when they are being used to indicate missing values, list those values as null values using the <a href="https://w3c.github.io/csvw/metadata/#cell-null"><code>null</code></a> property. This can take either a single string or an array of strings. For example, the <code>latitude</code> column might usually be numeric but hold an <code>X</code> if there is no indicative point for the country:
        </p>
        <pre class="example">{
  "titles": "latitude",
  <strong>"null": "X",</strong>
  "datatype": {
    "base": "number",
    "minimum": "-90",
    "maximum": "90"
  }
}</pre>
        <p class="note">
          The <a href="https://w3c.github.io/csvw/metadata/#cell-null"><code>null</code></a> property can also be useful when a column contains values that are of the right type but used to indicate a missing value. It's not uncommon, for example, for publishers to use the value <code>99</code> in a column that contains integers to indicate that a value is missing.
        </p>
        <p>See also:</p>
        <ul>
          <li><a href="#string-restriction" class="sectionRef"></a></li>
          <li><a href="https://w3c.github.io/csvw/metadata/#cell-null"><code>null</code> property</a> in [[tabular-metadata]]</li>
          <li><a href="https://w3c.github.io/csvw/syntax/#parsing-cells">Parsing Cells</a> in [[tabular-data-model]]</li>
        </ul>
      </section>
      <section id="sequence-values">
        <h2>What if the cells in a column contain lists of values?</h2>
        <p>
          Cells may contain lists of values with spaces, semi-colons or other characters acting as separators. For example, instead of using separate <code>latitude</code> and <code>longitude</code> columns, the CSV that we're looking at could contain a single <code>latlong</code> column consisting of the latitude and longitude separated by a space:
        </p>
        <pre class="example">
"country","country group","name (en)","name (fr)","name (de)","latlong"
"at","eu","Austria","Autriche","Österreich","47.6965545 13.34598005"
"be","eu","Belgium","Belgique","Belgien","50.501045 4.47667405"
"bg","eu","Bulgaria","Bulgarie","Bulgarien","42.72567375 25.4823218"
</pre>
        <p>
          In this scenario, the <a href="https://w3c.github.io/csvw/metadata/#cell-separator"><code>separator</code></a> property can be used to indicate that the values in a column are lists themselves, and what separator is used between the items in the list. For example:
        </p>
        <pre class="example">{
  "titles": "latlong",
  <strong>"separator": " ",</strong>
  "datatype": {
    "base": "number",
    "minimum": "-180",
    "maximum": "180"
  }
}</pre>
        <p>
          When <a href="https://w3c.github.io/csvw/metadata/#cell-separator"><code>separator</code></a> is specified, the <a href="https://w3c.github.io/csvw/metadata/#cell-datatype"><code>datatype</code></a> property applies to each of the values in the list. There's no way to indicate that the values in the list have different datatypes, or set limits on the length of the list.
        </p>
        <p>See also:</p>
        <ul>
          <li><a href="#list-values" class="sectionRef"></a></li>
          <li><a href="https://w3c.github.io/csvw/metadata/#cell-separator"><code>separator</code> property</a> in [[tabular-metadata]]</li>
          <li><a href="https://w3c.github.io/csvw/syntax/#parsing-cells">Parsing Cells</a> in [[tabular-data-model]]</li>
        </ul>
      </section>
      <section id="required-values">
        <h2>How do you ensure every row has a value for a column?</h2>
        <p>
          By default, a validator won't give any errors if a value is missing in a column. If you want to ensure that a value is provided for every row in the column, use the <a href="https://w3c.github.io/csvw/metadata/#cell-required"><code>required</code></a> property for that column, with the value <code>true</code>.
        </p>
        <p>
          In our example, we might say that all the columns are required except the French and German names (applications being expected to default to the English name if the translation is missing):
        </p>
        <pre class="example">
"tableSchema": {
  "columns": [{
    "titles": "country",
    <strong>"required": true</strong>
  },{
    "titles": "country group",
    <strong>"required": true</strong>
  },{
    "titles": "name (en)",
    <strong>"required": true</strong>
  },{
    "titles": "name (fr)"
  },{
    "titles": "name (de)"
  },{
    "titles": "latitude",
    <strong>"required": true</strong>
  },{
    "titles": "longitude",
    <strong>"required": true</strong>
  }]
}
</pre>
        <p class="note">
          Setting <a href="https://w3c.github.io/csvw/metadata/#cell-required"><code>required</code></a> to <code>true</code> means that you can't have any null values in a column. If, in this example, <code>latitude</code> and <code>longitude</code> had <code>null</code> set to <code>X</code> then those columns couldn't contain an <code>X</code>. It doesn't usually make sense to specify both <a href="https://w3c.github.io/csvw/metadata/#cell-null"><code>null</code></a> and <a href="https://w3c.github.io/csvw/metadata/#cell-required"><code>required</code></a>.
        </p>
        <p>See also:</p>
        <ul>
          <li><a href="#unique-values" class="sectionRef"></a></li>
          <li><a href="https://w3c.github.io/csvw/metadata/#cell-required"><code>required</code> property</a> in [[tabular-metadata]]</li>
        </ul>
      </section>
      <section id="unique-values">
        <h2>How do you indicate all the values in a column are unique?</h2>
        <p>
          In our example, the <code>country</code> column must contain unique values: each row should define a different country. To specify this, you can use a primary key to refer to the name of the column:
        </p>
        <pre class="example">
"tableSchema": {
  "columns": [{
    <strong>"name": "country",</strong>
    "titles": "country"
  },{
    "titles": "country group"
  },{
    "titles": "name (en)"
  },{
    "titles": "name (fr)"
  },{
    "titles": "name (de)"
  },{
    "titles": "latitude"
  },{
    "titles": "longitude"
  }],
  <strong>"primaryKey": "country"</strong>
}
</pre>
        <p>
          Each CSV file can only have one primary key. A primary key can be made up of a number of columns that have to be unique in combination: the classic example would be <code>["firstName", "lastName"]</code>.
        </p>
        <p>See also:</p>
        <ul>
          <li><a href="#enumeration-reference" class="sectionRef"></a></li>
          <li><a href="#required-values" class="sectionRef"></a></li>
          <li><a href="#shared-schemas" class="sectionRef"></a></li>
          <li><a href="https://w3c.github.io/csvw/metadata/#schema-primaryKey"><code>primaryKey</code> property</a> in [[tabular-metadata]]</li>
        </ul>
      </section>
    </section>
    <section>
      <h1>Transforming CSVs</h1>
      <p>
        CSV is great for transferring data around the place, but it's often not as useful for processing that data. Other formats can be better at providing structure and meaning for data. So a means for transforming data out of CSV and into other formats is a common requirement.
      </p>
      <section id="transformation">
        <h2>What can you transform CSV into?</h2>
        <p>
          You can of course transform CSV into anything you like using your favourite programming language. However, the CSV on the Web specs provide standardised ways of mapping CSV into two other formats:
        </p>
        <ul>
          <li>JSON, in [[csv2json]]</li>
          <li>RDF, in [[csv2rdf]]</li>
        </ul>
        <p>
          These specifications make use of the metadata described in this primer during the transformation to decide what to include in the transformed output and how to include it. Processors that support these standardised transformations can be used by people who can't program.
        </p>
        <p>
          These specifications describe what output you get if you don't supply any metadata. Given a CSV file like this:
        </p>
        <pre class="example">
"country","country group","name (en)","name (fr)","name (de)","latitude","longitude"
"at","eu","Austria","Autriche","Österreich","47.6965545","13.34598005"
"be","eu","Belgium","Belgique","Belgien","50.501045","4.47667405"
"bg","eu","Bulgaria","Bulgarie","Bulgarien","42.72567375","25.4823218"
</pre>
        <p>
          the usual, minimal JSON output would be:
        </p>
        <pre class="example">[{
  "country": "at",
  "country group": "eu",
  "name (en)": "Austria",
  "name (fr)": "Autriche",
  "name (de)": "Österreich",
  "latitude": "47.6965545",
  "longitude": "13.34598005"
}, {
  "country": "be",
  "country group": "eu",
  "name (en)": "Belgium",
  "name (fr)": "Belgique",
  "name (de)": "Belgien",
  "latitude": "50.501045",
  "longitude": "4.47667405"
}, {
  "country": "bg",
  "country group": "eu",
  "name (en)": "Bulgaria",
  "name (fr)": "Bulgarie",
  "name (de)": "Bulgarien",
  "latitude": "42.72567375",
  "longitude": "25.4823218"
}]</pre>
        <p>
          and the RDF output would be:
        </p>
        <pre class="example">
@prefix xsd: &lt;https://www.w3.org/2001/XMLSchema#&gt; .

[
  &lt;#country&gt; "at";
  &lt;#country%20group&gt; "eu";
  &lt;#latitude&gt; "47.6965545";
  &lt;#longitude&gt; "13.34598005";
  &lt;#name%20%28de%29&gt; "Österreich";
  &lt;#name%20%28en%29&gt; "Austria";
  &lt;#name%20%28fr%29&gt; "Autriche"
] .

[
  &lt;#country&gt; "be";
  &lt;#country%20group&gt; "eu";
  &lt;#latitude&gt; "50.501045";
  &lt;#longitude&gt; "4.47667405";
  &lt;#name%20%28de%29&gt; "Belgien";
  &lt;#name%20%28en%29&gt; "Belgium";
  &lt;#name%20%28fr%29&gt; "Belgique"
] .

[
  &lt;#country&gt; "bg";
  &lt;#country%20group&gt; "eu";
  &lt;#latitude&gt; "42.72567375";
  &lt;#longitude&gt; "25.4823218";
  &lt;#name%20%28de%29&gt; "Bulgarien";
  &lt;#name%20%28en%29&gt; "Bulgaria";
  &lt;#name%20%28fr%29&gt; "Bulgarie"
] .
        </pre>
        <p class="note">
          The specifications define how to transform CSV into RDF. In this Primer all the examples use <a href="https://www.w3.org/TR/turtle/">Turtle</a> as the serialisation for that RDF. Implementations may generate other serialisations for RDF such as <a href="https://www.w3.org/TR/rdf-syntax-grammar/">RDF/XML</a> or <a href="https://www.w3.org/TR/json-ld/">JSON-LD</a>.
        </p>
        <p>See also:</p>
        <ul>
          <li><a href="#extra-metadata" class="sectionRef"></a></li>
          <li><a href="#json-ld" class="sectionRef"></a></li>
          <li><a href="#data-cube" class="sectionRef"></a></li>
          <li><a href="#extension-transformations" class="sectionRef"></a></li>
          <li><a href="https://www.w3.org/TR/csv2json/#minimal-mode">Minimal Mode</a> in [[csv2json]]</li>
          <li><a href="https://w3c.github.io/csvw/csv2rdf/#conversion">Converting Tabular Data to RDF</a> in [[csv2rdf]]</li>
        </ul>
      </section>
      <section id="transformation-values">
        <h2>What values get used in the output of a transformation?</h2>
        <p>
          The result of a transformation will include typed values based on the datatype and language of each column. So if we state that the longitude and latitude are numbers and the names are strings in the given language, as in this metadata:
        </p>
        <pre class="example">
{
  "@context": "https://www.w3.org/ns/csvw",
  "url": "countries.csv",
  "tableSchema": {
    "columns": [{
      "titles": "country"
    },{
      "titles": "country group"
    },{
      "titles": "name (en)",
      <strong>"lang": "en"</strong>
    },{
      "titles": "name (fr)",
      <strong>"lang": "fr"</strong>
    },{
      "titles": "name (de)",
      <strong>"lang": "de"</strong>
    },{
      "titles": "latitude",
      <strong>"datatype": "number"</strong>
    },{
      "titles": "longitude",
      <strong>"datatype": "number"</strong>
    }]
  }
}
</pre>
        <p>
          then the JSON will look like:
        </p>
        <pre class="example">[{
  "country": "at",
  "country group": "eu",
  "name (en)": "Austria",
  "name (fr)": "Autriche",
  "name (de)": "Österreich",
  <strong>"latitude": 47.6965545,
  "longitude": 13.34598005</strong>
},{
  "country": "be",
  "country group": "eu",
  "name (en)": "Belgium",
  "name (fr)": "Belgique",
  "name (de)": "Belgien",
  <strong>"latitude": 50.501045,
  "longitude": 4.47667405</strong>
},{
  "country": "bg",
  "country group": "eu",
  "name (en)": "Bulgaria",
  "name (fr)": "Bulgarie",
  "name (de)": "Bulgarien",
  <strong>"latitude": 42.72567375,
  "longitude": 25.4823218</strong>
}]
        </pre>
        <p>
          and the RDF will look like:
        </p>
        <pre class="example">
@prefix rdf: &lt;https://www.w3.org/1999/02/22-rdf-syntax-ns#&gt; .
@prefix xsd: &lt;https://www.w3.org/2001/XMLSchema#&gt; .

[
  &lt;#country&gt; "at";
  &lt;#country%20group&gt; "eu";
  <strong>&lt;#latitude&gt; 4.76965545e1;
  &lt;#longitude&gt; 1.334598005e1;
  &lt;#name%20%28de%29&gt; "Österreich"@de;
  &lt;#name%20%28en%29&gt; "Austria"@en;
  &lt;#name%20%28fr%29&gt; "Autriche"@fr</strong>
] .

[
  &lt;#country&gt; "be";
  &lt;#country%20group&gt; "eu";
  <strong>&lt;#latitude&gt; 5.0501045e1;
  &lt;#longitude&gt; 4.47667405e0;
  &lt;#name%20%28de%29&gt; "Belgien"@de;
  &lt;#name%20%28en%29&gt; "Belgium"@en;
  &lt;#name%20%28fr%29&gt; "Belgique"@fr</strong>
] .

[
  &lt;#country&gt; "bg";
  &lt;#country%20group&gt; "eu";
  <strong>&lt;#latitude&gt; 4.272567375e1;
  &lt;#longitude&gt; 2.54823218e1;
  &lt;#name%20%28de%29&gt; "Bulgarien"@de;
  &lt;#name%20%28en%29&gt; "Bulgaria"@en;
  &lt;#name%20%28fr%29&gt; "Bulgarie"@fr</strong>
] .</pre>
        <p>See also:</p>
        <ul>
          <li><a href="#datatypes" class="sectionRef"></a></li>
          <li><a href="#new-datatypes" class="sectionRef"></a></li>
          <li><a href="#column-language" class="sectionRef"></a></li>
          <li><a href="#uom-datatypes" class="sectionRef"></a></li>
          <li><a href="https://www.w3.org/TR/csv2json/#datatypes">Datatypes</a> in [[csv2json]]</li>
          <li><a href="https://w3c.github.io/csvw/csv2rdf/#datatypes">Datatypes</a> in [[csv2rdf]]</li>
        </ul>
      </section>
      <section id="missing-values">
        <h2>What value gets used in the output if it's missing in the CSV?</h2>
        <p>
          If there's a missing value in the CSV, then usually the property will be omitted in the result as well. So if the latitude and longitude are missing for the first row of the CSV file we've been using, the equivalent JSON won't include those properties either:
        </p>
        <pre class="example">{
  "country": "at",
  "country group": "eu",
  "name (en)": "Austria",
  "name (fr)": "Autriche",
  "name (de)": "Österreich"
}</pre>
        <p>
          and nor will the RDF:
        </p>
        <pre class="example">[
  &lt;#country&gt; "at";
  &lt;#country%20group&gt; "eu";
  &lt;#name%20%28de%29&gt; "Österreich"@de;
  &lt;#name%20%28en%29&gt; "Austria"@en;
  &lt;#name%20%28fr%29&gt; "Autriche"@fr
] .</pre>
        <p>
          If you want a value to appear even when the value is missing in the CSV, you can provide that value as the <a href="https://w3c.github.io/csvw/metadata/#cell-default"><code>default</code></a> for the column. This value must be supplied as a string but will be treated exactly as if it had appeared within the CSV file. For example, if you supply a non-numeric string for a numeric column, as in:
        </p>
        <pre class="example">{
  "titles": "latitude",
  "datatype": "number",
  <strong>"default": "NOT KNOWN"</strong>
}</pre>
        <p>
          The default value will be seen as an invalid value and therefore represented as a string in the output.
        </p>
        <p>See also:</p>
        <ul>
          <li><a href="#required-values" class="sectionRef"></a></li>
          <li><a href="#mixed-datatypes" class="sectionRef"></a></li>
          <li><a href="https://www.w3.org/TR/csv2json/#minimal-mode">Minimal Mode</a> in [[csv2json]]</li>
          <li><a href="https://w3c.github.io/csvw/csv2rdf/#conversion">Converting Tabular Data to RDF</a> in [[csv2rdf]]</li>
        </ul>
      </section>
      <section id="property-names">
        <h2>How are the properties in the output of a transformation named?</h2>
        <p>
          By default, the properties in the JSON and RDF come from the titles of the columns (the headers in the CSV file). In RDF, since the properties are URIs, the names are URL-encoded and turned into fragment identifiers in a URL based on the location of the CSV file being transformed. Hence in the previous examples there have been property names like <code>"name (en)"</code> in JSON and <code>#name%20%28en%29</code> in RDF.
        </p>
        <p>
          You can override this default by supplying a <a href="https://w3c.github.io/csvw/metadata/#column-name"><code>name</code></a> for the column. That name will be used instead of the title of the column when creating the property. So if you have:
        </p>
        <pre class="example">
{
  "titles": "name (en)",
  "name": "english_name"
}
</pre>
        <p>
          then the property will be called <code>english_name</code> in the JSON output and <code>#english_name</code> in the RDF output.
        </p>
        <p>
          You can also use the <a href="https://w3c.github.io/csvw/metadata/#cell-propertyUrl"><code>propertyUrl</code></a> property to supply a prefixed name or a URL for the property. For example, to use <code>schema:latitude</code> as the name for the <code>latitude</code> property in both the JSON and the RDF output, you could use:
        </p>
        <pre class="example">{
  "titles": "latitude",
  <strong>"propertyUrl": "schema:latitude"</strong>
  "datatype": "number"
}</pre>
        <p>
          The <a href="https://w3c.github.io/csvw/metadata/#cell-propertyUrl"><code>propertyUrl</code></a> property can be used to map several columns in the CSV file onto properties with the same name. In our example, each country has several names which are all really the same property; the schema could look like:
        </p>
        <pre class="example">{
  "titles": "name (en)",
  <strong>"propertyUrl": "schema:name"</strong>
  "lang": "en"
},{
  "titles": "name (fr)",
  <strong>"propertyUrl": "schema:name"</strong>
  "lang": "fr"
},{
  "titles": "name (de)",
  <strong>"propertyUrl": "schema:name"</strong>
  "lang": "de"
}</pre>
        <p>
          With that schema, the JSON output will contain:
        </p>
        <pre class="example">
"schema:name": ["Belgium", "Belgique", "Belgien"]
        </pre>
        <p>
          and the RDF output will contain:
        </p>
        <pre class="example">
schema:name "Belgium"@en, "Belgique"@fr, "Belgien"@de
        </pre>
        <p>
          If there isn't a relevant property in one of the vocabularies that is built-in to CSV on the Web (those listed as part of the <a href="https://www.w3.org/2011/rdfa-context/rdfa-1.1">RDFa 1.1 initial context</a>), the <a href="https://w3c.github.io/csvw/metadata/#cell-propertyUrl"><code>propertyUrl</code></a> can hold a URL template. Usually this template won't include any substitutable parts because it's generally the case that the property should be the same for the whole column. For example, you might have:
        </p>
        <pre class="example">{
  "titles": "country group",
  <strong>"propertyUrl": "https://example.org/def/countryGroup"</strong>
}</pre>
        <p>
          In this case, the result of a transformation to JSON will contain:
        </p>
        <pre class="example">
"https://example.org/def/countryGroup": "eu"
        </pre>
        <p>
          and the RDF similarly:
        </p>
        <pre class="example">
&lt;https://example.org/def/countryGroup&gt; "eu"
        </pre>
        <p>See also:</p>
        <ul>
          <li><a href="#required-values" class="sectionRef"></a></li>
          <li><a href="#column-title-languages" class="sectionRef"></a></li>
          <li><a href="https://w3c.github.io/csvw/metadata/#column-name"><code>name</code> property</a> in [[tabular-metadata]]</li>
          <li><a href="https://w3c.github.io/csvw/metadata/#cell-propertyUrl"><code>propertyUrl</code> property</a> in [[tabular-metadata]]</li>
        </ul>
      </section>
      <section id="value-urls">
        <h2>How do you map values into URLs?</h2>
        <p>
          Sometimes a column contains a value that can be programmatically mapped into a URL. In this case, the <a href="https://w3c.github.io/csvw/metadata/#cell-valueUrl"><code>valueUrl</code></a> property contains a template for the URL that it should be mapped into.
        </p>
        <p>
          For example, say that there were pages for each country on the web at e.g. <code>https://example.org/country/at</code>. In that case, the URL for the country could be generated with the URL template <code>https://example.org/country/{country}</code>. Within this template, <code>{country}</code> inserts the value from the column named <code>country</code> into the URL. So the metadata could contain:
        </p>
        <pre class="example">{
  "titles": "country",
  <strong>"name": "country",
  "valueUrl": "https://example.org/country/{country}",</strong>
  "propertyUrl": "schema:url"
}</pre>
        <p>
          The JSON output would then contain:
        </p>
        <pre class="example">
"schema:url": "https://example.org/country/at"
        </pre>
        <p>
          and the RDF output:
        </p>
        <pre class="example">
schema:url &lt;https://example.org/country/at&gt;
        </pre>
        <p>
          If you want to preserve the original value from the column <em>and</em> use it to create a URL, you may want to introduce a virtual column. For example, with the latitude and longitude of each country available, you might want to provide a link to a map centered on the country within Google Maps. The URLs for these look like <a href="https://www.google.com/maps/@50.501045,4.476674,7z">https://www.google.com/maps/@50.501045,4.476674,7z</a>, and a template like <code>https://www.google.com/maps/@{lat},{long},7z</code>.
        </p>
        <p>
          To add a property that points to this URL, add a virtual column at the end of the column definitions within the schema. A virtual column definition looks just like a normal column definition but with the <a href="https://w3c.github.io/csvw/metadata/#column-virtual"><code>virtual</code></a> property set to <code>true</code>:
        </p>
        <pre class="example">
{
  "@context": "https://www.w3.org/ns/csvw",
  "url": "countries.csv",
  "tableSchema": {
    "columns": [{
      "titles": "country"
    },{
      "titles": "country group"
    },{
      "titles": "name (en)",
      "lang": "en"
    },{
      "titles": "name (fr)",
      "lang": "fr"
    },{
      "titles": "name (de)",
      "lang": "de"
    },{
      "titles": "latitude",
      <strong>"name": "lat",</strong>
      "datatype": "number"
    },{
      "titles": "longitude",
      <strong>"name": "long",</strong>
      "datatype": "number"
    },<strong>{
      "virtual": true,
      "propertyUrl": "schema:hasMap",
      "valueUrl": "https://www.google.com/maps/@{lat},{long},7z"
    }</strong>]
  }
}
</pre>
        <p>
          In JSON, this will result in the output:
        </p>
        <pre class="example">
"schema:hasMap": "https://www.google.com/maps/@42.72567375,25.4823218,7z"
        </pre>
        <p>
          and in RDF, the output:
        </p>
        <pre class="example">
schema:hasMap &lt;https://www.google.com/maps/@42.72567375,25.4823218,7z&gt;
        </pre>
        <p>See also:</p>
        <ul>
          <li><a href="#row-identifiers" class="sectionRef"></a></li>
          <li><a href="#row-types" class="sectionRef"></a></li>
          <li><a href="#nested-structures" class="sectionRef"></a></li>
          <li><a href="#uom-structured-values" class="sectionRef"></a></li>
          <li><a href="https://w3c.github.io/csvw/metadata/#cell-valueUrl"><code>valueUrl</code> property</a> in [[tabular-metadata]]</li>
        </ul>
      </section>
      <section id="row-identifiers">
        <h2>How do you include an identifier for the thing described by each row?</h2>
        <p>
          By default, the things described by each row don't have identifiers associated with them in either JSON or RDF outputs. You can add an identifier for the row by setting the <a href="https://w3c.github.io/csvw/metadata/#cell-aboutUrl"><code>aboutUrl</code></a> property. Usually that's done at the top level of the schema.
        </p>
        <p>
          For example, say each row in <code>countries.csv</code> was about a country whose identifier looked like <code>https://example.org/country/{code}</code> where <code>code</code> was the value within the first column of the CSV file (the <code>country</code> column). The <a href="https://w3c.github.io/csvw/metadata/#cell-aboutUrl"><code>aboutUrl</code></a> could be set to the generate this URL for each row using a URL template:
        </p>
        <pre class="example">
{
  "@context": "https://www.w3.org/ns/csvw",
  "url": "countries.csv",
  "tableSchema": {
    <strong>"aboutUrl": "https://example.org/country/{code}",</strong>
    "columns": [{
      "titles": "country",
      <strong>"name": "code"</strong>
    },{
      "titles": "country group"
    },{
      "titles": "name (en)",
      "lang": "en"
    },{
      "titles": "name (fr)",
      "lang": "fr"
    },{
      "titles": "name (de)",
      "lang": "de"
    },{
      "titles": "latitude",
      "datatype": "number"
    },{
      "titles": "longitude",
      "datatype": "number"
    }]
  }
}
</pre>
        <p>
          In the JSON, these identifiers are turned into <code>@id</code> properties on the objects generated for each row:
        </p>
        <pre class="example">[{
  <strong>"@id": "https: //example.org/country/at",</strong>
  "code": "at",
  "country group": "eu",
  "name (en)": "Austria",
  "name (fr)": "Autriche",
  "name (de)": "Österreich"
},{
  <strong>"@id": "https: //example.org/country/be",</strong>
  "code": "be",
  "country group": "eu",
  "name (en)": "Belgium",
  "name (fr)": "Belgique",
  "name (de)": "Belgien",
  "latitude": 50.501045,
  "longitude": 4.47667405
},{
  <strong>"@id": "https: //example.org/country/bg",</strong>
  "code": "bg",
  "country group": "eu",
  "name (en)": "Bulgaria",
  "name (fr)": "Bulgarie",
  "name (de)": "Bulgarien",
  "latitude": 42.72567375,
  "longitude": 25.4823218
}]</pre>
        <p>
          In the RDF, these identifiers become the identifiers for the entities that the properties relate to, rather than those being blank nodes:
        </p>
        <pre class="example">
@prefix rdf: &lt;https://www.w3.org/1999/02/22-rdf-syntax-ns#&gt; .
@prefix xsd: &lt;https://www.w3.org/2001/XMLSchema#&gt; .

&lt;https://example.org/country/at&gt;
   &lt;#code&gt; "at";
   &lt;#country%20group&gt; "eu";
   &lt;#latitude&gt; 4.76965545e1;
   &lt;#longitude&gt; 1.334598005e1;
   &lt;#name%20%28de%29&gt; "Österreich"@de;
   &lt;#name%20%28en%29&gt; "Austria"@en;
   &lt;#name%20%28fr%29&gt; "Autriche"@fr .

&lt;https://example.org/country/be&gt;
   &lt;#code&gt; "be";
   &lt;#country%20group&gt; "eu";
   &lt;#latitude&gt; 5.0501045e1;
   &lt;#longitude&gt; 4.47667405e0;
   &lt;#name%20%28de%29&gt; "Belgien"@de;
   &lt;#name%20%28en%29&gt; "Belgium"@en;
   &lt;#name%20%28fr%29&gt; "Belgique"@fr .

&lt;https://example.org/country/bg&gt;
   &lt;#code&gt; "bg";
   &lt;#country%20group&gt; "eu";
   &lt;#latitude&gt; 4.272567375e1;
   &lt;#longitude&gt; 2.54823218e1;
   &lt;#name%20%28de%29&gt; "Bulgarien"@de;
   &lt;#name%20%28en%29&gt; "Bulgaria"@en;
   &lt;#name%20%28fr%29&gt; "Bulgarie"@fr .
        </pre>
        <p>See also:</p>
        <ul>
          <li><a href="#value-urls" class="sectionRef"></a></li>
          <li><a href="#row-types" class="sectionRef"></a></li>
          <li><a href="#nested-structures" class="sectionRef"></a></li>
          <li><a href="#uom-structured-values" class="sectionRef"></a></li>
          <li><a href="https://w3c.github.io/csvw/metadata/#cell-aboutUrl"><code>aboutUrl</code> property</a> in [[tabular-metadata]]</li>
        </ul>
      </section>
      <section id="row-types">
        <h2>How do you indicate the type of the thing described by each row?</h2>
        <p>
          Whether generating JSON or RDF it can be useful to indicate that each row contains data about a particular type of thing, such as a Person or a Country. There isn't usually a column within tabular data that indicates the type of the row (because it's generally the same for every row, so including it would be superfluous), so you have to add it as a virtual column.
        </p>
        <p>
          The virtual column needs to come after the descriptions of columns actually within the data. It should have its <a href="https://w3c.github.io/csvw/metadata/#column-virtual"><code>virtual</code></a> property set to <code>true</code> and its <a href="https://w3c.github.io/csvw/metadata/#cell-propertyUrl"><code>propertyUrl</code></a> set to <code>rdf:type</code> to indicate that the virtual column will indicate the type of entity the row is about. The <a href="https://w3c.github.io/csvw/metadata/#cell-valueUrl"><code>valueUrl</code></a> property can then be set to the prefixed name or URL of the type of the entity. For example, when each row represents a Country, you might use:
        </p>
        <pre class="example">{
  "virtual": true,
  "propertyUrl": "rdf:type",
  "valueUrl": "schema:Country"
}</pre>
        <p>
          In the JSON this value will be transformed into the value of the <code>@type</code> property on the relevant object:
        </p>
        <pre class="example">
"@type": "schema:Country"
        </pre>
        <p>
          In RDF output, it becomes the class for the entity:
        </p>
        <pre class="example">
a schema:Country
        </pre>
        <p>See also:</p>
        <ul>
          <li><a href="#nested-structures" class="sectionRef"></a></li>
          <li><a href="https://w3c.github.io/csvw/metadata/#column-virtual"><code>virtual</code> property</a> in [[tabular-metadata]]</li>
          <li><a href="https://w3c.github.io/csvw/syntax/#dfn-virtual-columns">virtual columns</a> in [[tabular-data-model]]</li>
        </ul>
      </section>
      <section id="extra-metadata">
        <h2>How do you include extra metadata in the result of the transformation?</h2>
        <p>
          Transformations into JSON or RDF can be carried out in one of two modes. In minimal mode, which is what we've looked at so far, the output only contains data from the rows within the CSV file. In full mode, the output also contains metadata about the CSV file, including metadata from the metadata file.
        </p>
        <p>
          For example, say that our metadata file looked like:
        </p>
        <pre class="example">
{
  "@context": "https://www.w3.org/ns/csvw",
  "url": "countries.csv",
  <strong>"schema:name": "Countries",
  "schema:description": "European countries for which comparative statistics are collected by Eurostat.",
  "schema:creator": { "schema:name": "Eurostat" },</strong>
  "tableSchema": {
    ...
  }
}
</pre>
        <p>
          The output of a full JSON transformation would look like:
        </p>
        <pre class="example">{
  "tables": [{
    "url":"countries.csv",
    <strong>"schema:name":"Countries",
    "schema:description":"European countries for which comparative statistics are collected by Eurostat.",
    "schema:creator": {
      "schema:name": "Eurostat"
    },</strong>
    "row": [{
      "url": "countries.csv#row=2",
      "rownum":1,
      "describes": [{
        "country": "at",
        "country group": "eu",
        "name (en)": "Austria",
        "name (fr)": "Autriche",
        "name (de)": "Österreich",
        "latitude": 47.6965545,
        "longitude": 13.34598005
      }]
    }, {
      "url": "countries.csv#row=3",
      "rownum": 2,
      "describes": [{
        "country": "be",
        "country group": "eu",
        "name (en)": "Belgium",
        "name (fr)": "Belgique",
        "name (de)": "Belgien",
        "latitude": 50.501045,
        "longitude": 4.47667405
      }]
    }, {
      "url": "countries.csv#row=4",
      "rownum": 3,
      "describes": [{
        "country": "bg",
        "country group": "eu",
        "name (en)": "Bulgaria",
        "name (fr)": "Bulgarie",
        "name (de)": "Bulgarien",
        "latitude": 42.72567375,
        "longitude": 25.4823218
      }]
    }]
  }]
}
        </pre>
        <p>
          Similarly, the output of the full RDF would look like:
        </p>
        <pre class="example">
@prefix csvw: &lt;https://www.w3.org/ns/csvw#&gt; .
@prefix rdf: &lt;https://www.w3.org/1999/02/22-rdf-syntax-ns#&gt; .
@prefix schema: &lt;https://schema.org/&gt; .
@prefix xsd: &lt;https://www.w3.org/2001/XMLSchema#&gt; .

 [
    a csvw:TableGroup;
    csvw:table [
      a csvw:Table;
      <strong>schema:creator [ schema:name "Eurostat" ];
      schema:description "European countries for which comparative statistics are collected by Eurostat.";
      schema:name "Countries";</strong>
      csvw:row [
        a csvw:Row;
        csvw:describes [
          &lt;#country&gt; "at";
          &lt;#country%20group&gt; "eu";
          &lt;#latitude&gt; 4.76965545e1;
          &lt;#longitude&gt; 1.334598005e1;
          &lt;#name%20%28de%29&gt; "Österreich"@de;
          &lt;#name%20%28en%29&gt; "Austria"@en;
          &lt;#name%20%28fr%29&gt; "Autriche"@fr
        ];
        csvw:rownum 1;
        csvw:url &lt;#row=2&gt;
      ],  [
        a csvw:Row;
        csvw:describes [
          &lt;#country&gt; "be";
          &lt;#country%20group&gt; "eu";
          &lt;#latitude&gt; 5.0501045e1;
          &lt;#longitude&gt; 4.47667405e0;
          &lt;#name%20%28de%29&gt; "Belgien"@de;
          &lt;#name%20%28en%29&gt; "Belgium"@en;
          &lt;#name%20%28fr%29&gt; "Belgique"@fr
        ];
        csvw:rownum 2;
        csvw:url &lt;#row=3&gt;
      ],  [
        a csvw:Row;
        csvw:describes [
          &lt;#country&gt; "bg";
          &lt;#country%20group&gt; "eu";
          &lt;#latitude&gt; 4.272567375e1;
          &lt;#longitude&gt; 2.54823218e1;
          &lt;#name%20%28de%29&gt; "Bulgarien"@de;
          &lt;#name%20%28en%29&gt; "Bulgaria"@en;
          &lt;#name%20%28fr%29&gt; "Bulgarie"@fr
        ];
        csvw:rownum 3;
        csvw:url &lt;#row=4&gt;
      ];
      csvw:url &lt;&gt;
    ]
 ] .
        </pre>
        <p>
          Metadata provided about tables is interpreted based on the rules for [[json-ld]] which means that you can provide as much structure within that metadata as you like, including providing structured values, languages and datatypes, so that the data in the output includes what you need it to.
        </p>
        <p>See also:</p>
        <ul>
          <li><a href="#documentation" class="sectionRef"></a></li>
          <li><a href="#structured-metadata" class="sectionRef"></a></li>
          <li><a href="#data-cube" class="sectionRef"></a></li>
          <li><a href="#multilingual-metadata" class="sectionRef"></a></li>
          <li><a href="https://w3c.github.io/csvw/metadata/#common-properties">Common Properties</a> in [[tabular-metadata]]</li>
          <li><a href="https://www.w3.org/TR/csv2json/#standard-mode">Standard Mode</a> in [[csv2json]]</li>
          <li><a href="https://w3c.github.io/csvw/csv2rdf/#conversion">Converting Tabular Data to RDF</a> in [[csv2rdf]]</li>
        </ul>
      </section>
      <section id="suppressing-output">
        <h2>How can you remove output from a transformation result?</h2>
        <p>
          By default, the output from a JSON or RDF transformation will include all the data from all the columns of all the tables in the metadata document. It may be that you're not interested in some of that within the output of your transformation. In that case, you can use the <a href="https://w3c.github.io/csvw/metadata/#column-suppressOutput"><code>suppressOutput</code></a> property in the metadata to exclude the data that you're not interested in.
        </p>
        <p>
          For example, perhaps I'm not interested in the non-English names of countries in my output. In that case, I could suppress them as follows:
        </p>
        <pre class="example">{
  "titles": "name (fr)",
  "lang": "fr",
  <strong>"suppressOutput": true</strong>
}</pre>
        <p>
          Similarly, when generating the output for a set of tables, you can suppress the output from a whole table by adding the <a href="https://w3c.github.io/csvw/metadata/#table-suppressOutput"><code>suppressOutput</code></a> property to the description of that table:
        </p>
        <pre class="example">
{
  "@context": "https://www.w3.org/ns/csvw",
  "tables": [{
    "url": "countries.csv"
  }, {
    "url": "country-groups.csv",
    <strong>"suppressOutput": true</strong>
  }, {
    "url": "unemployment.csv"
  }]
}</pre>
        <p>See also:</p>
        <ul>
          <li><a href="#nested-structures" class="sectionRef"></a></li>
          <li><a href="https://w3c.github.io/csvw/metadata/#column-suppressOutput"><code>suppressOutput</code> property for columns</a> in [[tabular-metadata]]</li>
          <li><a href="https://w3c.github.io/csvw/metadata/#table-suppressOutput"><code>suppressOutput</code> property for tables</a> in [[tabular-metadata]]</li>
        </ul>
      </section>
      <section id="nested-structures">
        <h2>How do you transform into nested structures in JSON?</h2>
        <p>
          While tabular data is by necessity flat, it often holds data that is actually structured. For example, the data that we have been looking at:
        </p>
        <pre class="example">
"country","country group","name (en)","name (fr)","name (de)","latitude","longitude"
"at","eu","Austria","Autriche","Österreich","47.6965545","13.34598005"
"be","eu","Belgium","Belgique","Belgien","50.501045","4.47667405"
"bg","eu","Bulgaria","Bulgarie","Bulgarien","42.72567375","25.4823218"
</pre>
        <p>
          if modelled according to the <a href="https://schema.org">schema.org</a> vocabulary, would look like:
        </p>
        <pre class="example">[{
  "@type": "schema:Country",
  "schema:name": ["Austria", "Autriche", "Österreich"],
  "schema:geo": {
    "@type": "schema:GeoCoordinates",
    "schema:latitude":47.6965545,
    "schema:longitude":13.34598005
  }
}, {
  "@type": "schema:Country",
  "schema:name": ["Belgium", "Belgique", "Belgien"],
  "schema:geo": {
    "@type": "schema:GeoCoordinates",
    "schema:latitude":50.501045,
    "schema:longitude":4.47667405
  }
}, {
  "@type": "schema:Country",
  "schema:name": ["Bulgaria", "Bulgarie", "Bulgarien"],
  "schema:geo": {
    "@type": "schema:GeoCoordinates",
    "schema:latitude":42.72567375,
    "schema:longitude":25.4823218
  }
}]</pre>
        <p>
          Generating JSON in this shape requires the judicious use of virtual columns, <a href="https://w3c.github.io/csvw/metadata/#cell-aboutUrl"><code>aboutUrl</code></a> and <a href="https://w3c.github.io/csvw/metadata/#cell-valueUrl"><code>valueUrl</code></a>: if you create a column whose <a href="https://w3c.github.io/csvw/metadata/#cell-valueUrl"><code>valueUrl</code></a> corresponds to the <a href="https://w3c.github.io/csvw/metadata/#cell-aboutUrl"><code>aboutUrl</code></a> of another column, you will create nested properties.
        </p>
        <p>
          In this example, we can use two <a href="https://w3c.github.io/csvw/metadata/#cell-aboutUrl"><code>aboutUrl</code></a>s: one in the form <code>https://example.org/country/{code}</code> for the Country and one in the form <code>https://example.org/country/{code}#geo</code> for the geo-coordinates of the country. The names are properties of the former while the longitude and latitude are properties of the latter. A virtual column can add the association between the two objects, with a <a href="https://w3c.github.io/csvw/metadata/#cell-propertyUrl"><code>propertyUrl</code></a> of <code>schema:geo</code>, like so:
        </p>
        <pre class="example">
{
  "@context": "https://www.w3.org/ns/csvw",
  "url": "countries.csv",
  "tableSchema": {
    "aboutUrl": "https://example.org/country/{code}",
    "columns": [{
      "titles": "country",
      "name": "code",
      "suppressOutput": true
    },{
      "titles": "country group",
      "suppressOutput": true
    },{
      "titles": "name (en)",
      "lang": "en",
      "propertyUrl": "schema:name"
    },{
      "titles": "name (fr)",
      "lang": "fr",
      "propertyUrl": "schema:name"
    },{
      "titles": "name (de)",
      "lang": "de",
      "propertyUrl": "schema:name"
    },{
      "titles": "latitude",
      "datatype": "number",
      <strong>"aboutUrl": "https://example.org/country/{code}#geo",</strong>
      "propertyUrl": "schema:latitude"
    },{
      "titles": "longitude",
      "datatype": "number",
      <strong>"aboutUrl": "https://example.org/country/{code}#geo",</strong>
      "propertyUrl": "schema:longitude"
    },{
      "virtual": true,
      "propertyUrl": "rdf:type",
      "valueUrl": "schema:Country"
    },<strong>{
      "virtual": true,
      "propertyUrl": "schema:geo",
      "valueUrl": "https://example.org/country/{code}#geo"
    }</strong>,{
      "virtual": true,
      "aboutUrl": "https://example.org/country/{code}#geo",
      "propertyUrl": "rdf:type",
      "valueUrl": "schema:GeoCoordinates"
    }]
  }
}</pre>
        <p class="note">
          Note also in this example the use of <a href="https://w3c.github.io/csvw/metadata/#column-suppressOutput"><code>suppressOutput</code></a> to remove properties that we're not interested in, and the use of virtual columns to add type information to both types of generated object.
        </p>
        <p>
          The result of this transformation is close to what we were aiming for, though with the addition of <code>@id</code> properties:
        </p>
        <pre class="example">[{
  "@id": "https://example.org/country/at",
  "@type": "schema:Country",
  "schema:name": ["Austria", "Autriche", "Österreich"],
  "schema:geo": {
    "@id": "https://example.org/country/at#geo",
    "@type": "schema:GeoCoordinates",
    "schema:latitude": 47.6965545,
    "schema:longitude": 13.34598005
  }
}, {
  "@id": "https://example.org/country/be",
  "@type": "schema:Country",
  "schema:name": ["Belgium", "Belgique", "Belgien"],
  "schema:geo": {
    "@id":"https://example.org/country/be#geo",
    "@type": "schema:GeoCoordinates",
    "schema:latitude": 50.501045,
    "schema:longitude": 4.47667405
  }
}, {
  "@id": "https://example.org/country/bg",
  "@type": "schema:Country",
  "schema:name": ["Bulgaria", "Bulgarie", "Bulgarien"],
  "schema:geo": {
    "@id": "https://example.org/country/bg#geo",
    "@type": "schema:GeoCoordinates",
    "schema:latitude": 42.72567375,
    "schema:longitude": 25.4823218
  }
}]</pre>
        <p>
          The same metadata will generate similar RDF, though the nesting structure is not so obvious because of the way RDF works:
        </p>
        <pre class="example">
@prefix rdf: &lt;https://www.w3.org/1999/02/22-rdf-syntax-ns#&gt; .
@prefix schema: &lt;https://schema.org/&gt; .
@prefix xsd: &lt;https://www.w3.org/2001/XMLSchema#&gt; .

&lt;https://example.org/country/at&gt; a schema:Country;
   schema:geo &lt;https://example.org/country/at#geo&gt;;
   schema:name "Austria"@en, "Autriche"@fr, "Österreich"@de .

&lt;https://example.org/country/be&gt; a schema:Country;
   schema:geo &lt;https://example.org/country/be#geo&gt;;
   schema:name "Belgium"@en, "Belgique"@fr, "Belgien"@de .

&lt;https://example.org/country/bg&gt; a schema:Country;
   schema:geo &lt;https://example.org/country/bg#geo&gt;;
   schema:name "Bulgaria"@en, "Bulgarie"@fr, "Bulgarien"@de .

&lt;https://example.org/country/at#geo&gt; a schema:GeoCoordinates;
   schema:latitude 4.76965545e1;
   schema:longitude 1.334598005e1 .

&lt;https://example.org/country/be#geo&gt; a schema:GeoCoordinates;
   schema:latitude 5.0501045e1;
   schema:longitude 4.47667405e0 .

&lt;https://example.org/country/bg#geo&gt; a schema:GeoCoordinates;
   schema:latitude 4.272567375e1;
   schema:longitude 2.54823218e1 .
           </pre>
        <p>See also:</p>
        <ul>
          <li><a href="#value-urls" class="sectionRef"></a></li>
          <li><a href="#row-identifiers" class="sectionRef"></a></li>
          <li><a href="#row-types" class="sectionRef"></a></li>
          <li><a href="#suppressing-output" class="sectionRef"></a></li>
          <li><a href="#data-cube" class="sectionRef"></a></li>
          <li><a href="#uom-structured-values" class="sectionRef"></a></li>
          <li><a href="https://www.w3.org/TR/csv2json/#nesting-objects">Generating Nested Objects</a> in [[csv2json]]</li>
        </ul>
      </section>
      <section id="list-values">
        <h2>How do you indicate that values should be mapped to a list rather than repeating properties in RDF?</h2>
        <p>
          If you are used to using RDF you'll know that there's a big difference between having a property that has multiple values (ie multiple triples with the same subject and property) and a property that has a <code>rdf:List</code> as a value. Sometimes one is appropriate, sometimes the other. The <a href="https://w3c.github.io/csvw/metadata/#cell-ordered"><code>ordered</code></a> property enables you to indicate which to use for values that are sequences in the original data.
        </p>
        <p>
          Let's use as an example the version of our data in which the latitude and longitude are in the same property:
        </p>
        <pre class="example">
"country","country group","name (en)","name (fr)","name (de)","latlong"
"at","eu","Austria","Autriche","Österreich","47.6965545 13.34598005"
"be","eu","Belgium","Belgique","Belgien","50.501045 4.47667405"
"bg","eu","Bulgaria","Bulgarie","Bulgarien","42.72567375 25.4823218"
</pre>
        <p>
          In this example, if we state that the <code>latlong</code> column is space-separated like so:
        </p>
        <pre class="example">{
  "titles": "latlong",
  <strong>"separator": " ",</strong>
  "datatype": "number"
}</pre>
        <p>
          we'll end up with output like this:
        </p>
        <pre class="example">[
  &lt;#country&gt; "at";
  &lt;#country%20group&gt; "eu";
  &lt;#name%20%28en%29&gt; "Austria"@en;
  &lt;#name%20%28fr%29&gt; "Autriche"@fr;
  &lt;#name%20%28de%29&gt; "Österreich"@de;
  <strong>&lt;#latlong&gt; 4.76965545e1, 1.334598005e1;</strong>
] .</pre>
        <p>
          This shows the <code>#latlong</code> property having two values: <code>4.76965545e1</code> and <code>1.334598005e1</code>. These values could easily get mixed up such that the first was taken to be the longitude and the second the latitude rather than the other way around.
        </p>
        <p>
          To avoid this mix-up occurring, set the <a href="https://w3c.github.io/csvw/metadata/#cell-ordered"><code>ordered</code></a> property to <code>true</code>:
        </p>
        <pre class="example">{
  "titles": "latlong",
  "separator": " ",
  <strong>"ordered": true,</strong>
  "datatype": "number"
}</pre>
        <p>
          This will make the processor use a <code>rdf:List</code> for the value of the <code>#latlong</code> property instead, which in Turtle looks like:
        </p>
        <pre class="example">[
  &lt;#country&gt; "at";
  &lt;#country%20group&gt; "eu";
  &lt;#name%20%28en%29&gt; "Austria"@en;
  &lt;#name%20%28fr%29&gt; "Autriche"@fr;
  &lt;#name%20%28de%29&gt; "Österreich"@de;
  <strong>&lt;#latlong&gt; ( 4.76965545e1, 1.334598005e1 );</strong>
] .</pre>
        <p class="note">
          The <a href="https://w3c.github.io/csvw/metadata/#cell-ordered"><code>ordered</code></a> property makes no difference to JSON output because sequences in CSV are always transformed into arrays in JSON.
        </p>
        <p>See also:</p>
        <ul>
          <li><a href="#sequence-values" class="sectionRef"></a></li>
          <li><a href="https://w3c.github.io/csvw/metadata/#cell-ordered"><code>ordered</code> property</a> in [[tabular-metadata]]</li>
        </ul>
      </section>
      <section id="json-ld">
        <h2>How should you transform CSV into JSON-LD?</h2>
        <p>
          As illustrated above, it is possible to transform CSV into something that looks like JSON-LD by transforming it into JSON. You can add <code>@id</code> properties for identifiers using <a href="https://w3c.github.io/csvw/metadata/#cell-aboutUrl"><code>aboutUrl</code></a> and add <code>@type</code> properties for types using virtual columns.
        </p>
        <p>
          However, if you're really after JSON-LD as an output, the best route is to transform into RDF and emit that RDF as JSON-LD. This will give you more control over the context that's used to determine the properties and structure of the output.
        </p>
        <p>See also:</p>
        <ul>
          <li><a href="#row-identifiers" class="sectionRef"></a></li>
          <li><a href="#row-types" class="sectionRef"></a></li>
          <li><a href="https://w3c.github.io/csvw/csv2rdf/#conversion">Converting Tabular Data to RDF</a> in [[csv2rdf]]</li>
        </ul>
      </section>
      <section id="html-display">
        <h2>How should you display CSV tables in HTML?</h2>
        <p>
          There's no single specified way of displaying CSV tables in HTML. If you are writing code to do so, it's good practice to:
        </p>
        <ul>
          <li>use the locale of the user of the browser to determine which titles to display for columns, and how to format numbers and dates within the table</li>
          <li>respect the directionality of the table and the text within the table that's indicated through the <a href="https://w3c.github.io/csvw/metadata/#tableDirection"><code>tableDirection</code></a> and <a href="https://w3c.github.io/csvw/metadata/#cell-textDirection"><code>textDirection</code></a> properties</li>
          <li>use the <a href="https://w3c.github.io/csvw/metadata/#cell-aboutUrl"><code>aboutUrl</code></a> and <a href="https://w3c.github.io/csvw/metadata/#cell-valueUrl"><code>valueUrl</code></a> properties to link out to other pages from cells within the table, and the <a href="https://w3c.github.io/csvw/metadata/#cell-propertyUrl"><code>propertyUrl</code></a> to link out to information about the property a column represents; these properties could also be used to embed RDFa into the HTML table, as described in [[html-rdfa]]</li>
          <li>display the metadata that's available about the table so that people get a full idea of the context of the data</li>
          <li>provide a way to access notes and annotations that have been provided about individual cells, rows or columns</li>
          <li>highlight cells that contain errors so that they're easy to spot and correct</li>
          <li>provide links to other related resources indicated through the metadata supplied for the table</li>
          <li>keep columns that are used to provide a title for each row (using <a href="https://w3c.github.io/csvw/metadata/#schema-rowTitles"><code>rowTitles</code></a>) visible; for screen readers, use these to label the rows so that people can navigate through the table easily</li>
          <li>link out to the original CSV file so that people can download it</li>
        </ul>
        <p>See also:</p>
        <ul>
          <li><a href="#documentation" class="sectionRef"></a></li>
          <li><a href="#cell-annotations" class="sectionRef"></a></li>
          <li><a href="#value-urls" class="sectionRef"></a></li>
          <li><a href="#row-identifiers" class="sectionRef"></a></li>
          <li><a href="#column-title-languages" class="sectionRef"></a></li>
          <li><a href="#column-language" class="sectionRef"></a></li>
          <li><a href="#table-direction" class="sectionRef"></a></li>
          <li><a href="#row-titles" class="sectionRef"></a></li>
          <li><a href="https://w3c.github.io/csvw/syntax/#presenting-tables">Presenting Tables</a> in [[tabular-data-model]]</li>
        </ul>
      </section>
      <section id="data-cube">
        <h2>How can you transform CSV into the DataCube vocabulary?</h2>
        <p>
          The Data Cube vocabulary [[vocab-data-cube]] is a vocabulary for statistical data based on <a href="https://sdmx.org/">SDMX</a> (Statistical Data and Metadata eXchange). Statistical data is often expressed in tables, sometimes with one row per Observation and sometimes with each cell containing a different Observation.
        </p>
        <p>
          Generating data in the Data Cube vocabulary requires the use of techniques that have been described above, such as adding identifiers to entities, adding structure and types through virtual columns, and using metadata to supply additional static context.
        </p>
        <p>
          There is a <a href="https://github.com/w3c/csvw/blob/gh-pages/examples/rdf-data-cube-example.md">fully worked out example</a> of transforming to DataCube, using meterological data as its basis, available on the Github repository for the Working Group.
        </p>
        <p>See also:</p>
        <ul>
          <li><a href="#cell-annotations" class="sectionRef"></a></li>
          <li><a href="#value-urls" class="sectionRef"></a></li>
          <li><a href="#row-identifiers" class="sectionRef"></a></li>
          <li><a href="#row-types" class="sectionRef"></a></li>
          <li><a href="#extra-metadata" class="sectionRef"></a></li>
          <li><a href="#nested-structures" class="sectionRef"></a></li>
          <li><a href="https://github.com/w3c/csvw/blob/gh-pages/examples/rdf-data-cube-example.md">Generating Data Cube Example</a></li>
        </ul>
      </section>
      <section id="extension-transformations">
        <h2>How can you transform CSV into other formats?</h2>
        <p>
          While there are only specifications for transforming CSV into JSON and RDF, there is an extension mechanism within CSV metadata to indicate other transformations that could be applied to CSV files. The <a href="https://w3c.github.io/csvw/metadata/#table-transformations"><code>transformations</code></a> property on a table description holds an array of descriptions of transformations that processors could carry out. There's no guarantees that a given processor will recognise them, but over time it might be that there begins to be recognised practices for how such transformations might work.
        </p>
        <p>
          The transformations must have the following properties:
        </p>
        <dl>
          <dt><a href="https://w3c.github.io/csvw/metadata/#transformation-targetFormat"><code>targetFormat</code></a></dt>
          <dd>gives a URL for the format that the transformation transforms into, for example <code>https://www.iana.org/assignments/media-types/application/xml</code> for XML</dd>
          <dt><a href="https://w3c.github.io/csvw/metadata/#transformation-url"><code>url</code></a></dt>
          <dd>points to a script or template that can be used to transform the CSV into that format</dd>
          <dt><a href="https://w3c.github.io/csvw/metadata/#transformation-scriptFormat"><code>scriptFormat</code></a></dt>
          <dd>gives a URL for the format that the script is in, for example <code>https://mustache.github.io/</code> for Mustache or <code>https://www.iana.org/assignments/media-types/application/javascript</code> for Javascript</li>
        </dl>
        <p>
          You can also supply a <a href="https://w3c.github.io/csvw/metadata/#transformation-title"><code>titles</code></a> property to provide a human-readable description of the output of the transformation, and a <a href="https://w3c.github.io/csvw/metadata/#transformation-source"><code>source</code></a> property to indicate that the <em>input</em> to the transformation isn't the original CSV or tabular data, but <code>json</code> or <code>rdf</code>.
        </p>
        <p>
          For example, if I wanted to convert the data that we've been using into XML, I could create a Mustache template like this at <code>xml-template.mustache</code>:
        </p>
        <pre class="example">
{{#tables}}
  &lt;countries&gt;
    {{#row}}
      {{#describes}}
        &lt;country id="{{country}}" group="{{country_group}}"&gt;
          &lt;name xml:lang="en"&gt;{{name_en}}&lt;/name&gt;
          &lt;name xml:lang="fr"&gt;{{name_fr}}&lt;/name&gt;
          &lt;name xml:lang="de"&gt;{{name_de}}&lt;/name&gt;
          &lt;geo lat="{{latitude}}" long="{{longitude}}" /&gt;
        &lt;/country&gt;
      {{/describes}}
    {{/row}}
  &lt;/countries&gt;
{{/tables}}
</pre>
        <p>
          In the metadata for the CSV file I could then include:
        </p>
        <pre class="example">{
  "@context": "https://www.w3.org/ns/csvw",
  "url": "countries.csv",
  "transformations": [{
    "targetFormat": "https://www.iana.org/assignments/media-types/application/xml",
    "titles": "Simple XML version",
    "url": "xml-template.mustache",
    "scriptFormat": "https://mustache.github.io/",
    "source": "json"
  }]
}</pre>
        <p>
          Processors that recognised the URL for Mustache could offer users the option of passing the JSON output to a Mustache processor, which would generate:
        </p>
        <pre class="example">
&lt;countries&gt;
  &lt;country id="at" group="eu"&gt;
    &lt;name xml:lang="en"&gt;Austria&lt;/name&gt;
    &lt;name xml:lang="fr"&gt;Autriche&lt;/name&gt;
    &lt;name xml:lang="de"&gt;Österreich&lt;/name&gt;
    &lt;geo lat="47.6965545" long="13.34598005" /&gt;
  &lt;/country&gt;
  &lt;country id="be" group="eu"&gt;
    &lt;name xml:lang="en"&gt;Belgium&lt;/name&gt;
    &lt;name xml:lang="fr"&gt;Belgique&lt;/name&gt;
    &lt;name xml:lang="de"&gt;Belgien&lt;/name&gt;
    &lt;geo lat="50.501045" long="4.47667405" /&gt;
  &lt;/country&gt;
  &lt;country id="bg" group="eu"&gt;
    &lt;name xml:lang="en"&gt;Bulgaria&lt;/name&gt;
    &lt;name xml:lang="fr"&gt;Bulgarie&lt;/name&gt;
    &lt;name xml:lang="de"&gt;Bulgarien&lt;/name&gt;
    &lt;geo lat="42.72567375" long="25.4823218" /&gt;
  &lt;/country&gt;
&lt;/countries&gt;
        </pre>
        <p>
          Processors should document the kind of transformation scripts that they can recognise and how they process them.
        </p>
        <p>See also:</p>
        <ul>
          <li><a href="#extra-metadata" class="sectionRef"></a></li>
          <li><a href="https://w3c.github.io/csvw/metadata/#transformation-definitions">Transformation Definitions</a> in [[tabular-metadata]]</li>
        </ul>
      </section>
    </section>
    <section>
      <h1>Handling language in CSVs</h1>
      <p>
        There are a number of features in the CSV on the Web metadata documents that support scenarios encountered in CSV files that use different languages. We already discussed using varying number formats in <a href="#number-format" class="sectionRef"></a> and date formats in <a href="#date-format" class="sectionRef"></a>. Here we'll look at how to create metadata files, schemas and CSV files that take account of and work across multiple languages.
      </p>
      <section id="metadata-language">
        <h2>How do you indicate the language used by the metadata file?</h2>
        <p>
          The metadata file will often contain natural language text, such as titles and descriptions of columns and tables. Unless you specify otherwise, implementations will assume all this text is in an undefined language (<code>und</code>). If you want to specify what natural language is in use within the metadata file, you have to change the way the <code>@context</code> is specified. Instead of the normal value:
        </p>
        <pre class="example">
"@context": "https://www.w3.org/ns/csvw"
</pre>
        <p>
          The <code>@context</code> should take an array, where the first value is the usual URL as a string and the second is an object with a <code>@language</code> property set to the language being used within the metadata file. This example, which has English-language titles and descriptions, illustrates:
        </p>
        <pre class="example">
{
  <strong>"@context": [ "https://www.w3.org/ns/csvw", { "@language": "en "} ],</strong>
  "dc:title": "Countries"
  "url": "countries.csv"
  "tableSchema": {
    "columns": [{
      "titles": "country",
      "dc:description": "The ISO two-letter code for a country, in lowercase."
    },{
      "titles": "country group",
      "dc:description": "A lowercase two-letter code for a group of countries."
    },{
      "titles": "name (en)",
      "dc:description": "The official name of the country in English."
    },{
      "titles": "name (fr)",
      "dc:description": "The official name of the country in French."
    },{
      "titles": "name (de)",
      "dc:description": "The official name of the country in German."
    },{
      "titles": "latitude",
      "dc:description": "The latitude of an indicative point in the country."
    },{
      "titles": "longitude",
      "dc:description": "The longitude of an indicative point in the country."
    }]
  }
}
</pre>
        <p>See also:</p>
        <ul>
          <li><a href="#metadata" class="sectionRef"></a></li>
          <li><a href="#extra-metadata" class="sectionRef"></a></li>
          <li><a href="https://w3c.github.io/csvw/metadata/#context-language">default language</a> in [[tabular-metadata]]</li>
        </ul>
      </section>
      <section id="multilingual-metadata">
        <h2>How do you provide metadata such as descriptions in different languages?</h2>
        <p>
          Metadata such as descriptions can be objects rather than strings. Using objects is useful when you want to provide the language for a value. In this case, the object should have two properties: a <code>@value</code> property holding the natural-language string and a <code>@lang</code> value indicating what language that string is in. For example:
        </p>
        <pre class="example">
{
  "titles": "name (en)",
  "dc:description": <strong>{
    "@value": "The official name of the country in English.",
    "@lang": "en"
  }</strong>
}</pre>
        <p>
          You can use an array to provide the same metadata in many different languages, for example:
        </p>
        <pre class="example">
"dc:title": [{
  "@lang": "en",
  "@value": "Unemployment in Europe (monthly)"
},{
  "@lang": "de",
  "@value": "Arbeitslosigkeit in Europa (monatlich)"
},{
  "@lang": "fr",
  "@value": "Le Chômage en Europe (mensuel)"
}]
        </pre>
        <p class="note">
          If you don't indicate the language used for metadata, processors will assume it's the default language used in the metadata as a whole.
        </p>
        <p>See also:</p>
        <ul>
          <li><a href="#metadata-language" class="sectionRef"></a></li>
          <li><a href="#extra-metadata" class="sectionRef"></a></li>
          <li><a href="https://w3c.github.io/csvw/metadata/#values-of-common-properties">Values of Common Properties</a> in [[tabular-metadata]]</li>
        </ul>
      </section>
      <section id="column-title-languages">
        <h2>How do you provide titles for columns in different languages?</h2>
        <p>
          You can use an object as the value for the <a href="https://w3c.github.io/csvw/metadata/#column-titles"><code>titles</code></a> property for a column to provide titles in different languages. Within the object, each property is a language and the value is the title in that language:
        </p>
        <pre class="example">
"titles": {
  "en": "Country",
  "de": "Land",
  "fr": "Pays"
}</pre>
        <p class="note">
          If you don't indicate the language used for the title of a column, processors will assume it's the default language used in the metadata as a whole.
        </p>
        <p>See also:</p>
        <ul>
          <li><a href="#html-display" class="sectionRef"></a></li>
          <li><a href="#shared-schemas" class="sectionRef"></a></li>
          <li><a href="https://w3c.github.io/csvw/metadata/#natural-language-properties">Natural Language Properties</a> in [[tabular-metadata]]</li>
        </ul>
      </section>
      <section id="column-language">
        <h2>How do you specify the language of the values in a column?</h2>
        <p>
          Within an individual CSV file, it may be that different columns contain values that are in different languages. In the example we're using, there are three columns that each contain the name of a country, in English, French and German:
        </p>
        <pre class="example">
"country","country group","name (en)","name (fr)","name (de)","latlong"
"at","eu","Austria","Autriche","Österreich","47.6965545 13.34598005"
"be","eu","Belgium","Belgique","Belgien","50.501045 4.47667405"
"bg","eu","Bulgaria","Bulgarie","Bulgarien","42.72567375 25.4823218"
</pre>
        <p>
          Use the <a href="https://w3c.github.io/csvw/metadata/#cell-language"><code>lang</code></a> property on the column description to indicate the language of text in that column:
        </p>
        <pre class="example">
{
  <strong>"@context": [ "https://www.w3.org/ns/csvw", { "@language": "en "} ],</strong>
  "dc:title": "Countries"
  "url": "countries.csv"
  "tableSchema": {
    "columns": [{
      "titles": "country",
      "dc:description": "The ISO two-letter code for a country, in lowercase."
    },{
      "titles": "country group",
      "dc:description": "A lowercase two-letter code for a group of countries."
    },{
      "titles": "name (en)",
      "dc:description": "The official name of the country in English.",
      <strong>"lang": "en"</strong>
    },{
      "titles": "name (fr)",
      "dc:description": "The official name of the country in French.",
      <strong>"lang": "fr"</strong>
    },{
      "titles": "name (de)",
      "dc:description": "The official name of the country in German.",
      <strong>"lang": "de"</strong>
    },{
      "titles": "latitude",
      "dc:description": "The latitude of an indicative point in the country."
    },{
      "titles": "longitude",
      "dc:description": "The longitude of an indicative point in the country."
    }]
  }
}
</pre>
        <p class="note">
          There's no relationship between the language used in a metadata file and that used in the CSV file that it describes.
        </p>
        <p>See also:</p>
        <ul>
          <li><a href="#transformation-values" class="sectionRef"></a></li>
          <li><a href="#html-display" class="sectionRef"></a></li>
          <li><a href="https://w3c.github.io/csvw/metadata/#cell-language"><code>lang</code> property</a> in [[tabular-metadata]]</li>
        </ul>
      </section>
      <section id="table-direction">
        <h2>How do you indicate that tables should be displayed right-to-left?</h2>
        <p>
          Implementations that display tables according to the specs should mostly be able to guess whether a table should be displayed left-to-right or right-to-left based on the content of the table. Implementations will look at the content of the cells to work out which way to display their content and will look at the content of the table as a whole to work out whether to display the first column on the right or left of the page.
        </p>
        <p>
          If you want to override the display of a particular column then you can use the <a href="https://w3c.github.io/csvw/metadata/#cell-textDirection"><code>textDirection</code></a> property on a column description to explicitly be <code>rtl</code> or <code>ltr</code>:
        </p>
        <pre class="example">
{
  "titles": "name (ar)",
  "lang": "ar",
  <strong>"textDirection": "rtl"</strong>
}
        </pre>
        <p>
          If you want to override the display of the table overall then you can use the <a href="https://w3c.github.io/csvw/metadata/#tableDirection"><code>tableDirection</code></a> property on the description of the table, or for all tables in the group.
        </p>
        <pre class="example">
{
  <strong>"@context": "https://www.w3.org/ns/csvw",</strong>
  "url": "results.csv",
  <strong>"tableDirection": "rtl"</strong>
}
</pre>
        <p>
          The value of the <a href="https://w3c.github.io/csvw/metadata/#tableDirection"><code>tableDirection</code></a> property is inherited to all columns in the table, so any text within this table will similarly be displayed right-to-left. This can be overridden by setting <a href="https://w3c.github.io/csvw/metadata/#cell-textDirection"><code>textDirection</code></a> to <code>ltr</code> or <code>auto</code> (in which case the direction of the text within each cell will be determined by its contents).
        </p>
        <p>See also:</p>
        <ul>
          <li><a href="#html-display" class="sectionRef"></a></li>
          <li><a href="https://w3c.github.io/csvw/metadata/#cell-textDirection"><code>textDirection</code> property</a> in [[tabular-metadata]]</li>
          <li><a href="https://w3c.github.io/csvw/metadata/#tableDirection"><code>tableDirection</code> property</a> in [[tabular-metadata]]</li>
          <li><a href="https://w3c.github.io/csvw/syntax/#bidirectional-tables">Bidirectional Tables</a> in [[tabular-data-model]]</li>
        </ul>
      </section>
    </section>
    <section>
      <h1>Advanced Use</h1>
      <section id="units-of-measure">
        <h2>How do you support units of measure?</h2>
        <p>
          There is no native support for expressing the units of measure for a particular column. You can, however, use documentation to tell people who are using the data what unit of measure is used for that particular column. This can be informal within the description of the column:
        </p>
        <pre class="example">
{
  "titles": "distance",
  "dc:description": "Distance (kilometres)"
}</pre>
        <p>
          Alternatively, it can be more explicit using an existing units-of-measure property and vocabulary, such as:
        </p>
        <pre class="example">
{
  "titles": "distance",
  "https://purl.org/linked-data/sdmx/2009/attribute#unitMeasure": {
    "@id": "https://qudt.org/vocab/unit#Kilometer"
  }
}</pre>
        <p>
          to which you could even add more detail if you wanted (this is replicating the canonical definition of <a href="https://qudt.org/1.1/vocab/OVG_units-qudt-(v1.1).ttl">definition of <code>unit:Kilometer</code></a> from the <a href="https://qudt.org/">Quanitites, Units, Dimensions and Data Types (QUDT) Ontologies</a>):
        </p>
        <pre class="example">
 {
  "titles": "distance",
  "https://purl.org/linked-data/sdmx/2009/attribute#unitMeasure": {
    "@id": "https://qudt.org/vocab/unit#Kilometre",
    "@type": [
      "https://qudt.org/schema/qudt#SIUnit",
      "https://qudt.org/schema/qudt#DerivedUnit",
      "https://qudt.org/schema/qudt#LengthUnit"
    ],
    "rdfs:label": "Kilometer",
    "https://qudt.org/schema/qudt#abbreviation": "km",
    "https://qudt.org/schema/qudt#code": "1091",
    "https://qudt.org/schema/qudt#conversionMultiplier": 1000,
    "https://qudt.org/schema/qudt#conversionOffset": 0.0,
    "https://qudt.org/schema/qudt#symbol": "km",
    "skos:exactMatch": { "@id": "https://dbpedia.org/resource/Kilometre" }
  }
}       </pre>
        <section id="uom-structured-values">
          <h3>Supporting units of measure by transforming to structured values</h3>
          <p>
            If you are generating JSON or RDF from CSV, you may want to generate structured values that include the units of each value from the CSV file. This is a little complicated, but useful if different rows contain values that use different units. In this case, the output that you're aiming for in RDF would look something like:
          </p>
          <pre class="example">
[] :distance &lt;#row-1-distance&gt; .

&lt;#row-1-distance&gt;
  schema:value 3.5 ;
  schema:unitCode &lt;https://qudt.org/vocab/unit#Kilometer&gt; ;
  .
</pre>
          <p>
            and in JSON something like this:
          </p>
          <pre class="example">
"distance": {
  "@id": "#row-1-distance",
  "schema:value": 3.5
  "schema:unitCode": "https://qudt.org/vocab/unit#Kilometer"
}
</pre>
          <p class="note">
            You may want to use different properties than <code>schema:value</code> and <code>schema:unitCode</code>; if so, just use different <a href="https://w3c.github.io/csvw/metadata/#cell-propertyUrl"><code>propertyUrl</code></a>s.
          </p>
          <p>
            You need to decide on a pattern for the URLs for the values themselves, and set the <a href="https://w3c.github.io/csvw/metadata/#cell-aboutUrl"><code>aboutUrl</code></a> for the relevant column create that URL. In this example, the URLs that look like <code>#row-1-distance</code> can be generated with the pattern <code>#row-{_row}-distance</code>. The <a href="https://w3c.github.io/csvw/metadata/#cell-propertyUrl"><code>propertyUrl</code></a> for the column needs to be <code>schema:value</code> as the value in the column provides the value for that property. So the column description looks like:
          </p>
          <pre class="example">
{
  "name": "distance_value",
  "titles": "distance",
  "datatype": "number",
  "aboutUrl": "#row-{_row}-distance",
  "propertyUrl": "schema:value"
}</pre>
          <p>
            You then need to use virtual columns (descriptions of additional columns that don't exist in the source CSV) to generate the relationship between the thing whose distance is being measured and the structured value, and the additional property providing the unit for the structured value.
          </p>
          <p>
            To generate the relationship being the thing that has the distance and the structured value, the virtual column's <a href="https://w3c.github.io/csvw/metadata/#cell-valueUrl"><code>valueUrl</code></a> needs to hold the same URL template as you used before:
          </p>
          <pre class="example">
{
  "name": "distance",
  "virtual": true,
  "valueUrl": "#row-{_row}-distance"
}</pre>
          <p>
            To create the units property, you need another virtual column where the <a href="https://w3c.github.io/csvw/metadata/#cell-aboutUrl"><code>aboutUrl</code></a> of that virtual column generates the URL for the structured value, the <a href="https://w3c.github.io/csvw/metadata/#cell-propertyUrl"><code>propertyUrl</code></a> is <code>schema:unitCode</code> and the <a href="https://w3c.github.io/csvw/metadata/#cell-valueUrl"><code>valueUrl</code></a> is the URL representing the unit (in this case <code>https://qudt.org/vocab/unit#Kilometre</code>):
          </p>
          <pre class="example">
{
  "name": "distance_unit",
  "aboutUrl": "#row-{_row}-distance",
  "propertyUrl": "schema:unitCode",
  "valueUrl": "https://qudt.org/vocab/unit#Kilometer"
}</pre>
          <p>
            If it's necessary to add more detail about the unit (e.g. the fact that it's a unit of length) this can be done with additional virtual columns:
          </p>
          <pre class="example">
{
  "name": "kilometer_abbreviation",
  "virtual": true,
  "aboutUrl": "https://qudt.org/vocab/unit#Kilometer",
  "propertyUrl": "rdf:type",
  "valueUrl": "https://qudt.org/schema/qudt#LengthUnit"
}</pre>
          <p>
            Usually, however, processors should recognise or be able to resolve the URL for the unit to understand that it's a unit of length, if this is important for onward processing.
          </p>
          <p>See also:</p>
          <ul>
            <li><a href="#value-urls" class="sectionRef"></a></li>
            <li><a href="#row-identifiers" class="sectionRef"></a></li>
            <li><a href="#nested-structures" class="sectionRef"></a></li>
            <li><a href="https://qudt.org/">Quanitites, Units, Dimensions and Data Types (QUDT) Ontologies</a></li>
          </ul>
        </section>
        <section id="uom-datatypes">
          <h3>Supporting units of measure with named datatypes in RDF</h3>
          <p>
            If you are generating RDF from CSV, you may want to define a datatype for a column and then provide additional information about that datatype as properties. For example, the column description could look like:
          </p>
          <pre class="example">
{
  "titles": "distance",
  "datatype": {
    "@id": "https://example.org/unit/kilometre",
    "rdfs:label": "Kilometre",
    "base": "number"
  }
}</pre>
          <p>
            When values are generated in RDF for this column, they will be assigned the relevant datatype, for example:
          </p>
          <pre class="example">
[] :distance "3.5"^^&lt;https://example.org/unit/kilometre&gt; .

&lt;https://example.org/unit/kilometre&gt; rdfs:label "Kilometre" .
</pre>
          <p>
            Again, it is possible to include additional information about the unit being used as the datatype within the definition of the datatype:
          </p>
          <pre class="example">
{
  "titles": "distance",
  "datatype": {
    "@id": "https://example.org/unit/kilometre",
    <strong>"@type": "https://example.org/quantity/length",</strong>
    "rdfs:label": "Kilometre",
    "base": "number",
    <strong>"skos:notation": "km"</strong>
  }
}</pre>
          <p>See also:</p>
          <ul>
            <li><a href="#new-datatypes" class="sectionRef"></a></li>
            <li><a href="#transformation-values" class="sectionRef"></a></li>
            <li><a href="https://w3c.github.io/csvw/csv2rdf/#datatypes">Interpreting Datatypes</a> in [[csv2rdf]]</li>
          </ul>
        </section>
      </section>
      <section id="geospatial">
        <h2>How do you support geospatial data?</h2>
        <p>
          There are many different ways of representing geospatial data within a CSV file, and no single best practice for doing so.
        </p>
        <p>
          At the simplest level, it's possible to reference geospatial coordinates as points with separate columns for latitude, longitude and if necessary altitude (or using a different spatial reference system). This enables separate validation for the separate coordinates. The example used throughout this primer uses this setup:
        </p>
        <pre class="example">
"country","country group","name (en)","name (fr)","name (de)",<strong>"latitude","longitude"</strong>
"at","eu","Austria","Autriche","Österreich",<strong>"47.6965545","13.34598005"</strong>
"be","eu","Belgium","Belgique","Belgien",<strong>"50.501045","4.47667405"</strong>
"bg","eu","Bulgaria","Bulgarie","Bulgarien",<strong>"42.72567375","25.4823218"</strong>
</pre>
        <p>
          Metadata can be used to provide specialist types for the values of these coordinates, to indicate that they are latitude and longitude (by mapping to the well-known <code>schema:latitude</code> and <code>schema:longitude</code> properties which specify the use of WGS84), to group the coordinates together, and to provide a link that uses the coordinates to provide a map:
        </p>
        <pre class="example">{
  "titles": "latitude",
  "name": "lat",
  "datatype": {
    "base": "number",
    "minimum": "-90",
    "maximum": "90"
  },
  "aboutUrl": "https://example.org/country/{code}#geo",
  "propertyUrl": "schema:latitude"
}, {
  "titles": "longitude",
  "name": "long",
  "datatype": {
    "base": "number",
    "minimum": "-180",
    "maximum": "180"
  },
  "aboutUrl": "https://example.org/country/{code}#geo",
  "propertyUrl": "schema:longitude"
}, {
  "virtual": true,
  "propertyUrl": "schema:geo",
  "valueUrl": "https://example.org/country/{code}#geo"
}, {
  "virtual": true,
  "aboutUrl": "https://example.org/country/{code}#geo",
  "propertyUrl": "rdf:type",
  "valueUrl": "schema:GeoCoordinates"
}, {
  "virtual": true,
  "propertyUrl": "schema:hasMap",
  "valueUrl": "https://www.google.com/maps/@{lat},{long},7z"
}</pre>
        <p class="note">
          You can put latitude and longitude into a single column, with a character separator between the numbers as shown in <a href="#sequence-values" class="sectionRef"></a>. However, this makes it harder to accurately validate the individual coordinates. They also cannot be separated out into separate property values when converting to JSON or RDF. So this is a more restrictive method and best avoided.
        </p>
        <p>
          CSV files may also need to contain geometries beyond individual points. There are no built-in formats for geometries recognised by implementations of CSV on the Web. Geometries may be expressed using <a href="https://geojson.org">GeoJSON</a>, <a href="https://www.opengeospatial.org/standards/gml">GML</a>, <a href="https://www.opengeospatial.org/standards/kml">KML</a> or <a href="https://en.wikipedia.org/wiki/Well-known_text">OGC Well-Known Text (WKT)</a> representations. In each case, schemas may indicate that columns containing geometries adhere to a particular type:
        </p>
        <ul>
          <li><code>json</code> if the format is JSON-based such as GeoJSON</li>
          <li><code>xml</code> if the format is XML-based such as GML or KML</li>
          <li><code>string</code> if the format is text-based such as OGC WKT</li>
        </ul>
        <p>
          You can use the <a href="https://w3c.github.io/csvw/metadata/#datatype-format"><code>format</code></a> property to further constrain the content of columns containing these values. For example, you could use:
        </p>
        <pre class="example">
"datatype": {
  "@id": "https://geojson.org/",
  "base": "json",
  "format": "\\{ ?\"type\": ?\"Polygon\",.+\\}"
}
        </pre>
        <p>
          to indicate that a column contains a Polygon in GeoJSON, or:
        </p>
        <pre class="example">
"datatype": {
  "@id": "https://www.iana.org/assignments/media-types/application/gml+xml",
  "base": "xml",
  "format": ".*\\&lt;gml:Point xmlns:gml=\"https://www\.opengis\.net/ont/gml" srsName=\"([^\"])+\".*\\&gt;.+\\&lt;/gml:Point\\&gt;"
}
        </pre>
        <p>
          to indicate that a column contains a GML Point, or:
        </p>
        <pre class="example">
"datatype": {
  "@id": "https://www.iana.org/assignments/media-types/application/vnd.google-earth.kml+xml",
  "base": "xml",
  "format": ".*\\&lt;kml xmlns=\"https://www\\.opengis\\.net/kml/2.2\"\\&gt;.+\\&lt;/kml\\&gt;"
}
        </pre>
        <p>
          to indicate that a column contains KML, or:
        </p>
        <pre class="example">
"datatype": {
  "base": "string",
  "format": "POLYGON \\(\\(\\d+(\\.\\d+)? \\d+(\\.\\d+)?(, \\d+(\\.\\d+)? \\d+(\\.\\d+)?)+\\)\\)"
  "rdfs:seeAlso": "https://www.opengeospatial.org/standards/sfa"
}
        </pre>
        <p>
          to indicate that a column contains a very basic OGC WKT Polygon. (More sophisticated regular expressions could be used if properties held different types of objects such as points or lines or more complex polygons expressed in OGC WKT.)
        </p>
        <p class="note">
          There is no standard way of expressing which coordinate reference system (CRS) is being used within CSV metadata, but GeoJSON, GML and OGC WKT values can include information about which CRS they use. The <a href="https://www.w3.org/2015/spatial">W3C Spatial Data on the Web Working Group</a> intend to make recommendations in this area within [[sdw-bp]].
        </p>
        <p>See also:</p>
        <ul>
          <li><a href="#new-datatypes" class="sectionRef"></a></li>
          <li><a href="#sequence-values" class="sectionRef"></a></li>
          <li><a href="https://w3c.github.io/csvw/metadata/#datatypes">Datatypes</a> in [[tabular-metadata]]</li>
          <li><a href="https://w3c.github.io/csvw/syntax/#datatypes">Datatypes</a> in [[tabular-data-model]]</li>
        </ul>
      </section>
      <section id="shared-schemas">
        <h2>How can you specify a single schema for multiple CSV files?</h2>
        <p>
          CSV on the Web is designed to enable you to reuse the same schema when publishing multiple CSV files, even if those files are created by different organisations and therefore reside in different places. Rather than embedding a schema within the description of a table, the <a href="https://w3c.github.io/csvw/metadata/#table-schema"><code>tableSchema</code></a> property can point out to a schema held somewhere else.
        </p>
        <p>
          For example, if you were a statistical agency and wanted municipalities to publish their unemployment figures using the same schema, you could specify the columns that you wanted included within the schema you specified at <code>https://example.org/schema/unemployment.json</code>:
        </p>
        <pre class="example">
{
  "columns": [{
    "name": "municipality"
  }, {
    "name": "month",
    "datatype": "gYearMonth"
  }, {
    "name": "unemployment",
    "datatype": "number"
  }]
}
</pre>
        <p>
          Experience shows that publishers of data in CSV files often use their own headings for the columns. So long as these don't change the meaning of the column, as a statistical agency you probably don't care. The <a href="https://w3c.github.io/csvw/metadata/#column-titles"><code>titles</code></a> property allows you to provide multiple alternative titles that people may use in an array:
        </p>
        <pre class="example">
{
  "columns": [{
    "name": "municipality",
    <strong>"titles": [ "Municipality", "City", "Area" ]</strong>
  }, {
    "name": "month",
    <strong>"titles": [ "Month", "Period" ],</strong>
    "datatype": "gYearMonth"
  }, {
    "name": "unemployment",
    <strong>"titles": [ "Unemployment Rate", "Unemployment", "Number unemployed" ]</strong>
    "datatype": "number"
  }]
}
</pre>
        <p class="note">
          In cases where the data is being gathered from multiple countries, it may also be useful to specify multiple possible titles in different languages, as described in <a href="#column-title-languages" class="sectionRef"></a>.
        </p>
        <p>
          It will help consistency and processing of the data if the municipalities use a consistent set of codes to indicate which municipality the data relates to. As the statistical agency, you can supply the relevant codes in a CSV file, e.g. <code>https://example.org/ref/municipalities.csv</code>:
        </p>
        <pre class="example">
code,name
0101,Absecon City
0102,Atlantic City
0103,Brigantine City
...
</pre>
        <p>
          This file will of course have its own simple schema, <code>https://example.org/schema/municipalities.json</code>, that provides the datatype for the municipality codes and indicates that they are unique through a primary key:
        </p>
        <pre class="example">
{
  "columns": [{
    "name": "code",
    "datatype": { "format": "\d{4}" }
  }, {
    "name": "name"
  }],
  "primaryKey": "code"
}
</pre>
        <p>
          A <a>foreign key</a> in the schema supplied by the statistical authority ensures that the codes used in the unemployment data match up with the standard set supplied by the statistical authority:
        </p>
        <pre class="example">
{
  "columns": [{
    "name": "municipality",
    "titles": [ "Municipality", "City", "Area" ]
  }, {
    "name": "month",
    "titles": [ "Month", "Period" ],
    "datatype": "gYearMonth"
  }, {
    "name": "unemployment",
    "titles": [ "Unemployment Rate", "Unemployment", "Number unemployed" ]
    "datatype": "number"
  }],
  <strong>"foreignKeys": [{
    "columnReference": "municipality",
    "reference": {
      "resource": "https://example.org/ref/municipalities.csv",
      "columnReference": "code"
    }
  }]</strong>
}
</pre>
        <p>
          When a municipality describes their unemployment CSV, they will need to point to your schema for their data and to the centrally provided municipalities reference data and schema:
        </p>
        <pre class="example">
{
  "@context": "https://www.w3.org/ns/csvw",
  "tables": [{
    "url": "https://local.example.org/data/unemployment.csv",
    <strong>"tableSchema": "https://example.org/schema/unemployment.json"</strong>
  }, {
    <strong>"url": "https://example.org/ref/municipalities.csv",
    "tableSchema": "https://example.org/schema/municipalities.json"</strong>
  }]
}
</pre>
        <p class="note">
          A more complex example in which there is linking between pairs of files where the schemas are provided by a central authority is provided in the section <a href="https://w3c.github.io/csvw/metadata/#foreign-key-reference-between-schemas">Foreign Key Reference Between Schemas</a> within [[tabular-metadata]].
        </p>
        <p>See also:</p>
        <ul>
          <li><a href="#documentation-columns" class="sectionRef"></a></li>
          <li><a href="#datatypes" class="sectionRef"></a></li>
          <li><a href="#enumeration-reference" class="sectionRef"></a></li>
          <li><a href="#unique-values" class="sectionRef"></a></li>
          <li><a href="#column-title-languages" class="sectionRef"></a></li>
          <li><a href="https://w3c.github.io/csvw/metadata/#schema-examples">Examples of Foreign Keys</a> in [[tabular-metadata]]</li>
        </ul>
      </section>
      <section id="row-titles">
        <h2>How can you provide a title for a row?</h2>
        <p>
          It is useful to have titles for rows both for screen readers and in other displays where it may be difficult to view the complete context of a table and therefore to understand the content of a row.
        </p>
        <p>
          The <a href="https://w3c.github.io/csvw/metadata/#schema-rowTitles"><code>rowTitles</code></a> property within a schema provides an array of columns that provide sufficient context to label the row. These may sometimes be the same as the columns used for the <a href="https://w3c.github.io/csvw/metadata/#schema-primaryKey"><code>primaryKey</code></a> in the table, but are more likely to be columns that contain human readable text.
        </p>
        <p>
          For example, with the CSV:
        </p>
        <pre class="example">
"country","country group","name (en)","name (fr)","name (de)","latitude","longitude"
"at","eu","Austria","Autriche","Österreich","47.6965545","13.34598005"
"be","eu","Belgium","Belgique","Belgien","50.501045","4.47667405"
"bg","eu","Bulgaria","Bulgarie","Bulgarien","42.72567375","25.4823218"
</pre>
        <p>
          The <a href="https://w3c.github.io/csvw/metadata/#schema-rowTitles"><code>rowTitles</code></a> property could be set to reference the columns containing the name of each country, in the different languages available:
        </p>
        <pre class="example">
"tableSchema": {
  "columns": [{
    "titles": "country"
  },{
    "titles": "country group"
  },{
    "name": "name_en",
    "titles": "name (en)",
    "lang": "en"
  },{
    "name": "name_fr",
    "titles": "name (fr)",
    "lang": "fr"
  },{
    "name": "name_de",
    "titles": "name (de)",
    "lang": "de"
  },{
    "titles": "latitude"
  },{
    "titles": "longitude"
  }],
  <strong>"rowTitles": ["name_en", "name_fr", "name_de"]</strong>
}
</pre>
        <p>
          In this case, a screen reader or other display of the table could choose to read or display only the row title that matched the user's preferred language.
        </p>
        <p>
          In other cases, the <a href="https://w3c.github.io/csvw/metadata/#schema-rowTitles"><code>rowTitles</code></a> property may be set to an array of columns that <em>together</em> provided sufficient context to understand the column (eg <code>["firstName", "lastName"]</code>).
        </p>
        <p>See also:</p>
        <ul>
          <li><a href="#html-display" class="sectionRef"></a></li>
          <li><a href="https://w3c.github.io/csvw/metadata/#schema-rowTitles"><code>rowTitles</code> property</a> in [[tabular-metadata]]</li>
          <li><a href="https://w3c.github.io/csvw/syntax/#column-and-row-labelling">Column and Row Labelling</a> in [[tabular-data-model]]</li>
        </ul>
      </section>
      <section id="dialects">
        <h2>What about CSV that isn't standard CSV?</h2>
        <p>
          A lot of what's called "CSV" that's published on the web isn't actually CSV. It might use something other than commas (such as tabs or semi-colons) as separators between values, or might have multiple header lines.
        </p>
        <p>
          The specification for CSV as a format is [[RFC4180]]. However, this is an informational specification and and not a formal standard. Therefore, applications may deviate from it.
        </p>
        <p>
          The metadata that's described here can be used with files that contain tabular data but that aren't CSV. You can provide guidance to processors that are trying to parse those files through the <a href="https://w3c.github.io/csvw/metadata/#table-dialect"><code>dialect</code></a> property on a table description. For example, say we were dealing with a tab-separated file that contains multiple header lines at <code>https://example.org/data/unemployment.tsv</code>:
        </p>
        <pre class="example overlarge">
"country"	"country group"	"name (en)"	"name (fr)"	"name (de)"	"latitude"	"longitude"
"Land"	"Ländergruppe"	"Name (en)"	"Name (fr)"	"Name (de)"	"Breite"	"Länge"
"pays"	"groupe de pays"	"nom (en)"	"nom (fr)"	"nom (de)"	"latitude"	"longitude"
"at"	"eu"	"Austria"	"Autriche"	"Österreich"	"47.6965545"	"13.34598005"
"be"	"eu"	"Belgium"	"Belgique"	"Belgien"	"50.501045"	"4.47667405"
"bg"	"eu"	"Bulgaria"	"Bulgarie"	"Bulgarien"	"42.72567375"	"25.4823218"
</pre>
				<p>
					The metadata for this file could be:
				</p>
				<pre class="example">{
  "@context": "https://www.w3.org/ns/csvw",
  "url": "https://example.org/data/unemployment.tsv",
  <strong>"dialect": {
    "delimiter": "\t",
    "headerRowCount": 3
  }</strong>
}
</pre>
        <p>
          There are a number of other properties that you can set within the dialect to cater for the large range of weird things that people do in CSV files. They are:
        </p>
        <dl>
          <dt><a href="https://w3c.github.io/csvw/metadata/#dialect-commentPrefix"><code>commentPrefix</code></a></dt>
          <dd>
            <p>If the file contains comment lines, set this to the character used at the start of the lines that are comments (usually that's <code>#</code>).</p>
          </dd>
          <dt><a href="https://w3c.github.io/csvw/metadata/#dialect-delimiter"><code>delimiter</code></a></dt>
          <dd>
            <p>If the file doesn't use commas as separators between values, set this to the separator that it uses.</p>
          </dd>
          <dt><a href="https://w3c.github.io/csvw/metadata/#dialect-doubleQuote"><code>doubleQuote</code></a></dt>
          <dd>
            <p>If the file uses <code>\</code> to escape double quotes within values, set this to <code>false</code>.</p>
          </dd>
          <dt><a href="https://w3c.github.io/csvw/metadata/#dialect-encoding"><code>encoding</code></a></dt>
          <dd>
            <p>If the encoding of the file is not UTF-8, set this to the encoding.</p>
          </dd>
          <dt><a href="https://w3c.github.io/csvw/metadata/#dialect-header"><code>header</code></a></dt>
          <dd>
            <p>If the file doesn't have a header line, set this to <code>false</code>.</p>
          </dd>
          <dt><a href="https://w3c.github.io/csvw/metadata/#dialect-headerRowCount"><code>headerRowCount</code></a></dt>
          <dd>
            <p>If the file has more than one header line, set this to the number of header lines it has.</p>
          </dd>
          <dt><a href="https://w3c.github.io/csvw/metadata/#dialect-lineTerminators"><code>lineTerminators</code></a></dt>
          <dd>
            <p>If the file uses an unusual character at the end of its lines, set this to that character.</p>
          </dd>
          <dt><a href="https://w3c.github.io/csvw/metadata/#dialect-quoteChar"><code>quoteChar</code></a></dt>
          <dd>
            <p>If the file doesn't use double quotes (<code>"</code>) around values that contain commas, set this to the character that it does use.</p>
          </dd>
          <dt><a href="https://w3c.github.io/csvw/metadata/#dialect-skipBlankRows"><code>skipBlankRows</code></a></dt>
          <dd>
            <p>If the file contains blank rows that should just be ignored, set this to <code>true</code>.</p>
          </dd>
          <dt><a href="https://w3c.github.io/csvw/metadata/#dialect-skipColumns"><code>skipColumns</code></a></dt>
          <dd>
            <p>If the file has some columns at the start that don't contain useful information, set this to that number of columns.</p>
          </dd>
          <dt><a href="https://w3c.github.io/csvw/metadata/#dialect-skipInitialSpace"><code>skipInitialSpace</code></a></dt>
          <dd>
            <p>If values in the file sometimes start with whitespace that should be ignored, set this to <code>true</code>.</p>
          </dd>
          <dt><a href="https://w3c.github.io/csvw/metadata/#dialect-skipRows"><code>skipRows</code></a></dt>
          <dd>
            <p>If the file has some rows at the start that don't contain useful information, set this to that number of rows. (Sometimes people put metadata at the start of a CSV file, before the header lines.)</p>
          </dd>
          <dt><a href="https://w3c.github.io/csvw/metadata/#dialect-trim"><code>trim</code></a></dt>
          <dd>
            <p>If you don't want to ignore whitespace around values, set this to <code>false</code>. If you want to only ignore whitespace at the beginning of values, set it to <code>start</code> and if you want to only ignore whitespace at the end of values, to <code>end</code>. By default whitespace at the start and the end of a value will be stripped away.</p>
          </dd>
        </dl>
        <p>See also:</p>
        <ul>
          <li><a href="#tabular-data" class="sectionRef"></a></li>
          <li><a href="#tables-from-html" class="sectionRef"></a></li>
          <li><a href="https://w3c.github.io/csvw/syntax/#parsing">Parsing Tabular Data</a> in [[tabular-data-model]]</li>
          <li><a href="https://w3c.github.io/csvw/metadata/#dialect-descriptions">Dialect Descriptions</a> in [[tabular-metadata]]</li>
        </ul>
      </section>
      <section id="tables-from-html">
        <h2>What about tables in HTML?</h2>
        <p>
          Tables in HTML are a bit more complicated than tables in CSV files. However, it is possible to use the metadata described here and in [[tabular-metadata]] to described HTML tables by embedding the metadata within a <code>script</code> element in the header of the HTML page. A description and example of how to do this is provided in the [[csvw-html]] Note.
        </p>
        <p>See also:</p>
        <ul>
          <li><a href="#tabular-data" class="sectionRef"></a></li>
          <li><a href="#dialects" class="sectionRef"></a></li>
          <li>[[csvw-html]]</li>
        </ul>
      </section>
      <section id="well-known-location">
        <h2>What if you want to put metadata files somewhere else?</h2>
        <p>
          By default, if you point a processor at a CSV file on the web, they will look for a <code>Link</code> header within the response with <code>rel="describedby"</code> and specifying a content type of <code>application/csvm+json</code>, <code>application/ld+json</code> or <code>application/json</code>. If you're publishing CSV files and it's possible to set the <code>Link</code> header, this is the best way of telling processors where to look for metadata files.
        </p>
        <p>
          If processors don't see an appropriate <code>Link</code> header, they will append <code>-metadata.json</code> to the end of the URL of the CSV file to try to find metadata for it. If they can't find a metadata file there, they will look in the directory containing the CSV file for a file called <code>csv-metadata.json</code> and use that file.
        </p>
        <p>
          Looking for files in this way isn't appropriate on all servers. As a publisher, it might be that you have URLs for CSV files that are automatically generated using queries, such as <code>https://example.org/data?format=csv&amp;x=15&amp;y=53</code> or that you want metadata to live in a separate subdirectory or central location.
        </p>
        <p>
          As a publisher, if you can't or don't want to use the <code>Link</code> header, you can control where processors look for metadata for your CSV files by listing the locations to look at within the <code>/.well-known/csvm</code> file on your server. (This is a well-known location as defined in [[RFC5785]].) This file should contain a list of URL patterns which will be expanded by substituting <code>url</code> for the URL of the CSV file, and then resolving against the location of the CSV file. Lines might look like:
        </p>
        <pre class="example">
/metadata?for={url}
?format=metadata
{+url}m
        </pre>
        <p>
          With a CSV file at <code>https://example.org/data.csv</code> this would lead the processor to search for metadata at:
        </p>
        <pre class="example">
https://example.org/metadata?for=https://example.org/data.csv
https://example.org/data.csv?format=metadata
https://example.org/data.csvm
        </pre>
        <p>See also:</p>
        <ul>
          <li><a href="#metadata" class="sectionRef"></a></li>
          <li><a href="https://w3c.github.io/csvw/syntax/#locating-metadata">Locating Metadata</a> in [[tabular-data-model]]</li>
        </ul>
      </section>
    </section>
  </body>
</html>
