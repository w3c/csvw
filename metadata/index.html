<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta content="width=device-width,initial-scale=1" name="viewport" />
    <title>Metadata Vocabulary for Tabular Data</title>
    <script class="remove" src="http://www.w3.org/Tools/respec/respec-w3c-common">
		</script>
    <script class="remove">
var respecConfig = {
    localBiblio: {
        "CSV-MODEL": "Jeni Tennison. <a href=\"http://w3c.github.io/csvw/syntax/\"><cite>Model for Tabular Data and Metadata on the Web</cite></a> Editor's Draft. URL: <a href=\"http://w3c.github.io/csvw/syntax/\">http://w3c.github.io/csvw/syntax/</a>",
        "UNICODE-BIDI": "Mark Davis; Aharon Lanin; Andrew Glass. <a href=\"http://unicode.org/reports/tr9/\"><cite>TR9, Unicode Bidirectional Algorithm.</cite></a>. 24 September 2013, URL: <a href=\"http://unicode.org/reports/tr9/\">http://unicode.org/reports/tr9/</a>",
        "RFC3066": "H. Alvestrand, ed. <a href=\"http://www.ietf.org/rfc/rfc3066.txt\"><cite>RFC 3066: Tags for the Identification of Languages 1995</cite></a>. Available at: <a href=\"http://www.ietf.org/rfc/rfc3066.txt\">http://www.ietf.org/rfc/rfc3066.txt</a>"
    },
    specStatus: "ED",
    shortName: "tabular-metadata",
    //publishDate:  "2014-03-27",
    //previousPublishDate: "2014-03-27",
    //previousMaturity: "FPWD",
    //previousURI: "http://www.w3.org/TR/2014/WD-tabular-data-model-20140327/",
    edDraftURI: "http://w3c.github.io/csvw/metadata/",
    // lcEnd: "3000-01-01",
    // crEnd: "3000-01-01",
    editors: [{ 
      name: "Rufus Pollock", 
      url: "http://rufuspollock.org/",
      company: "Open Knowledge", 
      companyURL: "https://okfn.org/" 
    }, {
      name: "Jeni Tennison",
      company: "Open Data Institute",
      companyURL: "http://theodi.org/"
    }],
    wg: "CSV on the Web Working Group",
    wgURI: "http://www.w3.org/2013/csvw/",
    wgPublicList: "public-csv-wg",
    wgPatentURI: "http://www.w3.org/2004/01/pp-impl/68238/status",
    otherLinks: [{
      key: "Repository",
      data: [{
          value: "We are on Github",
          href: "https://github.com/w3c/csvw"
      }, {
          value: "File a bug",
          href: "https://github.com/w3c/csvw"
      }]
      }, {
      key: "Changes",
        data: [{
        //  value: "Diff to previous version",
        //  href: "diff-20140327.html"
        //}, {
          value: "Commit history",
          href: "https://github.com/w3c/csvw/commits/gh-pages"
      }]
    }],
    inlineCSS: true,
    noIDLIn: true,
    noLegacyStyle: false
    };
    </script>
  </head>
  <body>
    <section id="abstract">
      <p>
        Validation, conversion, display and search of tabular data on the web requires additional metadata that describes how the data should be interpreted. This document defines a vocabulary for metadata that annotates tabular data. This can be used to provide metadata at various levels, from collections of data from CSV documents and how they relate to each other down to individual cells within a table.
      </p>
    </section>
    <section id="sotd">
      <p>
        The CSV on the Web Working Group was chartered to produce a Recommendation "Access methods for CSV Metadata" as well as Recommendations for "Metadata vocabulary for CSV data" and "Mapping mechanism to transforming CSV into various Formats (e.g., RDF, JSON, or XML)". This document aims to primarily satisfy the second of those Recommendations.
      </p>
    </section>
    <section>
      <h2>Introduction</h2>
      <p>
        Interpreting tabular data that is available on the web, particularly as CSV, usually requires additional metadata. As an example, say that the following CSV file were available at <code>http://example.org/tree-ops.csv</code>
      </p>
      <pre class="example">
GID,On Street,Species,Trim Cycle,Inventory Date
1,ADDISON AV,Celtis australis,Large Tree Routine Prune,10/18/2010
2,EMERSON ST,Liquidambar styraciflua,Large Tree Routine Prune,6/2/2010
3,EMERSON ST,Liquidambar styraciflua,Large Tree Routine Prune,6/2/2010
      </pre>
      <p>
        A human consumer of this data might be able to figure out the meaning of the different columns, particularly if there were some additional human-readable documentation made available. Automated processors would have a much harder time; realistically they would be limited to displaying the information in a table. Making available machine-readable metadata helps with the interpretation of the tabular data. For example, say that the following metadata file were available at <code>http://example.org/trees-ops.csv.json</code>:
      </p>
      <pre class="example highlight">
{
  "name": "tree-ops",
  "title": "Tree Operations",
  "keywords": ["tree", "street", "maintenance"],
  "publisher": [{
    "name": "Example Municipality",
    "web": "http://example.org"
  }],
  "license": "cc-by",
  "resources": [{
    "name": "tree-ops",
    "path": "tree-ops.csv",
    "modified": "2010-12-31",
    "schema": {
      "fields": [{
        "name": "GID",
        "title": "Generic Identifier",
        "description": "An identifier for the operation on a tree.",
        "type": "string",
        "constraints": {
          "required": true,
          "unique": true
        }
      }, {
        "name": "On Street",
        "description": "The street that the tree is on.",
        "type": "string"
      }, {
        "name": "Species",
        "description": "The species of the tree.",
        "type": "string"
      }, {
        "name": "Trim Cycle",
        "description": "The operation performed on the tree.",
        "type": "string"
      }, {
        "name": "Inventory Date",
        "description": "The date of the operation that was performed.",
        "type": "date",
        "format": "M/D/YYYY"
      }]
    },
    "primaryKey": "GID"  
  }]
}
      </pre>
      <div class="issue">
        <p>
          Above is unaltered datapackage JSON. If we focus on just single file metadata, try to throw in some JSON-LD naming conventions and use terminology from the model document, we get something more like:
        </p>
        <pre class="highlight">
[{
  "@id": "tree-ops.csv",
  "@type": "Table",
  "title": "Tree Operations",
  "keywords": ["tree", "street", "maintenance"],
  "publisher": [{
    "name": "Example Municipality",
    "web": "http://example.org"
  }],
  "license": "http://opendefinition.org/licenses/cc-by/",
  "modified": "2010-12-31",
  "columns": [{
    "@id": "_:GID",
    "name": "GID",
    "title": "Generic Identifier",
    "description": "An identifier for the operation on a tree.",
    "type": "string",
    "required": true,
    "unique": true
  }, {
    "name": "On Street",
    "description": "The street that the tree is on.",
    "type": "string"
  }, {
    "name": "Species",
    "description": "The species of the tree.",
    "type": "string"
  }, {
    "name": "Trim Cycle",
    "description": "The operation performed on the tree.",
    "type": "string"
  }, {
    "name": "Inventory Date",
    "description": "The date of the operation that was performed.",
    "type": "date",
    "format": "M/D/YYYY"
  }]
  "primaryKey": "_:GID"  
}]
        </pre>
        <p>
          The JSON-LD context would roughly look like:
        </p>
        <pre class="highlight">
{
  "@vocab": "http://w3.org/ns/table#",
  "dc": "http://purl.org/dc/terms/",
  "xsd": "http://www.w3.org/2001/XMLSchema#",
  "title": "dc:title",
  "keywords": "dc:keywords",
  "publisher": {
    "@id": "dc:publisher",
    "@type": "@id"
    // something here that maps the publisher onto an appropriate schema.org type?    
  }
  "license": {
    "@id": "dc:license",
    "@type": "@id"
  },
  "modified": {
    "@id": "dc:modified",
    "@type": "xsd:date"
  },
  "columns": {
    "@type": "@id",
    "@container": "@list"
  },
  "primaryKey": {
    "@type": "@id"
  }
}
        </pre>
      </div>
      <p>
        Given the location of the CSV file, this metadata file can be located by appending <code>.json</code> to the URL (as described in <a href="http://www.w3.org/TR/tabular-data-model/#standard-path">Model for Tabular Data and Metadata on the Web</a>). It provides information for different types of applications:
      </p>
      <ul>
        <li><strong>Viewers</strong> can use the indicated metadata to provide a more user-friendly or human-readable view of the CSV file, which might include displaying it in a table or as graphs or charts.</li>
        <li><strong>Data entry tools</strong> can use the metadata to prompt people to supply information that is added to a CSV file</li>
        <li><strong>Validators</strong> can check that the labels of the columns in the metadata file match those in the CSV file, that the values in the columns are of the right type and in the right format, and that values in the <code>GID</code> column are all present and unique.</li>
        <li><strong>Converters</strong> can use the metadata to map the CSV data into other formats such as JSON, RDF and XML, or into databases or statistical applications, in intelligent ways.</li>
        <li><strong>Data Aggregators</strong> can use the indicated metadata, such as descriptions, titles, modification dates and licences, to enable more intelligent retrieval of relevant data on the web.</li>
      </ul>
      <p>
        The <a href="http://www.w3.org/TR/tabular-data-model/">Model for Tabular Data and Metadata on the Web</a> specification defines an <a href="http://www.w3.org/TR/tabular-data-model/#annotated-model">Annotated Tabular Data Model</a> in which tables, columns, rows and cells can be annotated with properties and values, and a <a href="http://www.w3.org/TR/tabular-data-model/#grouped-model">Grouped Tabular Data Model</a> in which a group of tables is annotated. That specification also describes <a href="http://www.w3.org/TR/tabular-data-model/#metadata">how to locate metadata</a> about a given CSV file.
      </p>
      <p>
        This document defines the format and structure of metadata documents, and how these are interpreted to create an Annotated Tabular Data Model. It also defines how to validate tabular data based on some of these annotations. This metadata can be expressed as an RDF graph. However, all applications that conform to this specification (including validators and applications that read or convert tabular data) MUST read the JSON-based format described in <a href="#metadata-in-json" class="sectionRef"></a>.
      </p>
      <p class="issue">
        We should aim, if we can, for the JSON format to be equivalent to a JSON-LD version of the RDF vocabulary, but without any requirement to include context within the JSON itself (to save people from having to do boilerplate).
      </p>
    </section>
    <section>
      <h2>Processing Tables</h2>
      <p>
        This section describes how particular types of applications should use the metadata supplied about a CSV file when they process that CSV file.
      </p>
      <section>
        <h3>Annotating Tables</h3>
        <p>
          The metadata defined in this specification is used to annotate an existing <a href="http://w3c.github.io/csvw/syntax/#dfn-annotated-table">annotated table</a> as defined in [[!CSV-MODEL]]. Annotated tables form the basis for all further processing, such as validating or displaying the table. All compliant applications MUST create annotated tables based on the algorithm defined here.
        </p>
        <p>
          Metadata documents contain descriptions of tables, columns, rows and cells which are used to create annotations. There are three classes of properties on description objects:
        </p>
        <ul>
          <li>properties that are used to identify the table, column, row or cell that the annotations should appear on; these match up to properties on those objects in the core tabular data model defined in [[!CSV-MODEL]] and do not form additional annotations</li>
          <li>properties that map directly to annotations that appear directly on the table, column, row or cell whose description they appear on, such as the <code>name</code> of a column or the <code>provenance</code> of a table</li>
          <li>properties that are specified on the description of a table, column or row to provide a default value for the equivalent annotation on each of the cells that appear in that table, column or row</li>
        </ul>
        <section>
          <h4>Direct Annotations</h4>
          <p>
            <dfn title="direct annotation">Direct annotations</dfn> are properties on the description object for a given table, column, row or cell which map directly to properties on the described table, column, row or cell. The name of the annotation is the same as the name of the property on the annotation. The value of the annotation is the same as the value of the property on the description object.
          </p>
        </section>
        <section>
          <h4>Inherited Properties</h4>
          <p>
            A cell may be assigned annotations based on properties on the description objects for the table, column or row that it appears in. These properties are known as <dfn title="inherited property">inherited properties</dfn> and are listed in <a href="#cells" class="sectionRef"></a>. To ascertain a value for these annotations, an application MUST identify the relevant property in the descriptions of the table, column and row.
          </p>
          <p>
            Applications MUST raise an error if the value of a property in a column or row description is not <a>compatible with</a> the value of that property on the table. Applications MUST raise an error if the value of a property on a row is not <a>compatible with</a> the values of that property on all the columns in the table. Application MUST raise an error if the value of a property on a cell is not <a>compatible with</a> the values of that property on both the column and the row that the cell is associated with.
          </p>
          <p>
            A value for a cell, column or row is <dfn>compatible with</dfn> with a value on a row, column or table if they are the same value or if the first value is a sub-value of the second value. The definitions of individual inherited properties indicate what values count as sub-values of others.
          </p>
        </section>
      </section>
      <section>
        <h3>Displaying Tables</h3>
        <section>
          <h4>Displaying Metadata</h4>
          <p class="issue">TODO: Stuff about providing metadata about the table</p>
        </section>
        <section>
          <h4>Bidirectional Tables</h4>
          <p>
            There are two levels of bidirectionality to consider when displaying tables: the directionality of the table (ie whether the columns should be arranged left-to-right or right-to-left) and the directionality of the content of individual cells.
          </p>
          <p>
            The <a href="#table-direction"><code>table-direction</code> property</a> provides information about the desired display of the table. If <code>table-direction=ltr</code> then the first column SHOULD be displayed on the left and the last column on the right. If <code>table-direction=rtl</code> then the first column SHOULD be displayed on the right and the last column on the left.
          </p>
          <p>
            If <code>table-direction=default</code> then tables SHOULD be displayed with attention to the bidirectionality of the content of the file. Specifically, the values of the cells in the table should be scanned breadth first: from the first cell in the first column through to the last cell in the first column, down to the last cell in the last column. If the first character in the table with a <a href="http://unicode.org/reports/tr9/#Bidirectional_Character_Types">strong type</a> as defined in [[!UNICODE-BIDI]] indicates a <acronym title="right-to-left">RTL</acronym> directionality, the table should be displayed with the first column on the right and the last column on the left. Otherwise, the table should be displayed with the first column on the left and the last column on the right. Characters such as whitespace, quotes, commas and numbers do not have a strong type, and therefore are skipped when identifying the character that determines the directionality of the table.
          </p>
          <p>
            Implementations SHOULD enable user preferences to override the indicated metadata about the directionality of the table.
          </p>
          <p>
            Once the directionality of the table has been determined, each cell within the table should be considered as a separate <a href="http://unicode.org/reports/tr9/#The_Paragraph_Level">paragraph</a>, as defined by the <acronym title="Unicode Bidirectional Algorithm">UBA</acronym> in [[!UNICODE-BIDI]]. The default directionality for the cell is determined by looking at the <a href="#cell-text-direction"><code>text-direction</code> property</a>, which is an <a>inherited property</a>.
          </p>
          <p>
            Thus, as defined by the <acronym title="Unicode Bidirectional Algorithm">UBA</acronym>, if a cell contains no characters with a strong type (if it's a number or date for example) then the way the cell is displayed should be determined by the <a href="#cell-text-direction"><code>text-direction</code> property</a> of the cell. However, when the cell contains characters with a strong type (such as letters) then they MUST be displayed according to the Unicode Bidirectional Algorithm as described in [[!UNICODE-BIDI]].
          </p>
        </section>
        <section>
          <h4>Column and Row Headings</h4>
          <p class="issue">TODO: stuff about using labels etc</p>
        </section>
        <section>
          <h4>Displaying cells</h4>
          <p class="issue">TODO: stuff about formatting values, having access to notes &amp; annotations etc</p>
        </section>
      </section>
      <section>
        <h3>Validating Tables</h3>
        <p class="issue">TODO</p>
      </section>
      <section>
        <h3>Converting Tables</h3>
        <p>
          Conversions of tabular data to other formats operate over a <a href="http://w3c.github.io/csvw/syntax/#dfn-annotated-table">annotated table</a> constructed as defined in <a href="#annotating-tables" class="sectionRef"></a>. The mechanics of these conversions to other formats are defined in other specifications.
        </p>
        <p>
          Conversion specifications MUST define a default mapping from an annotated table that lacks any annotations (ie that is equivalent to an un-annotated table).
        </p>
        <p>
          Conversion specifications MAY use any of the properties defined in this specification to adjust the mapping of an annotated table into another format. For example, the <a href="#column-name"><code>name</code> of a column</a> may become the name of the equivalent element in XML or property in JSON or be used to construct a property URI in RDF.
        </p>
        <p>
          Conversion specifications MAY define additional properties, not defined in this specification, which are specifically used when converting to the target format of the conversion. For example, a conversion to XML might specify a <code>element-or-attribute</code> property on columns that determines whether a particular column is represented through an element or an attribute in the data.
        </p>
        <p>
          Conversion specifications SHOULD specify format-specific properties specifying external processing steps to provide more control to people defining conversions. If these are specified, the conversion specification MUST specify at what point in the processing this external processing takes place, and what it takes place on. Examples might be:
        </p>
        <ul>
          <li>the URL of an XSLT file that is used to process XML after it is generated</li>
          <li>a string containing a SPARQL CONSTRUCT pattern that is executed on RDF after it is generated</li>
          <li>properties that contain definitions of Javascript callback functions that are used when processing particular columns or individual rows</li>
        </ul>
        <p class="issue">
          There might be some properties that should be used in particular ways within conversion specifications in order to give some consistency. For example, using the names of columns as the source of property names. So there might be other constraints on conversion specifications that get listed here.
        </p>
      </section>
      <section>
        <h3>Aggregating Tables</h3>
        <p class="issue">TODO</p>
      </section>
    </section>
    <section>
      <h2>Metadata Format</h2>
      <p>
        This section defines a set of properties and permitted values for annotating tabular data, and how these annotations should be interpreted by applications.
      </p>
      <p class="issue">
        We intend to support metadata for packages, and to support externally-sourced schemas for tabular data. For now, we are scoping to single metadata files defining single CSV files.
      </p>
      <section>
        <h3>Syntax</h3>
        <p>
          A metadata document is a JSON document which holds an object at the top level. This object is a <a>description object</a> of a table. A <dfn>description object</dfn> is a JSON object that describes a component of a table (a table, a column, a row or a cell) and has one or more properties are mapped into properties on that component. There are different types of properties on description objects:
        </p>
        <dl>
          <dt><dfn title="link property">link properties</dfn></dt>
          <dd>
            <p>These hold one or more references to other resources by URL. Their values may be:</p>
            <ul>
              <li><strong>strings</strong> &mdash; resolved as URLs against the <a>base URL</a></li>
              <li><strong>arrays</strong> &mdash; lists of strings which are resolved as URLs against the <a>base URL</a></li>
            </ul>
          </dd>
          <dt><dfn title="internal reference property">internal reference properties</dfn></dt>
          <dd>
            <p>These hold one or more references to other description objects. The referenced description object must have an <code>@id</code> property whose value looks like <code>_:<var>name</var></code>. Internal reference properties can then reference other description objects through values that are:</p>
            <ul>
              <li><strong>strings</strong> &mdash; in the format <code>_:<var>name</var></code> which MUST match the <code>@id</code> on another description object within the metadata document</li>
              <li><strong>arrays</strong> &mdash; lists of strings as above</li>
            </ul>
          </dd>
          <dt><dfn title="object property">object properties</dfn></dt>
          <dd>
            <p>These hold one or more objects or references to objects by URL. Their values may be:</p>
            <ul>
              <li><strong>strings</strong> &mdash; resolved as URLs against the <a>base URL</a></li>
              <li><strong>objects</strong> &mdash; interpreted as structured objects</li>
              <li><strong>arrays</strong> &mdash; lists of strings and/or objects</li>
            </ul>
            <p>
              Object properties are often used when the values can be or should be values within controlled vocabularies.
            </p>
            <p class="issue">
              Add an example using frequency, which has a controlled vocabulary from DCT.
            </p>
          </dd>
          <dt><dfn title="natural language property">natural language properties</dfn></dt>
          <dd>
            <p>These hold natural language strings. Their values may be:</p>
            <ul>
              <li><strong>strings</strong> &mdash; interpreted as natural language strings in the <a>default language</a></li>
              <li><strong>arrays</strong> &mdash; interpreted as alternative natural language strings in the <a>default language</a></li>
              <li><strong>objects</strong> whose properties MUST be language codes as defined by [[!RFC3066]] and whose values are either strings or arrays, providing natural language strings in that language</li>
            </ul>
            <p class="issue">
              It would be nice to enable some markup in natural language strings, for example by stating that they are interpreted as HTML or Markdown.
            </p>
          </dd>
          <dt><dfn title="atomic property">atomic properties</dfn></dt>
          <dd>
            <p>These hold atomic values such as dates, numbers or strings. Their values may be:</p>
            <ul>
              <li><strong>numbers</strong> &mdash; interpreted as integers or doubles</li>
              <li><strong>booleans</strong> &mdash; interpreted as booleans</li>
              <li><strong>strings</strong> &mdash; interpreted as defined by the property</li>
              <li><strong>arrays</strong> &mdash; lists of numbers, booleans or strings</li>
            </ul>
          </dd>
        </dl>
      </section>
      <section>
        <h3>Top-Level Properties</h3>
        <p>
          The top-level object MAY have a <code>@context</code> property. This holds an object that provides metadata for interpreting other properties, namely:
        </p>
        <dl>
          <dt><code>@language</code></dt>
          <dd>
            <p>
              indicates the default language for the values of properties in the description; if present, its value MUST be a language code [[!RFC3066]] which is the <dfn>default language</dfn> for the values of other properties in the metadata document
            </p>
            <p class="note">
              Note that the <code>@language</code> property of the <code>@context</code> object, which gives the default language used within the metadata file, is distinct from the <code>language</code> property on a <a>description object</a>, which gives the language used in the data within the table.
            </p>
          </dd>
          <dt><code>@base</code></dt>
          <dd>
            <p>
              indicates the base URL against which other URLs within the description are resolved; if present, its value MUST be a URL which is resolved against the base URL of the metadata document (the location from which it was retrieved) to provide the <dfn>base URL</dfn> for other URLs in the metadata document
            </p>
            <p class="note">
              Note that the <code>@base</code> property of the <code>@context</code> object provides the base URL used for URLs within the metadata document, not the URLs that appear within the table.
            </p>
          </dd>
        </dl>
      </section>
      <section>
        <h3>Common Properties</h3>
        <p>
          The properties listed here may be applied to any structure within the tabular data model: tables, columns, rows or cells.
        </p>
        <p class="issue">
          Any other lists of properties we should crib off?
        </p>
        <section>
          <h4>Dublin Core Terms</h4>
          <p>
            Descriptions MAY contain any properties defined by [[!DC-TERMS]] to describe the table. This specification does not define any application behaviour associated with these properties being present, except that validation of metadata files MUST check that, if they are present, they adhere to the syntax defined here.
          </p>
          <table>
            <thead>
              <tr><th>Property</th><th>Type</th><th>Details</th></tr>
            </thead>
            <tr><th><code>abstract</code></th><td><a>natural language property</a></td><td></td></tr>
            <tr><th><code>accessRights</code></th><td><a>object property</a></td><td></td></tr>
            <tr><th><code>accrualMethod</code></th><td><a>object property</a></td><td></td></tr>
            <tr><th><code>accrualPeriodicity</code></th><td><a>object property</a></td><td></td></tr>
            <tr><th><code>accrualPolicy</code></th><td><a>object property</a></td><td></td></tr>
            <tr><th><code>alternative</code></th><td><a>natural language property</a></td><td></td></tr>
            <tr><th><code>audience</code></th><td><a>object property</a></td><td></td></tr>
            <tr><th><code>available</code></th><td><a>atomic property</a></td><td>dates in the format <code>YYYY-MM-DD</code></td></tr>
            <tr><th><code>bibliographicCitation</code></th><td><a>natural language property</a></td><td></td></tr>
            <tr><th><code>conformsTo</code></th><td><a>object property</a></td><td></td></tr>
            <tr><th><code>contributor</code></th><td><a>object property</a></td><td></td></tr>
            <tr><th><code>coverage</code></th><td><a>object property</a></td><td></td></tr>
            <tr><th><code>created</code></th><td><a>atomic property</a></td><td>dates in the format <code>YYYY-MM-DD</code></td></tr>
            <tr><th><code>creator</code></th><td><a>object property</a></td><td></td></tr>
            <tr><th><code>date</code></th><td><a>atomic property</a></td><td>dates in the format <code>YYYY-MM-DD</code></td></tr>
            <tr><th><code>dateAccepted</code></th><td><a>atomic property</a></td><td>dates in the format <code>YYYY-MM-DD</code></td></tr>
            <tr><th><code>dateCopyrighted</code></th><td><a>atomic property</a></td><td>dates in the format <code>YYYY-MM-DD</code></td></tr>
            <tr><th><code>dateSubmitted</code></th><td><a>atomic property</a></td><td>dates in the format <code>YYYY-MM-DD</code></td></tr>
            <tr><th><code>description</code></th><td><a>natural language property</a></td><td></td></tr>
            <tr><th><code>educationLevel</code></th><td><a>object property</a></td><td></td></tr>
            <tr><th><code>extent</code></th><td><a>object property</a></td><td></td></tr>
            <tr><th><code>format</code></th><td><a>object property</a></td><td></td></tr>
            <tr><th><code>hasFormat</code></th><td><a>object property</a></td><td></td></tr>
            <tr><th><code>hasPart</code></th><td><a>link property</a></td><td></td></tr>
            <tr><th><code>hasVersion</code></th><td><a>link property</a></td><td></td></tr>
            <tr><th><code>identifier</code></th><td><a>atomic property</a></td><td>a URL</td></tr>
            <tr><th><code>instructionalMethod</code></th><td><a>object property</a></td><td></td></tr>
            <tr><th><code>isFormatOf</code></th><td><a>link property</a></td><td></td></tr>
            <tr><th><code>isPartOf</code></th><td><a>link property</a></td><td></td></tr>
            <tr><th><code>isReferencedBy</code></th><td><a>link property</a></td><td></td></tr>
            <tr><th><code>isReplacedBy</code></th><td><a>link property</a></td><td></td></tr>
            <tr><th><code>isRequiredBy</code></th><td><a>link property</a></td><td></td></tr>
            <tr><th><code>issued</code></th><td><a>atomic property</a></td><td>dates in the format <code>YYYY-MM-DD</code></td></tr>
            <tr><th><code>isVersionOf</code></th><td><a>link property</a></td><td></td></tr>
            <tr><th><code>language</code></th><td><a>atomic property</a></td><td>a language code as defined by [[!RFC3066]]; this is an <a>inherited property</a></td></tr>
            <tr><th><code>license</code></th><td><a>object property</a></td><td></td></tr>
            <tr><th><code>mediator</code></th><td><a>object property</a></td><td></td></tr>
            <tr><th><code>medium</code></th><td><a>object property</a></td><td></td></tr>
            <tr><th><code>modified</code></th><td><a>atomic property</a></td><td>dates in the format <code>YYYY-MM-DD</code></td></tr>
            <tr><th><code>provenance</code></th><td><a>object property</a></td><td></td></tr>
            <tr><th><code>publisher</code></th><td><a>object property</a></td><td></td></tr>
            <tr><th><code>references</code></th><td><a>link property</a></td><td></td></tr>
            <tr><th><code>relation</code></th><td><a>link property</a></td><td></td></tr>
            <tr><th><code>replaces</code></th><td><a>link property</a></td><td></td></tr>
            <tr><th><code>requires</code></th><td><a>link property</a></td><td></td></tr>
            <tr><th><code>rights</code></th><td><a>object property</a></td><td></td></tr>
            <tr><th><code>rightsHolder</code></th><td><a>object property</a></td><td></td></tr>
            <tr><th><code>source</code></th><td><a>link property</a></td><td></td></tr>
            <tr><th><code>spatial</code></th><td><a>object property</a></td><td></td></tr>
            <tr><th><code>subject</code></th><td><a>object property</a></td><td></td></tr>
            <tr><th><code>tableOfContents</code></th><td><a>natural language property</a></td><td></td></tr>
            <tr><th><code>temporal</code></th><td><a>object property</a></td><td></td></tr>
            <tr><th><code>title</code></th><td><a>natural language property</a></td><td></td></tr>
            <tr><th><code>type</code></th><td><a>object property</a></td><td></td></tr>
            <tr><th><code>valid</code></th><td><a>atomic property</a></td><td>dates in the format <code>YYYY-MM-DD</code></td></tr>
          </table>
          <p class="issue">
            The adoption of <code>type</code> from DC-TERMS means that the datatype of cells is indicated through <code>datatype</code> instead.
          </p>
        </section>
        <section>
          <h4>Links</h4>
          <p>
            Description MAY include properties for registered <a href="http://www.iana.org/assignments/link-relations/link-relations.xhtml">link relations</a>, prefixed by <code>link:</code>. This specification does not define any application behaviour associated with these properties being present, except that validation of metadata files MUST check that, if they are present, they have values that are URLs or arrays of URLs. The following properties are particularly relevant to tabular data:
          </p>
          <ul>
            <li><code>link:alternate</code></li>
            <li><code>link:canonical</code></li>
            <li><code>link:collection</code></li>
            <li><code>link:duplicate</code></li>
            <li><code>link:glossary</code></li>
            <li><code>link:help</code></li>
            <li><code>link:icon</code></li>
            <li><code>link:last</code></li>
            <li><code>link:latest-version</code></li>
            <li><code>link:next</code></li>
            <li><code>link:original</code></li>
            <li><code>link:predecessor-version</code></li>
            <li><code>link:prev</code> or <code>link:previous</code></li>
            <li><code>link:preview</code></li>
            <li><code>link:profile</code></li>
            <li><code>link:related</code></li>
            <li><code>link:search</code></li>
            <li><code>link:self</code></li>
            <li><code>link:start</code></li>
            <li><code>link:successor-version</code></li>
            <li><code>link:terms-of-service</code></li>
            <li><code>link:up</code></li>
            <li><code>link:version-history</code></li>
            <li><code>link:working-copy</code></li>
            <li><code>link:working-copy-of</code></li>
          </ul>
          <p class="issue">
            Unlike the Dublin Core terms, link relations are an ever-expanding list and there may eventually be clashes between link relation terms and those defined above. That's why the above list uses QNames for all link relations, so that they look like <code>link:<var>relation</var></code> rather than plain <code><var>relation</var></code>.
          </p>
        </section>
      </section>
      <!--
      <section>
        <h3>Table Groups</h3>
        <p>
          Groups of tabular data files are often provided within a self-contained package, though they do not have to be.
        </p>
        <p class="note">
          The following is a more-or-less direct copy from <a href="http://dataprotocols.org/data-packages/">Data Package Format</a>, with added issues.
        </p>
        <section>
          <h4>Required Fields</h4>
          <p>A valid metadata document MUST include the following fields:</p>
          <ul>
            <li>
              <p><code>name</code> (required) - short url-usable (and preferably human-readable) name of
          the package. This MUST be lower-case and contain only alphanumeric characters
          along with “.”, “_” or “-“ characters. It will function as a unique
          identifier and therefore SHOULD be unique in relation to any registry in
          which this package will be deposited (and preferably globally unique).</p>

              <p>The name SHOULD be invariant, meaning that it SHOULD NOT change when a data
          package is updated, unless the new package version should be considered a
          distinct package, e.g. due to significant changes in structure or
          interpretation. Version distinction SHOULD be left to the version field. As
          a corollary, the name also SHOULD NOT include an indication of time range
          covered.</p>
            </li>
          </ul>
          <p class="issue">
            The requirement for a name seems more like a requirement for metadata used within a package registry than when interpreting CSV files (which might or might not be in a package). Should <code>name</code> be required? Should it have the syntactic constraints described above?
          </p>
          <p>In addition to the above fields, it is recommended that the following fields SHOULD 
        be included in every package descriptor:</p>
          <p class="issue">
            There are four levels of requirement here: MUST, SHOULD, MAY ("recommended") and optional. In practice, given that the metadata is completely extensible, there are probably only two practical levels: required (ie if the annotation is absent anything validating the metadata file MUST raise an error) and optional, so probably worth reclassifying in that way. Should anything be required?
          </p>
          <ul>
            <li>
              <p><code>resources</code> - a JSON array of hashes that describe the contents of 
          the package. The structure of the resource hash is described in the “Resource Information”
          section.</p>
              <p class="issue">
                This should be reworded not to be reliant as a property, not reliant on JSON.
              </p>
            </li>
            <li>
              <p><code>license</code> (or <code>licenses</code>) - is a field specifying the license (or licenses)
          under which the package is provided. You MAY specify either a <code>license</code> field
          or a <code>licenses</code> field but NOT both.</p>
              <p class="issue">
                Suggest having a single annotation (<code>license</code>) and leaving the pluralisation to the JSON serialisation.
              </p>
              <p><strong>This property is not legally binding and does not necessarily mean your
          package is licensed under the terms you define in this property.</strong></p>
              <p class="issue">
                Not clear what the point is of providing licence information in the metadata file if it can't be interpreted by receivers of the metadata as indicating the licence that the data is being made available under?
              </p>
              <ul>
                <li>
                  <p><code>license</code> MUST be a string and its value SHOULD be an <a href="http://licenses.opendefinition.org/">Open Definition license
          ID</a> (preferably one that is <a href="http://opendefinition.org/licenses/">Open Definition
          approved</a>.</p>

                  <pre><code>{ "license" : "PDDL-1.0" }
          </code></pre>
                  <p class="issue">
                    Constrain to a URL instead?
                  </p>
                </li>
                <li>
                  <p><code>licenses</code> MUST be an array. Each entry MUST be a hash with a <code>type</code> and a
          <code>url</code> property linking to the actual text. The <code>type</code> SHOULD be an [Open
          Definition license ID][od-license] if an ID exists for the license and
          otherwise may be the general license name or identifier. Here is an
          Example:</p>

                  <pre><code>"licenses": [{
            "type": "PDDL-1.0",
            "url": "http://opendatacommons.org/licenses/pddl/"
          }]
          </code></pre>
                </li>
              </ul>
            </li>
            <li>
              <p><code>datapackage_version</code> - the version of the data package specification this
          datapackage.json conforms to. It should follow the Semantic Versioning
          requirements (http://semver.org/). The current version of this specification is given at 
          the top of this document.</p>
              <p class="issue">
                This should probably be a serialisation thing rather than a metadata property, as it's about the format of the metadata file rather than of the group of tables.
              </p>
            </li>
          </ul>
        </section>
        <section>
          <h4>Recommended Fields</h3>
          <p class="issue">
            Align these to Dublin Core / DCAT?
          </p>
          <p>Additionally, a package descriptor MAY include the following keys and values:</p>
          <ul>
            <li><code>title</code> - a title or one sentence description for this package</li>
            <li><code>description</code> - a description of the package. The first paragraph (up to the
          first double line break should be usable as summary information for the package)</li>
            <li><code>homepage</code> - URL string for the data packages web site</li>
            <li><code>version</code> - a version string identifying the version of the package. It should conform to the Semantic Versioning requirements
          (http://semver.org/).</li>
            <li>
              <p><code>sources</code> - an array of source hashes. Each source hash may have <code>name</code>, <code>web</code> and <code>email</code> fields. Example:</p>

              <pre><code>"sources": [{
            "name": "World Bank and OECD",
            "web": "http://data.worldbank.org/indicator/NY.GDP.MKTP.CD"
          }]
          </code></pre>
            </li>
            <li><code>keywords</code> - an Array of string keywords to assist users searching for the
          package in catalogs.</li>
            <li><code>image</code> - a link to an image to use for this data package</li>
          </ul>
        </section>
        <section>
          <h4>Optional Fields</h4>
          <p class="issue">
            Align these to Dublin Core / DCAT?
          </p>
          <ul>
            <li><code>maintainers</code> - Array of maintainers of the package. Each maintainer is a hash
          which must have a “name” property and may optionally provide “email” and
          “web” properties.</li>
            <li>
              <p><code>contributors</code> - an Array of hashes each containing the details of a
          contributor. Must contain a ‘name’ property and MAY contain an email and web
          property. By convention, the first contributor is the original author of the
          package. Example:</p>

              <pre><code>"contributors":[ {
            "name": "Joe Bloggs",
            "email": "joe@bloggs.com",
            "web": "http://www.bloggs.com"
          }]
          </code></pre>
            </li>
            <li><code>publisher</code> - like contributors </li>
            <li><code>base</code> - a base URI used to resolve <code>resources</code> that specify relative paths in
          the event that the actual data files specified by those resource paths are not
          located in the same directory in which the descriptor file (<code>datapackage.json</code>)
          resides.</li>
            <li>
              <p><code>dataDependencies</code> - Hash of prerequisite data packages on which this package
          depends in order to install. Follows same format as CommonJS Packages spec
          v1.1.Each dependency defines the lowest compatible MAJOR[.MINOR[.PATCH]]
          dependency versions (only one per MAJOR version) with which the package has
          been tested and is assured to work. The version may be a simple version
          string (see the version property for acceptable forms), or it may be a hash
          group of dependencies which define a set of options, any one of which
          satisfies the dependency. The ordering of the group is significant and
          earlier entries have higher priority. Example:</p>

              <pre><code>"dataDependencies": {
             "country-codes": "",
             "unemployment": "2.1",
             "geo-boundaires": {
               "acmecorp-geo-boundaries": ["1.0", "2.0"],
               "othercorp-geo-boundaries": "0.9.8",
             },
          }
          </code></pre>
              <p class="issue">
                This is again about package management rather than interpretation of tabular data, so suggest omitting it from this specification.
              </p>
            </li>
          </ul>

          <div class="note">
            <p>NOTE: A Data Package author MAY add any number of additional fields beyond those
          listed in the specification here.  For example, suppose you were storing
          time series data and want to list the temporal coverage of the data in the
          Data Package you could add a field <code>temporal</code> (cf <a href="http://dublincore.org/documents/usageguide/qualifiers.shtml#temporal">Dublin Core</a>):</p>

            <pre><code>"temporal": {
            "name": "19th Century",
            "start": "1800-01-01",
            "end": "1899-12-31"
          }
          </code></pre>

            <p>This flexibility enables specific communities to extend Data Packages as
          appropriate for the data they manage. As an example, the <a href="/tabular-data-package/">Tabular Data
          Package</a> specification extends Data Package to the case
          where all the data is tabular and stored in CSV.</p>
          </div>
        </section>
      </section>
    -->
      <section>
        <h3>Tables</h3>
        <p>
          Metadata data associated with tables describes either the table itself or all the data in the table, depending on the property.
        </p>
        <section>
          <h4>Required Properties</h4>
          <dl>
            <dt id="table-id"><code>@id</code></dt>
            <dd>
              <p>
                This gives the URL of the CSV file that the table is held in, relative to the location of the metadata document.
              </p>
              <p class="issue">
                Technically, the CSV file might not be the same as the table that it contains. For example, a given CSV file might contain two tables (in different regions of the CSV file), or might contain a table that isn't positioned at the top left of the CSV file. Given this, should we use a different property than <code>@id</code> to indicate the CSV file that the table comes from?
              </p>
            </dd>
          </dl>
          <p class="issue">
            It's possible to alias all the JSON-LD keywords, for example to use <code>url</code> instead of <code>@id</code>, but would that be useful?
          </p>
        </section>
        <section>
          <h4>Optional Properties</h4>
          <p>
            The description of a table MAY also contain:
          </p>
          <dl>
            <dt id="table-ld-type"><code>@type</code></dt>
            <dd>
              If included, <code>@type</code> MUST be set to <code>"Table"</code>. Publishers MAY include this to provide additional information to JSON-LD based toolchains.
            </dd>
            <dt id="table-direction"><code>table-direction</code></dt>
            <dd>
              <p>
                One of <code>"rtl"</code>, <code>"ltr"</code> or <code>"default"</code>. Indicates whether the table should be displayed with the first column on the right, on the left, or based on the first character in the table that has a specific direction. See <a href="#bidirectional-tables" class="sectionRef"></a> for more details.
              </p>
              <p class="issue">
                This should really be a controlled vocabulary in JSON-LD, but I think that would mean saying <code>bidi:rtl</code> and <code>bidi:ltr</code> were the possible values for the property, rather than simply <code>rtl</code> and <code>ltr</code>. Have I missed something?
              </p>
            </dd>
            <dt id="table-columns"><code>columns</code></dt>
            <dd>
              <p>
                An array of column descriptions as described in <a href="#columns" class="sectionRef"></a>. These are matched to columns by position: the first column description in the array applies to the first column in the table, the second to the second and so on.
              </p>
              <p>
                The <a href="#column-name"><code>name</code></a> properties of the column descriptions MUST be unique within a given table description.
              </p>
              <p class="issue">
                We will need a mechanism for pointing to a schema in a separate document (for reusability).
              </p>
            </dd>
            <dt id="table-rows"><code>rows</code></dt>
            <dd>
              <p>
                An array of row descriptions as described in <a href="#rows" class="sectionRef"></a>. These are matched to row by the value of the <code>row</code> in the row description. The values of the <code>row</code> properties MUST be unique within a given table description (ie no row can have more than one description).
              </p>
            </dd>
            <dt id="table-cells"><code>cells</code></dt>
            <dd>
              <p>
                An array of cell descriptions as described in <a href="#cells" class="sectionRef"></a>. These are matched to cell by the value of the <code>row</code> and <code>column</code> properties in the cell description. The combination of values of the <code>row</code> and <code>column</code> properties MUST be unique within a given table description (ie no cell can have more than one description).
              </p>
            </dd>
            <dt id="table-primaryKey"><code>primaryKey</code></dt>
            <dd>
              <p>
                An <a>internal reference property</a> that holds either a single references to a column description object or an array of references.
              </p>
              <p>
                Validators MUST check that each row has a unique combination of cells in the indicated columns. For example, if <code>primaryKey</code> is set to <code>["_:familyName", "_:givenName"]</code> then every row must have a unique value for the combination of the <code>familyName</code> and <code>givenName</code> columns.
              </p>
              <p class="issue">
                When referencing columns for a primary key, it is a lot clearer to reference them by name rather than by number. For JSON-LD compatibility, we have to assign a blank node identifier to each column even though they each have a <code>name</code> property that could be used instead. It would be great to avoid having the extra <code>_:</code> syntax which will just seem weird to people who don't care about RDF.
              </p>
            </dd>
          </dl>
          <p class="issue">
            Should we include any properties that help in the parsing of the file, eg data package includes <code>encoding</code>?
          </p>
          <p class="issue">
            Should we include any properties that help in checking the integrity of the file, eg data package includes <code>bytes</code> and <code>hash</code>? We could possibly reuse the <a href="http://www.w3.org/TR/SRI/">Subresource Integrity</a> work here.
          </p>
          <p>
            The description MAY contain any of the properties defined in <a href="#common-properties" class="sectionRef"></a> to describe the table. As well as links to other related tables, the following common properties are particularly suitable for tables:
          </p>
          <ul>
            <li><code>created</code></li>
            <li><code>creator</code></li>
            <li><code>description</code></li>
            <li><code>language</code></li>
            <li><code>license</code></li>
            <li><code>modified</code></li>
            <li><code>provenance</code></li>
            <li><code>publisher</code></li>
            <li><code>rights</code></li>
            <li><code>rightsHolder</code></li>
            <li><code>source</code></li>
            <li><code>spatial</code></li>
            <li><code>subject</code></li>
            <li><code>temporal</code></li>
            <li><code>title</code></li>
          </ul>
          <p>
            The description MAY contain any of the <a title="inherited property">inherited properties</a> defined for cells in <a href="#inherited-properties" class="sectionRef"></a>.
          </p>
        </section>
        <!--
        <section>
          <h4>Foreign Keys</h4>

          <div class="alert alert-success">
          Foreign Keys by necessity must be able to reference other data objects. These
          data objects require a specific structure for the spec to work. This spec
          assumes the data objects being referenced are <a href="/data-packages/">Data
          Packages</a>. Thus, to use Foreign Keys you must be referencing Data Packages.
          </div>

          <p>A foreign key is a reference where entries in a given field (or fields) on this
          table (‘resource’ in data package terminology) is a reference to an entry in a
          field (or fields) on a separate resource.</p>

          <p>The <code>foreignKeys</code> attribute, if present, MUST be an Array. Each entry in the
          array must be a <code>foreignKey</code>. A <code>foreignKey</code> MUST be a Hash and:</p>

          <ul>
            <li><code>MUST</code> have an attribute <code>fields</code>. <code>fields</code> is a string or array specifying the 
          field or fields on this resource that form the source part of the foreign
          key. The structure of the string or array is as per <code>primaryKey</code> above.</li>
            <li><code>MUST</code> have an attribute <code>reference</code> which MUST be a Hash. The Hash
              <ul>
                <li><code>MAY</code> have an attribute <code>datapackage</code>. This attribute is a string being a url or
          name to a datapackage. If absent the implication is that this is a
          reference to a resource within the current data package.</li>
                <li><code>MUST</code> have an attribute <code>resource</code> which is the name of the resource
          within the referenced data package</li>
                <li><code>MUST</code> have an attribute <code>fields</code> which is a string if the outer <code>fields</code> is a
          string, else an array of the same length as the outer <code>fields</code>, describing the
          field (or fields) references on the destination resource. The structure of
          the string or array is as per <code>primaryKey</code> above.</li>
              </ul>
            </li>
          </ul>

          <p>Here’s an example:</p>

          <pre><code>  "fields": [
              {
                "name": "state"
              }
            ],
            "foreignKeys": [
              {
                "fields": "state"
                "reference": {
                  "datapackage": "http://data.okfn.org/data/mydatapackage/",
                  "resource": "the-resource",
                  "fields": "state_id"
                }
              }
            ]
          </code></pre>
        </section>
      -->
      </section>

      <section>
        <h3>Columns</h3>
        <p>
          A column description is a simple JSON object that describes a single column. The description provides additional human-readable documentation for a column, as well as additional information that may be used to validate the cells within the column, create a user interface for data entry, or inform conversion into other formats.
        </p>
        <p>
          There are no required properties for column descriptors.
        </p>
        <section>
          <h4>Required Properties</h4>
          <dl>
            <dt id="column-name"><code>name</code></dt>
            <dd>
              <p>
                An <a>atomic property</a> that gives a canonical name for the column. This MUST be a string. Conversion specifications MUST use this property as the basis for the names of properties/elements/attributes in the results of conversions.
              </p>
              <p class="issue">
                Suggest we have some syntactic limitations on names, to make it easy to use them as the basis of JSON properties, XML elements and so on. For example, not containing spaces would be good.
              </p>
              <p>
                During validation, if there is no <code>title</code> property and the column already has a <code>title</code> annotation then a validator MUST issue a warning if the existing <code>title</code> annotation does not match the <code>name</code> specified in the column description.
              </p>
            </dd>
          </dl>
        </section>
        <section>
          <h4>Optional Properties</h4>
          <dl>
            <dt id="column-title"><code>title</code></dt>
            <dd>
              <p>
                A <a>natural language property</a> that provides possible alternative names for the column. The <dfn>possible column titles</dfn> are defined as:
              </p>
              <ul>
                <li>if the value of <code>title</code> is a string, that string</li>
                <li>if the value of <code>title</code> is an array, the strings in that array</li>
                <li>if the value of <code>title</code> is an object, the string or strings that are the value of the property of that object whose name is the <a>column language</a></li>
              </ul>
              <p>
                where the <dfn>column language</dfn> is the value of the <code>language</code> property on the column description, or (if there is no such language), the value of the <code>language</code> property on the table description.
              </p>
              <p>
                If the column already has a <code>title</code> annotation (because a header row has been included in the original CSV file) then a validator MUST issue a warning if the existing <code>title</code> annotation is not the same as any of the <a>possible column titles</a>.
              </p>
              <p class="note">
                The facility to specify multiple potential titles for a column is important when the same column description is used for multiple CSVs, through a mechanism yet to be defined by this specification.
              </p>
            </dd>
            <dt id="column-ld-type"><code>@type</code></dt>
            <dd>
              <p>
                If included, <code>@type</code> MUST be set to <code>"Column"</code>. Publishers MAY include this to provide additional information to JSON-LD based toolchains.
              </p>
              <p class="issue">
                Having both a <code>@type</code> property and a <code>type</code> property is confusing. Should we rename <code>@type</code> in the JSON-LD context? What to?
              </p>
            </dd>
            <dt id="column-required"><code>required</code></dt>
            <dd>A boolean value which indicates whether every cell within the column must have a non-null value.</dd>
          </dl>
          <p>
            The description MAY contain any of the properties defined in <a href="#common-properties" class="sectionRef"></a> to describe the column.
          </p>
          <p>
            The description MAY contain any of the <a title="inherited property">inherited properties</a> defined for cells in <a href="#inherited-properties" class="sectionRef"></a>.
          </p>
        </section>
      </section>
      <section>
        <h3>Rows</h3>
        <p>
          Rows can be described using row <a title="description object">description objects</a>. A row description object is a JSON object within a metadata file that includes properties that describe an individual row.
        </p>
        <section>
          <h4>Required Properties</h4>
          <p>
            The following properties MUST appear on a row description:
          </p>
          <dl>
            <dt><code>row</code></dt>
            <dd>an integer; the number of the row the description object describes</dd>
          </dl>
          <div class="note">
            <p>
              The value of the <code>row</code> property indicates the position of the row within the table rather than the position of the row within the original CSV file. For example, a CSV file might contain padding columns and skipped headers, as in:
            </p>
            <pre>
,"Expenditure over £25,000- Payment made in January 2014",,,,,,,,
,,,,,,,,,
,Department Family,Entity,Date,Expense Type,Expense Area,Supplier,Transaction Number,Amount in Sterling,
,Department of Health,The Royal Wolverhampton Hospitals NHS Trust RL4,31/01/2014,Capital Project,Capital,STRYKER UK LTD,0001337928,31896.06,
,Department of Health,The Royal Wolverhampton Hospitals NHS Trust RL4,17/01/2014,SERVICE AGREEMENTS,Pathology,ABBOTT LABORATORIES LTD,0001335058,77775.13,
...
            </pre>
            <p>
              The table (as defined in [[CSV-MODEL]]) begins in the fourth row and second column of the CSV file. The initial column is padding, and the initial columns provide metadata about the table and the columns it contains. The first row in the table contains cells with the values <code>Department of Health</code>,<code>The Royal Wolverhampton Hospitals NHS Trust RL4</code>,<code>31/01/2014</code>,<code>Capital Project</code>,<code>Capital</code>,<code>STRYKER UK LTD</code>,<code>0001337928</code>,<code>31896.06</code>,<code>null</code>. This is equivalent to the row identified by the fragment identifier <code>#row=4</code>.
            </p>
          </div>
        </section>
        <section>
          <h4>Optional Properties</h4>
          <dl>
            <dt id="column-ld-type"><code>@type</code></dt>
            <dd>
              <p>
                If included, <code>@type</code> MUST be set to <code>"Row"</code>. Publishers MAY include this to provide additional information to JSON-LD based toolchains.
              </p>
            </dd>
          </dl>
          <p>
            The description MAY contain any of the properties defined in <a href="#common-properties" class="sectionRef"></a> to describe the row.
          </p>
          <p>
            The description MAY contain any of the <a title="inherited property">inherited properties</a> defined for cells in <a href="#inherited-properties" class="sectionRef"></a>.
          </p>
        </section>
      </section>
      <section>
        <h3>Cells</h3>
        <p>
          Cells can be described using cell <a title="description object">description objects</a>. A cell description object is a JSON object within a metadata file that includes properties that describe an individual cell.
        </p>
        <section>
          <h4>Required Properties</h4>
          <p>
            The following properties MUST appear on a cell description:
          </p>
          <dl>
            <dt><code>row</code></dt>
            <dd>an integer; the number of the row on which the cell appears</dd>
            <dt><code>column</code></dt>
            <dd>an integer; the number of the column on which the cell appears</dd>
          </dl>
          <div class="note">
            <p>
              The values of the <code>row</code> and <code>column</code> properties indicate the position of the cell within the table rather than the position of the cell within the original CSV file. For example, a CSV file might contain padding columns and skipped headers, as in:
            </p>
            <pre>
,"Expenditure over £25,000- Payment made in January 2014",,,,,,,,
,,,,,,,,,
,Department Family,Entity,Date,Expense Type,Expense Area,Supplier,Transaction Number,Amount in Sterling,
,Department of Health,The Royal Wolverhampton Hospitals NHS Trust RL4,31/01/2014,Capital Project,Capital,STRYKER UK LTD,0001337928,31896.06,
,Department of Health,The Royal Wolverhampton Hospitals NHS Trust RL4,17/01/2014,SERVICE AGREEMENTS,Pathology,ABBOTT LABORATORIES LTD,0001335058,77775.13,
...
            </pre>
            <p>
              The table (as defined in [[CSV-MODEL]]) begins in the fourth row and second column of the CSV file. The initial column is padding, and the initial columns provide metadata about the table and the columns it contains. The cell in the first column of the first row has the value "Department of Health". This is equivalent to the cell identified by the fragment identifier <code>#cell=4,2</code>.
            </p>
          </div>
        </section>
        <section>
          <h4>Optional Properties</h4>
          <dl>
            <dt id="column-ld-type"><code>@type</code></dt>
            <dd>
              <p>
                If included, <code>@type</code> MUST be set to <code>"Cell"</code>. Publishers MAY include this to provide additional information to JSON-LD based toolchains.
              </p>
            </dd>
          </dl>
          <p>
            The description MAY contain any of the properties defined in <a href="#common-properties" class="sectionRef"></a> to describe the column.
          </p>
          <p>
            The description MAY contain any of the <a title="inherited property">inherited properties</a> defined for cells in <a href="#inherited-properties" class="sectionRef"></a>.
          </p>
        </section>
        <section>
          <h4>Inherited Properties</h4>
          <p>
            Cell descriptions may override <a title="inherited property">inherited properties</a>, as described in <a href="#created-annotated-tables" class="sectionRef"></a>. It is good practice to define these properties on columns, so that all cells within a given column are handled in the same way. These properties are:
          </p>
          <dl>
            <dt id="cell-empty-value"><code>null</code></dt>
            <dd>
              <p>
                The string used for null values. If not specified, the default for this is the empty string.
              </p>
            </dd>
            <dt id="cell-separator"><code>separator</code></dt>
            <dd>
              <p>
                The character used to separate items in the string value of the cell. If <code>null</code>, the cell does not contain a list. Otherwise, application MUST split the string value of the cell on the specified separator character and parse each of the resulting strings separately. The cell's value will then be a list. Conversion specifications MUST use the separator to determine the conversion of a cell into the target format. See <a href="#parsing-cells"></a> for more details.
              </p>
            </dd>
            <dt id="cell-format"><code>format</code></dt>
            <dd>
              <p>
                A definition of the format of the cell, used when parsing the cell as described in <a href="#parsing-cells"></a>.
              </p>
            </dd>
            <dt id="cell-datatype"><code>datatype</code></dt>
            <dd>
              <p>
                The main datatype of the values of the cell. If the cell contains a list (ie <code>separator</code> is not <code>null</code>) then this is the datatype of each value within the list. Conversion specifications MUST use the datatype of the value to determine the conversion of a cell into the target format. See <a href="#datatypes"></a> for more details.
              </p>
              <p class="issue">
                Using the term <code>datatype</code> rather than <code>type</code> because DCTERMS defines <code>type</code>, and because <code>type</code> is confusing with <code>@type</code>.
              </p>
            </dd>
            <dt id="cell-length"><code>length</code></dt>
            <dd>
              <p>
                The exact length of the value of the cell. See <a href="#length-constraints" class="sectionRef"></a> for details.
              </p>
            </dd>
            <dt id="cell-minLength"><code>minLength</code></dt>
            <dd>
              <p>
                The minimum length of the value of the cell. See <a href="#length-constraints" class="sectionRef"></a> for details.
              </p>
            </dd>
            <dt id="cell-maxLength"><code>maxLength</code></dt>
            <dd>
              <p>
                The maximum length of the value of the cell. See <a href="#length-constraints" class="sectionRef"></a> for details.
              </p>
            </dd>
            <dt id="cell-minimum"><code>minimum</code></dt>
            <dd>
              <p>
                The minimum value for the cell (inclusive); equivalent to <code>minInclusive</code>. See <a href="#value-constraints" class="sectionRef"></a> for details.
              </p>
            </dd>
            <dt id="cell-maximum"><code>maximum</code></dt>
            <dd>
              <p>
                The maximum value for the cell (inclusive); equivalent to <code>maxInclusive</code>. See <a href="#value-constraints" class="sectionRef"></a> for details.
              </p>
            </dd>
            <dt id="cell-minInclusive"><code>minInclusive</code></dt>
            <dd>
              <p>
                The minimum value for the cell (inclusive). See <a href="#value-constraints" class="sectionRef"></a> for details.
              </p>
            </dd>
            <dt id="cell-maxInclusive"><code>maxInclusive</code></dt>
            <dd>
              <p>
                The maximum value for the cell (inclusive). See <a href="#value-constraints" class="sectionRef"></a> for details.
              </p>
            </dd>
            <dt id="cell-minExclusive"><code>minExclusive</code></dt>
            <dd>
              <p>
                The minimum value for the cell (exclusive). See <a href="#value-constraints" class="sectionRef"></a> for details.
              </p>
            </dd>
            <dt id="cell-maxExclusive"><code>maxExclusive</code></dt>
            <dd>
              <p>
                The maximum value for the cell (exclusive). See <a href="#value-constraints" class="sectionRef"></a> for details.
              </p>
            </dd>
            <dt id="cell-text-direction"><code>text-direction</code></dt>
            <dd>
              <p>
                One of <code>"rtl"</code> or <code>"ltr"</code> (the default). Indicates whether the text within the cell should be displayed by default as left-to-right or right-to-left text. See <a href="#bidirectional-tables" class="sectionRef"></a> for more details.
              </p>
            </dd>
          </dl>
        </section>
        <section>
          <h3>Datatypes</h3>
          <p>
            Cells within tables may be annotated with a <code>datatype</code> which indicates the type of the value obtained by parsing the value of the cell. The format expected in the cell is determined by the <code>format</code> annotation, if there is one, or uses a default format determined by the type.
          </p>
          <p>
            The possible datatypes are:
          </p>
          <ul>
            <li>
              <p>the datatypes defined in [[!xmlschema-2]] with the exception of those that rely on XML mechanisms for definition, namely:</p>
              <ul>
                <li><code>anySimpleType</code></li>
                <li><code>string</code>; a sub-value of <code>anySimpleType</code></li>
                <li><code>normalizedString</code>; a sub-value of <code>string</code></li>
                <li><code>token</code>; a sub-value of <code>normalizedString</code></li>
                <li><code>language</code>; a sub-value of <code>token</code></li>
                <li><code>Name</code>; a sub-value of <code>token</code></li>
                <li><code>NCName</code>; a sub-value of <code>Name</code></li>
                <li><code>boolean</code>; a sub-value of <code>anySimpleType</code></li>
                <li><code>decimal</code>; a sub-value of <code>anySimpleType</code></li>
                <li><code>integer</code>; a sub-value of <code>decimal</code></li>
                <li><code>nonPositiveInteger</code>; a sub-value of <code>integer</code></li>
                <li><code>negativeInteger</code>; a sub-value of <code>nonPositiveInteger</code></li>
                <li><code>long</code>; a sub-value of <code>integer</code></li>
                <li><code>int</code>; a sub-value of <code>long</code></li>
                <li><code>short</code>; a sub-value of <code>int</code></li>
                <li><code>byte</code>; a sub-value of <code>short</code></li>
                <li><code>nonNegativeInteger</code>; a sub-value of <code>integer</code></li>
                <li><code>unsignedLong</code>; a sub-value of <code>nonNegativeInteger</code></li>
                <li><code>unsignedInt</code>; a sub-value of <code>unsignedLong</code></li>
                <li><code>unsignedShort</code>; a sub-value of <code>unsignedInt</code></li>
                <li><code>unsignedByte</code>; a sub-value of <code>unsignedShort</code></li>
                <li><code>positiveInteger</code>; a sub-value of <code>nonNegativeInteger</code></li>
                <li><code>float</code>; a sub-value of <code>anySimpleType</code></li>
                <li><code>double</code>; a sub-value of <code>anySimpleType</code></li>
                <li><code>duration</code>; a sub-value of <code>anySimpleType</code></li>
                <li><code>dateTime</code>; a sub-value of <code>anySimpleType</code></li>
                <li><code>time</code>; a sub-value of <code>anySimpleType</code></li>
                <li><code>date</code>; a sub-value of <code>anySimpleType</code></li>
                <li><code>gYearMonth</code>; a sub-value of <code>anySimpleType</code></li>
                <li><code>gYear</code>; a sub-value of <code>anySimpleType</code></li>
                <li><code>gMonthDay</code>; a sub-value of <code>anySimpleType</code></li>
                <li><code>gDay</code>; a sub-value of <code>anySimpleType</code></li>
                <li><code>gMonth</code>; a sub-value of <code>anySimpleType</code></li>
                <li><code>hexBinary</code>; a sub-value of <code>anySimpleType</code></li>
                <li><code>base64Binary</code>; a sub-value of <code>anySimpleType</code></li>
                <li><code>anyURI</code>; a sub-value of <code>anySimpleType</code></li>
              </ul>
            </li>
            <li>the datatype <code>number</code> which is exactly equivalent to <code>double</code></li>
            <li>the datatype <code>binary</code> which is exactly equivalent to <code>base64Binary</code></li>
            <li>the datatype <code>datetime</code> which is exactly equivalent to <code>dateTime</code></li>
            <li>
              <p>
                the datatype <code>geopoint</code> which indicates a comma-separated longitude and latitude (ie values that after stripping leading and trailing whitespace are in the format <code><var>longitude</var>\s*,\s*<var>latitude</var></code>); a sub-value of <code>anySimpleType</code>
              </p>
              <p class="issue">
                In JSON Table Schema, <code>geopoint</code> permits values in JSON representations of points, namely <code>{ lon: <var>longitude</var>, lat: <code>latitude</code>}</code> and <code>[<var>longitude</var>, <var>latitude</var>]</code>. Suggest that these additional formats are supported through the <code>format</code> property.
              </p>
            </li>
            <li>the datatype <code>any</code> which is exactly equivalent to <code>anySimpleType</code></li>
          </ul>
          <p class="issue">
            The JSON Table Schema also includes <code>object</code>, <code>array</code> and <code>geojson</code>. Should we be supporting the inclusion of JSON-based structures within CSV files?
          </p>
          <p class="issue">
            Is the <code>any</code> type useful?
          </p>
          <p class="issue">
            Should there be types for formats like XML, HTML and markdown?
          </p>
          <section>
            <h4>Length Constraints</h4>
            <p>
              The <code>length</code>, <code>minLength</code> and <code>maxLength</code> properties indicate the exact, minimum and maximum lengths of the values of cells.
            </p>
            <p>
              Applications MUST raise an error if both <code>length</code> and <code>minLength</code> are specified and they do not have the same value. Similarly, applications MUST raise an error if both <code>length</code> and <code>maxLength</code> are specified and they do not have the same value. Applications MUST raise an error if <code>length</code>, <code>maxLength</code> or <code>minLength</code> are specified and the cell value is not a list (ie <code>separator</code> is not specified), a string or one of its subtypes, or a binary value.
            </p>
            <p>
              The length of a value of a cell is determined as follows:
            </p>
            <ul>
              <li>if the cell is <code>null</code> its length is zero</li>
              <li>if the value is a list, its length is the number of items in the list</li>
              <li>if the value is a string or one of its subtypes, its length is the number of characters in the value</li>
              <li>if the value is of a binary type, its length is the number of bytes in the binary value</li>
            </ul>
          </section>
          <section>
            <h4>Value Constraints</h4>
            <p>
              The <code>minimum</code>, <code>maximum</code>, <code>minInclusive</code>, <code>maxInclusive</code>, <code>minExclusive</code> and <code>maxExclusive</code> properties indicate limits on the values of cells. These apply to numeric and date/time types. The <code>minimum</code> property is equivalent to the <code>minInclusive</code> property and the <code>maximum</code> property is equivalent to the <code>maxInclusive</code> property.
            </p>
            <p>
              Validation against these properties is as defined in [[!xmlschema-2]].
            </p>
          </section>
        </section>
        <section>
          <h3>Parsing cells</h3>
          <p>
            Unlike many other data formats, tabular data is designed to be read by humans. For that reason, it's common for data to be represented within tabular data in a human-readable way. The <code>separator</code> and <code>format</code> properties indicates the format used to represent data within the table. This is used:
          </p>
          <ul>
            <li>by <strong>validators</strong> to check that the data in the table is in the expected format</li>
            <li>by <strong>converters</strong> to parse the values before mapping them into values in the target of the conversion</li>
            <li>when <strong>displaying</strong> data, to map it into formats that are meaningful for those viewing the data (as opposed to those publishing it)</li>
            <li>when <strong>inputting</strong> data, to turn entered values into representations in a consistent format</li>
          </ul>
          <p>
            The process of parsing the string value of a cell into a single value or a list of values is as follows:
          </p>
          <ol>
            <li>unless the <code>datatype</code> is <code>string</code> or <code>anySimpleType</code> or <code>any</code>, strip leading and trailing whitespace from the value</li>
            <li>if the value is the same as the <code>null</code> value, then the value is <code>null</code></li>
            <li>if the <code>separator</code> property is not <code>null</code>, create a list of values by splitting the string at the character specified by the <code>separator</code> property</li>
            <li>validate the value(s) against the <code>format</code>, if one is specified, as described below; raise an error if any of the values do not match the specified format</li>
            <li>parse the value(s) using the <code>format</code>, as described below</li>
          </ol>
          <section>
            <h4>Formats for strings</h4>
            <p>
              If the <code>datatype</code> is a string type, the <code>format</code> property provides a regular expression for the string values, in the syntax defined by [[!ECMASCRIPT]].
            </p>
            <p class="issue">
              Is this the right reference to use for regular expressions? Could use XML Schema ones or XPath ones instead?
            </p>
          </section>
          <section>
            <h4>Formats for numeric types</h4>
            <p>
              It is not uncommon for numbers within tabular data to be formatted for human consumption, which may involve using commas for decimal points, grouping digits in the number using commas, or adding currency symbols or percent signs to the number.
            </p>
            <p>
              If the <code>datatype</code> is a numeric type, the <code>format</code> property indicates the expected format for that number. Validators MUST check that the numbers in the column adhere to the specified format. Converters MUST use the <code>format</code> property to parse the number when mapping it into a suitable type in the target language of the conversion.
            </p>
            <p>
              When the <code>datatype</code> is a numeric type, the <code>format</code> property's value MUST be a number format as specified in [[!xslt-21]].
            </p>
            <p class="issue">
              Is this the right reference to use for parsing numbers? Would a printf syntax be better?
            </p>
          </section>
          <section>
            <h4>Formats for booleans</h4>
            <p>
              Boolean values may be represented in many ways aside from the standard <code>1</code> and <code>0</code> or <code>true</code> and <code>false</code>.
            </p>
            <p>
              If the <code>datatype</code> is <code>boolean</code>, the <code>format</code> property provides the true and false values expected, separated by <code>|</code>. For example if <code>format</code> is <code>Y|N</code> then cells must hold either <code>Y</code> or <code>N</code> with <code>Y</code> meaning <code>true</code> and <code>N</code> meaning <code>false</code>.
            </p>
          </section>
          <section>
            <h4>Formats for dates and times</h4>
            <p>
              Dates and times are commonly represented in tabular data in formats other than those defined in [[!xmlschema-2]].
            </p>
            <p>
              If the <code>datatype</code> is a date or time type, the <code>format</code> property indicates the expected format for that date or time. Validators MUST check that the dates or times in the column adhere to the specified format. Converters MUST use the <code>format</code> property to parse the date or time when mapping it into a suitable type in the target language of the conversion.
            </p>
            <p>
              When the <code>datatype</code> is a date or time type, the <code>format</code> property's value MUST be a date/time format as specified in [[!xslt-21]].
            </p>
            <p class="issue">
              Is this the right reference to use for parsing dates and times? Would a printf syntax be better?
            </p>
          </section>
          <section>
            <h4>Formats for durations</h4>
            <p class="issue">
              Are there standard formats for describing how to parse durations that we can crib from?
            </p>
          </section>
        </section>
        <section>
          <h3>Additional Constraints</h3>

          <p>A set of constraints can be associated with a cell. These constraints can be used 
          to validate data against a JSON Table Schema. The constraints might be used by consumers 
          to validate, for example, the contents of a data package, or as a means to validate 
          data being collected or updated via a data entry interface.</p>

          <p>A constraints descriptor is a JSON hash. It <code>MAY</code> contain any of the following 
          keys.</p>

          <ul>
            <li><code>minLength</code> – An integer that specifies the minimum number of characters for a value</li>
            <li><code>maxLength</code> – An integer that specifies the maximum number of characters for a value</li>
            <li><code>unique</code> – A boolean. If <code>true</code>, then all values for that cell MUST be unique within the 
          data file in which it is found. This defines a unique key for a row although a row could 
          potentially have several such keys.</li>
            <li><code>pattern</code> – A regular expression that can be used to test cell values. If the regular 
          expression matches then the value is valid. Values will be treated as a string of characters. 
          It is recommended that values of this cell conform to the standard 
          <a href="http://www.w3.org/TR/xmlschema-2/#regexs">XML Schema regular expression syntax</a>. See also 
          <a href="http://www.regular-expressions.info/xml.html">this reference</a>.</li>
            <li><code>minimum</code> – specifies a minimum value for a cell. This is different to <code>minLength</code> which 
          checks number of characters. A <code>minimum</code> value constraint checks whether a cell value is greater than 
          or equal to the specified value. The range checking depends on the <code>type</code> of the cell. E.g. an 
          integer cell may have a minimum value of 100; a date cell might have a minimum date. If a 
          <code>minimum</code> value constraint is specified then the cell descriptor <code>MUST</code> contain a <code>type</code> key</li>
            <li><code>maximum</code> – as above, but specifies a maximum value for a cell.</li>
          </ul>

          <p>A constraints descriptor may contain multiple constraints, in which case a consumer <code>MUST</code> apply 
          all the constraints when determining if a cell value is valid.</p>

          <p>A data file, e.g. an entry in a data package, is considered to be valid if all of its cells are valid 
          according to their declared <code>type</code> and <code>constraints</code>.</p>

        </section>
      </section>
    </section>
    <section>
      <h2>Metadata in JSON</h2>
      <p class="issue">
        Add example of what it looks like.
      </p>
      <section>
        <h3>JSON-LD Context</h3>
        <p class="issue">
          Provide the context file for JSON-LD-based processing of metadata files.
        </p>
      </section>
      <section>
        <h3><code>application/csvm+json</code> Media Type</h3>
        <p class="issue">
          Provide definition of the media type here.
        </p>
      </section>
    </section>
    <section class="appendix">
      <h2>Acknowledgements</h2>
      <p>
        This document is largely a copy of content from the <a href="http://dataprotocols.org/data-packages/">Data Package</a> specification and the <a href="http://dataprotocols.org/json-table-schema/">JSON Table Schema</a>, which are maintained as part of <a href="http://dataprotocols.org/">Data Protocols</a>. Particular contributors to that work are Rufus Pollock, Paul Fitzpatrick, Andrew Berkeley, Francis Irving, Benoit Chesneau, Leigh Dodds, Martin Keegan, and Gunnlaugur Thor Briem.
      </p>
    </section>
    <section class="appendix">
      <h2>IANA Considerations</h2>
      <section>
        <h3>Registration of <code>application/csvm+json</code></h3>
        <p class="issue">TODO</p>
      </section>
    </section>
    <section class="appendix">
      <h2>JSON-LD Context</h2>
      <p>
        The following JSON document is the JSON-LD context document that can be used to interpret metadata documents as RDF.
      </p>
      <p class="issue">
        See <a href="csvm-context.json">csvm-context.json</a>.
      </p>
    </section>
  </body>
</html>

